commit 5575da1ffdf860588f8a1da9557f1fbc6d86b649
Author: James Sedgwick <jsedgwick@fb.com>
Date:   Tue May 26 15:14:41 2015 -0700

    copy wangle back into folly
    
    Summary: copy everything but example/
    
    Test Plan: fbconfig -r folly/wangle && fbmake runtests
    
    Reviewed By: hans@fb.com
    
    Subscribers: fugalh, ps, bmatheny, folly-diffs@, jsedgwick, yfeldblum, markdrayton, chalfant
    
    FB internal diff: D2100811
    
    Tasks: 5802833
    
    Signature: t1:2100811:1432678173:6c336fe53aa223993f6f82de4ac91b3c19beacf1

diff --git a/folly/wangle/acceptor/Acceptor.cpp b/folly/wangle/acceptor/Acceptor.cpp
new file mode 100644
index 0000000..8ef0d18
--- /dev/null
+++ b/folly/wangle/acceptor/Acceptor.cpp
@@ -0,0 +1,456 @@
+/*
+ *  Copyright (c) 2015, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+#include <folly/wangle/acceptor/Acceptor.h>
+
+#include <folly/wangle/acceptor/ManagedConnection.h>
+#include <folly/wangle/ssl/SSLContextManager.h>
+
+#include <boost/cast.hpp>
+#include <fcntl.h>
+#include <folly/ScopeGuard.h>
+#include <folly/io/async/EventBase.h>
+#include <fstream>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <folly/io/async/AsyncSSLSocket.h>
+#include <folly/io/async/AsyncSocket.h>
+#include <gflags/gflags.h>
+#include <unistd.h>
+
+using folly::wangle::ConnectionManager;
+using folly::wangle::ManagedConnection;
+using std::chrono::microseconds;
+using std::chrono::milliseconds;
+using std::filebuf;
+using std::ifstream;
+using std::ios;
+using std::shared_ptr;
+using std::string;
+
+namespace folly {
+
+#ifndef NO_LIB_GFLAGS
+DEFINE_int32(shutdown_idle_grace_ms, 5000, "milliseconds to wait before "
+             "closing idle conns");
+#else
+const int32_t FLAGS_shutdown_idle_grace_ms = 5000;
+#endif
+
+static const std::string empty_string;
+std::atomic<uint64_t> Acceptor::totalNumPendingSSLConns_{0};
+
+/**
+ * Lightweight wrapper class to keep track of a newly
+ * accepted connection during SSL handshaking.
+ */
+class AcceptorHandshakeHelper :
+      public AsyncSSLSocket::HandshakeCB,
+      public ManagedConnection {
+ public:
+  AcceptorHandshakeHelper(AsyncSSLSocket::UniquePtr socket,
+                          Acceptor* acceptor,
+                          const SocketAddress& clientAddr,
+                          std::chrono::steady_clock::time_point acceptTime,
+                          TransportInfo& tinfo)
+    : socket_(std::move(socket)), acceptor_(acceptor),
+      acceptTime_(acceptTime), clientAddr_(clientAddr),
+      tinfo_(tinfo) {
+    acceptor_->downstreamConnectionManager_->addConnection(this, true);
+    if(acceptor_->parseClientHello_)  {
+      socket_->enableClientHelloParsing();
+    }
+    socket_->sslAccept(this);
+  }
+
+  virtual void timeoutExpired() noexcept override {
+    VLOG(4) << "SSL handshake timeout expired";
+    sslError_ = SSLErrorEnum::TIMEOUT;
+    dropConnection();
+  }
+  virtual void describe(std::ostream& os) const override {
+    os << "pending handshake on " << clientAddr_;
+  }
+  virtual bool isBusy() const override {
+    return true;
+  }
+  virtual void notifyPendingShutdown() override {}
+  virtual void closeWhenIdle() override {}
+
+  virtual void dropConnection() override {
+    VLOG(10) << "Dropping in progress handshake for " << clientAddr_;
+    socket_->closeNow();
+  }
+  virtual void dumpConnectionState(uint8_t loglevel) override {
+  }
+
+ private:
+  // AsyncSSLSocket::HandshakeCallback API
+  virtual void handshakeSuc(AsyncSSLSocket* sock) noexcept override {
+
+    const unsigned char* nextProto = nullptr;
+    unsigned nextProtoLength = 0;
+    sock->getSelectedNextProtocol(&nextProto, &nextProtoLength);
+    if (VLOG_IS_ON(3)) {
+      if (nextProto) {
+        VLOG(3) << "Client selected next protocol " <<
+            string((const char*)nextProto, nextProtoLength);
+      } else {
+        VLOG(3) << "Client did not select a next protocol";
+      }
+    }
+
+    // fill in SSL-related fields from TransportInfo
+    // the other fields like RTT are filled in the Acceptor
+    tinfo_.ssl = true;
+    tinfo_.acceptTime = acceptTime_;
+    tinfo_.sslSetupTime = std::chrono::duration_cast<std::chrono::milliseconds>(
+      std::chrono::steady_clock::now() - acceptTime_
+    );
+    tinfo_.sslSetupBytesRead = sock->getRawBytesReceived();
+    tinfo_.sslSetupBytesWritten = sock->getRawBytesWritten();
+    tinfo_.sslServerName = sock->getSSLServerName() ?
+      std::make_shared<std::string>(sock->getSSLServerName()) : nullptr;
+    tinfo_.sslCipher = sock->getNegotiatedCipherName() ?
+      std::make_shared<std::string>(sock->getNegotiatedCipherName()) : nullptr;
+    tinfo_.sslVersion = sock->getSSLVersion();
+    tinfo_.sslCertSize = sock->getSSLCertSize();
+    tinfo_.sslResume = SSLUtil::getResumeState(sock);
+    tinfo_.sslClientCiphers = std::make_shared<std::string>();
+    sock->getSSLClientCiphers(*tinfo_.sslClientCiphers);
+    tinfo_.sslServerCiphers = std::make_shared<std::string>();
+    sock->getSSLServerCiphers(*tinfo_.sslServerCiphers);
+    tinfo_.sslClientComprMethods =
+        std::make_shared<std::string>(sock->getSSLClientComprMethods());
+    tinfo_.sslClientExts =
+        std::make_shared<std::string>(sock->getSSLClientExts());
+    tinfo_.sslNextProtocol = std::make_shared<std::string>();
+    tinfo_.sslNextProtocol->assign(reinterpret_cast<const char*>(nextProto),
+                                  nextProtoLength);
+
+    acceptor_->updateSSLStats(
+      sock,
+      tinfo_.sslSetupTime,
+      SSLErrorEnum::NO_ERROR
+    );
+    acceptor_->downstreamConnectionManager_->removeConnection(this);
+    acceptor_->sslConnectionReady(std::move(socket_), clientAddr_,
+        nextProto ? string((const char*)nextProto, nextProtoLength) :
+                                  empty_string, tinfo_);
+    delete this;
+  }
+
+  virtual void handshakeErr(AsyncSSLSocket* sock,
+                            const AsyncSocketException& ex) noexcept override {
+    auto elapsedTime = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - acceptTime_);
+    VLOG(3) << "SSL handshake error after " << elapsedTime.count() <<
+        " ms; " << sock->getRawBytesReceived() << " bytes received & " <<
+        sock->getRawBytesWritten() << " bytes sent: " <<
+        ex.what();
+    acceptor_->updateSSLStats(sock, elapsedTime, sslError_);
+    acceptor_->sslConnectionError();
+    delete this;
+  }
+
+  AsyncSSLSocket::UniquePtr socket_;
+  Acceptor* acceptor_;
+  std::chrono::steady_clock::time_point acceptTime_;
+  SocketAddress clientAddr_;
+  TransportInfo tinfo_;
+  SSLErrorEnum sslError_{SSLErrorEnum::NO_ERROR};
+};
+
+Acceptor::Acceptor(const ServerSocketConfig& accConfig) :
+  accConfig_(accConfig),
+  socketOptions_(accConfig.getSocketOptions()) {
+}
+
+void
+Acceptor::init(AsyncServerSocket* serverSocket,
+               EventBase* eventBase) {
+  CHECK(nullptr == this->base_);
+
+  if (accConfig_.isSSL()) {
+    if (!sslCtxManager_) {
+      sslCtxManager_ = folly::make_unique<SSLContextManager>(
+        eventBase,
+        "vip_" + getName(),
+        accConfig_.strictSSL, nullptr);
+    }
+    for (const auto& sslCtxConfig : accConfig_.sslContextConfigs) {
+      sslCtxManager_->addSSLContextConfig(
+        sslCtxConfig,
+        accConfig_.sslCacheOptions,
+        &accConfig_.initialTicketSeeds,
+        accConfig_.bindAddress,
+        cacheProvider_);
+      parseClientHello_ |= sslCtxConfig.clientHelloParsingEnabled;
+    }
+
+    CHECK(sslCtxManager_->getDefaultSSLCtx());
+  }
+
+  base_ = eventBase;
+  state_ = State::kRunning;
+  downstreamConnectionManager_ = ConnectionManager::makeUnique(
+    eventBase, accConfig_.connectionIdleTimeout, this);
+
+  if (serverSocket) {
+    serverSocket->addAcceptCallback(this, eventBase);
+
+    for (auto& fd : serverSocket->getSockets()) {
+      if (fd < 0) {
+        continue;
+      }
+      for (const auto& opt: socketOptions_) {
+        opt.first.apply(fd, opt.second);
+      }
+    }
+  }
+}
+
+Acceptor::~Acceptor(void) {
+}
+
+void Acceptor::addSSLContextConfig(const SSLContextConfig& sslCtxConfig) {
+  sslCtxManager_->addSSLContextConfig(sslCtxConfig,
+                                      accConfig_.sslCacheOptions,
+                                      &accConfig_.initialTicketSeeds,
+                                      accConfig_.bindAddress,
+                                      cacheProvider_);
+}
+
+void
+Acceptor::drainAllConnections() {
+  if (downstreamConnectionManager_) {
+    downstreamConnectionManager_->initiateGracefulShutdown(
+      std::chrono::milliseconds(FLAGS_shutdown_idle_grace_ms));
+  }
+}
+
+void Acceptor::setLoadShedConfig(const LoadShedConfiguration& from,
+                       IConnectionCounter* counter) {
+  loadShedConfig_ = from;
+  connectionCounter_ = counter;
+}
+
+bool Acceptor::canAccept(const SocketAddress& address) {
+  if (!connectionCounter_) {
+    return true;
+  }
+
+  uint64_t maxConnections = connectionCounter_->getMaxConnections();
+  if (maxConnections == 0) {
+    return true;
+  }
+
+  uint64_t currentConnections = connectionCounter_->getNumConnections();
+  if (currentConnections < maxConnections) {
+    return true;
+  }
+
+  if (loadShedConfig_.isWhitelisted(address)) {
+    return true;
+  }
+
+  // Take care of comparing connection count against max connections across
+  // all acceptors. Expensive since a lock must be taken to get the counter.
+  auto connectionCountForLoadShedding = getConnectionCountForLoadShedding();
+  if (connectionCountForLoadShedding < loadShedConfig_.getMaxConnections()) {
+    return true;
+  }
+
+  VLOG(4) << address.describe() << " not whitelisted";
+  return false;
+}
+
+void
+Acceptor::connectionAccepted(
+    int fd, const SocketAddress& clientAddr) noexcept {
+  if (!canAccept(clientAddr)) {
+    close(fd);
+    return;
+  }
+  auto acceptTime = std::chrono::steady_clock::now();
+  for (const auto& opt: socketOptions_) {
+    opt.first.apply(fd, opt.second);
+  }
+
+  onDoneAcceptingConnection(fd, clientAddr, acceptTime);
+}
+
+void Acceptor::onDoneAcceptingConnection(
+    int fd,
+    const SocketAddress& clientAddr,
+    std::chrono::steady_clock::time_point acceptTime) noexcept {
+  TransportInfo tinfo;
+  processEstablishedConnection(fd, clientAddr, acceptTime, tinfo);
+}
+
+void
+Acceptor::processEstablishedConnection(
+    int fd,
+    const SocketAddress& clientAddr,
+    std::chrono::steady_clock::time_point acceptTime,
+    TransportInfo& tinfo) noexcept {
+  if (accConfig_.isSSL()) {
+    CHECK(sslCtxManager_);
+    AsyncSSLSocket::UniquePtr sslSock(
+      makeNewAsyncSSLSocket(
+        sslCtxManager_->getDefaultSSLCtx(), base_, fd));
+    ++numPendingSSLConns_;
+    ++totalNumPendingSSLConns_;
+    if (totalNumPendingSSLConns_ > accConfig_.maxConcurrentSSLHandshakes) {
+      VLOG(2) << "dropped SSL handshake on " << accConfig_.name <<
+        " too many handshakes in progress";
+      updateSSLStats(sslSock.get(), std::chrono::milliseconds(0),
+                     SSLErrorEnum::DROPPED);
+      sslConnectionError();
+      return;
+    }
+    new AcceptorHandshakeHelper(
+      std::move(sslSock),
+      this,
+      clientAddr,
+      acceptTime,
+      tinfo
+    );
+  } else {
+    tinfo.ssl = false;
+    tinfo.acceptTime = acceptTime;
+    AsyncSocket::UniquePtr sock(makeNewAsyncSocket(base_, fd));
+    connectionReady(std::move(sock), clientAddr, empty_string, tinfo);
+  }
+}
+
+void
+Acceptor::connectionReady(
+    AsyncSocket::UniquePtr sock,
+    const SocketAddress& clientAddr,
+    const string& nextProtocolName,
+    TransportInfo& tinfo) {
+  // Limit the number of reads from the socket per poll loop iteration,
+  // both to keep memory usage under control and to prevent one fast-
+  // writing client from starving other connections.
+  sock->setMaxReadsPerEvent(16);
+  tinfo.initWithSocket(sock.get());
+  onNewConnection(std::move(sock), &clientAddr, nextProtocolName, tinfo);
+}
+
+void
+Acceptor::sslConnectionReady(AsyncSocket::UniquePtr sock,
+                             const SocketAddress& clientAddr,
+                             const string& nextProtocol,
+                             TransportInfo& tinfo) {
+  CHECK(numPendingSSLConns_ > 0);
+  connectionReady(std::move(sock), clientAddr, nextProtocol, tinfo);
+  --numPendingSSLConns_;
+  --totalNumPendingSSLConns_;
+  if (state_ == State::kDraining) {
+    checkDrained();
+  }
+}
+
+void
+Acceptor::sslConnectionError() {
+  CHECK(numPendingSSLConns_ > 0);
+  --numPendingSSLConns_;
+  --totalNumPendingSSLConns_;
+  if (state_ == State::kDraining) {
+    checkDrained();
+  }
+}
+
+void
+Acceptor::acceptError(const std::exception& ex) noexcept {
+  // An error occurred.
+  // The most likely error is out of FDs.  AsyncServerSocket will back off
+  // briefly if we are out of FDs, then continue accepting later.
+  // Just log a message here.
+  LOG(ERROR) << "error accepting on acceptor socket: " << ex.what();
+}
+
+void
+Acceptor::acceptStopped() noexcept {
+  VLOG(3) << "Acceptor " << this << " acceptStopped()";
+  // Drain the open client connections
+  drainAllConnections();
+
+  // If we haven't yet finished draining, begin doing so by marking ourselves
+  // as in the draining state. We must be sure to hit checkDrained() here, as
+  // if we're completely idle, we can should consider ourself drained
+  // immediately (as there is no outstanding work to complete to cause us to
+  // re-evaluate this).
+  if (state_ != State::kDone) {
+    state_ = State::kDraining;
+    checkDrained();
+  }
+}
+
+void
+Acceptor::onEmpty(const ConnectionManager& cm) {
+  VLOG(3) << "Acceptor=" << this << " onEmpty()";
+  if (state_ == State::kDraining) {
+    checkDrained();
+  }
+}
+
+void
+Acceptor::checkDrained() {
+  CHECK(state_ == State::kDraining);
+  if (forceShutdownInProgress_ ||
+      (downstreamConnectionManager_->getNumConnections() != 0) ||
+      (numPendingSSLConns_ != 0)) {
+    return;
+  }
+
+  VLOG(2) << "All connections drained from Acceptor=" << this << " in thread "
+          << base_;
+
+  downstreamConnectionManager_.reset();
+
+  state_ = State::kDone;
+
+  onConnectionsDrained();
+}
+
+milliseconds
+Acceptor::getConnTimeout() const {
+  return accConfig_.connectionIdleTimeout;
+}
+
+void Acceptor::addConnection(ManagedConnection* conn) {
+  // Add the socket to the timeout manager so that it can be cleaned
+  // up after being left idle for a long time.
+  downstreamConnectionManager_->addConnection(conn, true);
+}
+
+void
+Acceptor::forceStop() {
+  base_->runInEventBaseThread([&] { dropAllConnections(); });
+}
+
+void
+Acceptor::dropAllConnections() {
+  if (downstreamConnectionManager_) {
+    VLOG(3) << "Dropping all connections from Acceptor=" << this <<
+      " in thread " << base_;
+    assert(base_->isInEventBaseThread());
+    forceShutdownInProgress_ = true;
+    downstreamConnectionManager_->dropAllConnections();
+    CHECK(downstreamConnectionManager_->getNumConnections() == 0);
+    downstreamConnectionManager_.reset();
+  }
+  CHECK(numPendingSSLConns_ == 0);
+
+  state_ = State::kDone;
+  onConnectionsDrained();
+}
+
+} // namespace
diff --git a/folly/wangle/acceptor/ConnectionManager.cpp b/folly/wangle/acceptor/ConnectionManager.cpp
new file mode 100644
index 0000000..bb75c74
--- /dev/null
+++ b/folly/wangle/acceptor/ConnectionManager.cpp
@@ -0,0 +1,233 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <folly/wangle/acceptor/ConnectionManager.h>
+
+#include <glog/logging.h>
+#include <folly/io/async/EventBase.h>
+
+using folly::HHWheelTimer;
+using std::chrono::milliseconds;
+
+namespace folly { namespace wangle {
+
+ConnectionManager::ConnectionManager(EventBase* eventBase,
+    milliseconds timeout, Callback* callback)
+  : connTimeouts_(new HHWheelTimer(eventBase)),
+    callback_(callback),
+    eventBase_(eventBase),
+    idleIterator_(conns_.end()),
+    idleLoopCallback_(this),
+    timeout_(timeout),
+    idleConnEarlyDropThreshold_(timeout_ / 2) {
+
+}
+
+void
+ConnectionManager::addConnection(ManagedConnection* connection,
+    bool timeout) {
+  CHECK_NOTNULL(connection);
+  ConnectionManager* oldMgr = connection->getConnectionManager();
+  if (oldMgr != this) {
+    if (oldMgr) {
+      // 'connection' was being previously managed in a different thread.
+      // We must remove it from that manager before adding it to this one.
+      oldMgr->removeConnection(connection);
+    }
+
+    // put the connection into busy part first.  This should not matter at all
+    // because the last callback for an idle connection must be onDeactivated(),
+    // so the connection must be moved to idle part then.
+    conns_.push_front(*connection);
+
+    connection->setConnectionManager(this);
+    if (callback_) {
+      callback_->onConnectionAdded(*this);
+    }
+  }
+  if (timeout) {
+    scheduleTimeout(connection, timeout_);
+  }
+}
+
+void
+ConnectionManager::scheduleTimeout(ManagedConnection* const connection,
+    std::chrono::milliseconds timeout) {
+  if (timeout > std::chrono::milliseconds(0)) {
+    connTimeouts_->scheduleTimeout(connection, timeout);
+  }
+}
+
+void ConnectionManager::scheduleTimeout(
+  folly::HHWheelTimer::Callback* callback,
+  std::chrono::milliseconds timeout) {
+  connTimeouts_->scheduleTimeout(callback, timeout);
+}
+
+void
+ConnectionManager::removeConnection(ManagedConnection* connection) {
+  if (connection->getConnectionManager() == this) {
+    connection->cancelTimeout();
+    connection->setConnectionManager(nullptr);
+
+    // Un-link the connection from our list, being careful to keep the iterator
+    // that we're using for idle shedding valid
+    auto it = conns_.iterator_to(*connection);
+    if (it == idleIterator_) {
+      ++idleIterator_;
+    }
+    conns_.erase(it);
+
+    if (callback_) {
+      callback_->onConnectionRemoved(*this);
+      if (getNumConnections() == 0) {
+        callback_->onEmpty(*this);
+      }
+    }
+  }
+}
+
+void
+ConnectionManager::initiateGracefulShutdown(
+  std::chrono::milliseconds idleGrace) {
+  if (idleGrace.count() > 0) {
+    idleLoopCallback_.scheduleTimeout(idleGrace);
+    VLOG(3) << "Scheduling idle grace period of " << idleGrace.count() << "ms";
+  } else {
+    action_ = ShutdownAction::DRAIN2;
+    VLOG(3) << "proceeding directly to closing idle connections";
+  }
+  drainAllConnections();
+}
+
+void
+ConnectionManager::drainAllConnections() {
+  DestructorGuard g(this);
+  size_t numCleared = 0;
+  size_t numKept = 0;
+
+  auto it = idleIterator_ == conns_.end() ?
+    conns_.begin() : idleIterator_;
+
+  while (it != conns_.end() && (numKept + numCleared) < 64) {
+    ManagedConnection& conn = *it++;
+    if (action_ == ShutdownAction::DRAIN1) {
+      conn.notifyPendingShutdown();
+    } else {
+      // Second time around: close idle sessions. If they aren't idle yet,
+      // have them close when they are idle
+      if (conn.isBusy()) {
+        numKept++;
+      } else {
+        numCleared++;
+      }
+      conn.closeWhenIdle();
+    }
+  }
+
+  if (action_ == ShutdownAction::DRAIN2) {
+    VLOG(2) << "Idle connections cleared: " << numCleared <<
+      ", busy conns kept: " << numKept;
+  }
+  if (it != conns_.end()) {
+    idleIterator_ = it;
+    eventBase_->runInLoop(&idleLoopCallback_);
+  } else {
+    action_ = ShutdownAction::DRAIN2;
+  }
+}
+
+void
+ConnectionManager::dropAllConnections() {
+  DestructorGuard g(this);
+
+  // Iterate through our connection list, and drop each connection.
+  VLOG(3) << "connections to drop: " << conns_.size();
+  idleLoopCallback_.cancelTimeout();
+  unsigned i = 0;
+  while (!conns_.empty()) {
+    ManagedConnection& conn = conns_.front();
+    conns_.pop_front();
+    conn.cancelTimeout();
+    conn.setConnectionManager(nullptr);
+    // For debugging purposes, dump information about the first few
+    // connections.
+    static const unsigned MAX_CONNS_TO_DUMP = 2;
+    if (++i <= MAX_CONNS_TO_DUMP) {
+      conn.dumpConnectionState(3);
+    }
+    conn.dropConnection();
+  }
+  idleIterator_ = conns_.end();
+  idleLoopCallback_.cancelLoopCallback();
+
+  if (callback_) {
+    callback_->onEmpty(*this);
+  }
+}
+
+void
+ConnectionManager::onActivated(ManagedConnection& conn) {
+  auto it = conns_.iterator_to(conn);
+  if (it == idleIterator_) {
+    idleIterator_++;
+  }
+  conns_.erase(it);
+  conns_.push_front(conn);
+}
+
+void
+ConnectionManager::onDeactivated(ManagedConnection& conn) {
+  auto it = conns_.iterator_to(conn);
+  conns_.erase(it);
+  conns_.push_back(conn);
+  if (idleIterator_ == conns_.end()) {
+    idleIterator_--;
+  }
+}
+
+size_t
+ConnectionManager::dropIdleConnections(size_t num) {
+  VLOG(4) << "attempt to drop " << num << " idle connections";
+  if (idleConnEarlyDropThreshold_ >= timeout_) {
+    return 0;
+  }
+
+  size_t count = 0;
+  while(count < num) {
+    auto it = idleIterator_;
+    if (it == conns_.end()) {
+      return count; // no more idle session
+    }
+    auto idleTime = it->getIdleTime();
+    if (idleTime == std::chrono::milliseconds(0) ||
+          idleTime <= idleConnEarlyDropThreshold_) {
+      VLOG(4) << "conn's idletime: " << idleTime.count()
+              << ", earlyDropThreshold: " << idleConnEarlyDropThreshold_.count()
+              << ", attempt to drop " << count << "/" << num;
+      return count; // idleTime cannot be further reduced
+    }
+    ManagedConnection& conn = *it;
+    idleIterator_++;
+    conn.timeoutExpired();
+    count++;
+  }
+
+  return count;
+}
+
+
+}} // folly::wangle
diff --git a/folly/wangle/acceptor/LoadShedConfiguration.cpp b/folly/wangle/acceptor/LoadShedConfiguration.cpp
new file mode 100644
index 0000000..44381e4
--- /dev/null
+++ b/folly/wangle/acceptor/LoadShedConfiguration.cpp
@@ -0,0 +1,43 @@
+/*
+ *  Copyright (c) 2015, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+#include <folly/wangle/acceptor/LoadShedConfiguration.h>
+
+#include <folly/Conv.h>
+#include <openssl/ssl.h>
+
+using std::string;
+
+namespace folly {
+
+void LoadShedConfiguration::addWhitelistAddr(folly::StringPiece input) {
+  auto addr = input.str();
+  size_t separator = addr.find_first_of('/');
+  if (separator == string::npos) {
+    whitelistAddrs_.insert(SocketAddress(addr, 0));
+  } else {
+    unsigned prefixLen = folly::to<unsigned>(addr.substr(separator + 1));
+    addr.erase(separator);
+    whitelistNetworks_.insert(NetworkAddress(SocketAddress(addr, 0), prefixLen));
+  }
+}
+
+bool LoadShedConfiguration::isWhitelisted(const SocketAddress& address) const {
+  if (whitelistAddrs_.find(address) != whitelistAddrs_.end()) {
+    return true;
+  }
+  for (auto& network : whitelistNetworks_) {
+    if (network.contains(address)) {
+      return true;
+    }
+  }
+  return false;
+}
+
+}
diff --git a/folly/wangle/acceptor/ManagedConnection.cpp b/folly/wangle/acceptor/ManagedConnection.cpp
new file mode 100644
index 0000000..3ddd0d3
--- /dev/null
+++ b/folly/wangle/acceptor/ManagedConnection.cpp
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <folly/wangle/acceptor/ManagedConnection.h>
+
+#include <folly/wangle/acceptor/ConnectionManager.h>
+
+namespace folly { namespace wangle {
+
+ManagedConnection::ManagedConnection()
+  : connectionManager_(nullptr) {
+}
+
+ManagedConnection::~ManagedConnection() {
+  if (connectionManager_) {
+    connectionManager_->removeConnection(this);
+  }
+}
+
+void
+ManagedConnection::resetTimeout() {
+  if (connectionManager_) {
+    resetTimeoutTo(connectionManager_->getDefaultTimeout());
+  }
+}
+
+void
+ManagedConnection::resetTimeoutTo(std::chrono::milliseconds timeout) {
+  if (connectionManager_) {
+    connectionManager_->scheduleTimeout(this, timeout);
+  }
+}
+
+void
+ManagedConnection::scheduleTimeout(
+  folly::HHWheelTimer::Callback* callback,
+    std::chrono::milliseconds timeout) {
+  if (connectionManager_) {
+    connectionManager_->scheduleTimeout(callback, timeout);
+  }
+}
+
+////////////////////// Globals /////////////////////
+
+std::ostream&
+operator<<(std::ostream& os, const ManagedConnection& conn) {
+  conn.describe(os);
+  return os;
+}
+
+}} // folly::wangle
diff --git a/folly/wangle/acceptor/SocketOptions.cpp b/folly/wangle/acceptor/SocketOptions.cpp
new file mode 100644
index 0000000..b33e103
--- /dev/null
+++ b/folly/wangle/acceptor/SocketOptions.cpp
@@ -0,0 +1,38 @@
+/*
+ *  Copyright (c) 2015, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+#include <folly/wangle/acceptor/SocketOptions.h>
+
+#include <netinet/tcp.h>
+#include <sys/socket.h>
+
+namespace folly {
+
+AsyncSocket::OptionMap filterIPSocketOptions(
+  const AsyncSocket::OptionMap& allOptions,
+  const int addrFamily) {
+  AsyncSocket::OptionMap opts;
+  int exclude;
+  if (addrFamily == AF_INET) {
+    exclude = IPPROTO_IPV6;
+  } else if (addrFamily == AF_INET6) {
+    exclude = IPPROTO_IP;
+  } else {
+    LOG(FATAL) << "Address family " << addrFamily << " was not IPv4 or IPv6";
+    return opts;
+  }
+  for (const auto& opt: allOptions) {
+    if (opt.first.level != exclude) {
+      opts[opt.first] = opt.second;
+    }
+  }
+  return opts;
+}
+
+}
diff --git a/folly/wangle/acceptor/TransportInfo.cpp b/folly/wangle/acceptor/TransportInfo.cpp
new file mode 100644
index 0000000..4f735b4
--- /dev/null
+++ b/folly/wangle/acceptor/TransportInfo.cpp
@@ -0,0 +1,65 @@
+/*
+ *  Copyright (c) 2015, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+#include <folly/wangle/acceptor/TransportInfo.h>
+
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <folly/io/async/AsyncSocket.h>
+
+using std::chrono::microseconds;
+using std::map;
+using std::string;
+
+namespace folly {
+
+bool TransportInfo::initWithSocket(const AsyncSocket* sock) {
+#if defined(__linux__) || defined(__FreeBSD__)
+  if (!TransportInfo::readTcpInfo(&tcpinfo, sock)) {
+    tcpinfoErrno = errno;
+    return false;
+  }
+  rtt = microseconds(tcpinfo.tcpi_rtt);
+  validTcpinfo = true;
+#else
+  tcpinfoErrno = EINVAL;
+  rtt = microseconds(-1);
+#endif
+  return true;
+}
+
+int64_t TransportInfo::readRTT(const AsyncSocket* sock) {
+#if defined(__linux__) || defined(__FreeBSD__)
+  struct tcp_info tcpinfo;
+  if (!TransportInfo::readTcpInfo(&tcpinfo, sock)) {
+    return -1;
+  }
+  return tcpinfo.tcpi_rtt;
+#else
+  return -1;
+#endif
+}
+
+#if defined(__linux__) || defined(__FreeBSD__)
+bool TransportInfo::readTcpInfo(struct tcp_info* tcpinfo,
+                                const AsyncSocket* sock) {
+  socklen_t len = sizeof(struct tcp_info);
+  if (!sock) {
+    return false;
+  }
+  if (getsockopt(sock->getFd(), IPPROTO_TCP,
+                 TCP_INFO, (void*) tcpinfo, &len) < 0) {
+    VLOG(4) << "Error calling getsockopt(): " << strerror(errno);
+    return false;
+  }
+  return true;
+}
+#endif
+
+} // folly
diff --git a/folly/wangle/bootstrap/BootstrapTest.cpp b/folly/wangle/bootstrap/BootstrapTest.cpp
new file mode 100644
index 0000000..724afec
--- /dev/null
+++ b/folly/wangle/bootstrap/BootstrapTest.cpp
@@ -0,0 +1,365 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "folly/wangle/bootstrap/ServerBootstrap.h"
+#include "folly/wangle/bootstrap/ClientBootstrap.h"
+#include "folly/wangle/channel/Handler.h"
+
+#include <glog/logging.h>
+#include <gtest/gtest.h>
+#include <boost/thread.hpp>
+
+using namespace folly::wangle;
+using namespace folly;
+
+typedef Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> BytesPipeline;
+
+typedef ServerBootstrap<BytesPipeline> TestServer;
+typedef ClientBootstrap<BytesPipeline> TestClient;
+
+class TestClientPipelineFactory : public PipelineFactory<BytesPipeline> {
+ public:
+  std::unique_ptr<BytesPipeline, folly::DelayedDestruction::Destructor>
+  newPipeline(std::shared_ptr<AsyncSocket> sock) {
+    // We probably aren't connected immedately, check after a small delay
+    EventBaseManager::get()->getEventBase()->tryRunAfterDelay([sock](){
+      CHECK(sock->good());
+      CHECK(sock->readable());
+    }, 100);
+    return nullptr;
+  }
+};
+
+class TestPipelineFactory : public PipelineFactory<BytesPipeline> {
+ public:
+  std::unique_ptr<BytesPipeline, folly::DelayedDestruction::Destructor> newPipeline(
+    std::shared_ptr<AsyncSocket> sock) {
+
+    pipelines++;
+    return std::unique_ptr<BytesPipeline, folly::DelayedDestruction::Destructor>(
+      new BytesPipeline());
+  }
+  std::atomic<int> pipelines{0};
+};
+
+class TestAcceptor : public Acceptor {
+EventBase base_;
+ public:
+  TestAcceptor() : Acceptor(ServerSocketConfig()) {
+    Acceptor::init(nullptr, &base_);
+  }
+  void onNewConnection(
+      AsyncSocket::UniquePtr sock,
+      const folly::SocketAddress* address,
+      const std::string& nextProtocolName,
+        const TransportInfo& tinfo) {
+  }
+};
+
+class TestAcceptorFactory : public AcceptorFactory {
+ public:
+  std::shared_ptr<Acceptor> newAcceptor(EventBase* base) {
+    return std::make_shared<TestAcceptor>();
+  }
+};
+
+TEST(Bootstrap, Basic) {
+  TestServer server;
+  TestClient client;
+}
+
+TEST(Bootstrap, ServerWithPipeline) {
+  TestServer server;
+  server.childPipeline(std::make_shared<TestPipelineFactory>());
+  server.bind(0);
+  server.stop();
+}
+
+TEST(Bootstrap, ServerWithChildHandler) {
+  TestServer server;
+  server.childHandler(std::make_shared<TestAcceptorFactory>());
+  server.bind(0);
+  server.stop();
+}
+
+TEST(Bootstrap, ClientServerTest) {
+  TestServer server;
+  auto factory = std::make_shared<TestPipelineFactory>();
+  server.childPipeline(factory);
+  server.bind(0);
+  auto base = EventBaseManager::get()->getEventBase();
+
+  SocketAddress address;
+  server.getSockets()[0]->getAddress(&address);
+
+  TestClient client;
+  client.pipelineFactory(std::make_shared<TestClientPipelineFactory>());
+  client.connect(address);
+  base->loop();
+  server.stop();
+
+  CHECK(factory->pipelines == 1);
+}
+
+TEST(Bootstrap, ClientConnectionManagerTest) {
+  // Create a single IO thread, and verify that
+  // client connections are pooled properly
+
+  TestServer server;
+  auto factory = std::make_shared<TestPipelineFactory>();
+  server.childPipeline(factory);
+  server.group(std::make_shared<IOThreadPoolExecutor>(1));
+  server.bind(0);
+  auto base = EventBaseManager::get()->getEventBase();
+
+  SocketAddress address;
+  server.getSockets()[0]->getAddress(&address);
+
+  TestClient client;
+  client.pipelineFactory(std::make_shared<TestClientPipelineFactory>());
+
+  client.connect(address);
+
+  TestClient client2;
+  client2.pipelineFactory(std::make_shared<TestClientPipelineFactory>());
+  client2.connect(address);
+
+  base->loop();
+  server.stop();
+
+  CHECK(factory->pipelines == 2);
+}
+
+TEST(Bootstrap, ServerAcceptGroupTest) {
+  // Verify that server is using the accept IO group
+
+  TestServer server;
+  auto factory = std::make_shared<TestPipelineFactory>();
+  server.childPipeline(factory);
+  server.group(std::make_shared<IOThreadPoolExecutor>(1), nullptr);
+  server.bind(0);
+
+  SocketAddress address;
+  server.getSockets()[0]->getAddress(&address);
+
+  boost::barrier barrier(2);
+  auto thread = std::thread([&](){
+    TestClient client;
+    client.pipelineFactory(std::make_shared<TestClientPipelineFactory>());
+    client.connect(address);
+    EventBaseManager::get()->getEventBase()->loop();
+    barrier.wait();
+  });
+  barrier.wait();
+  server.stop();
+  thread.join();
+
+  CHECK(factory->pipelines == 1);
+}
+
+TEST(Bootstrap, ServerAcceptGroup2Test) {
+  // Verify that server is using the accept IO group
+
+  // Check if reuse port is supported, if not, don't run this test
+  try {
+    EventBase base;
+    auto serverSocket = AsyncServerSocket::newSocket(&base);
+    serverSocket->bind(0);
+    serverSocket->listen(0);
+    serverSocket->startAccepting();
+    serverSocket->setReusePortEnabled(true);
+    serverSocket->stopAccepting();
+  } catch(...) {
+    LOG(INFO) << "Reuse port probably not supported";
+    return;
+  }
+
+  TestServer server;
+  auto factory = std::make_shared<TestPipelineFactory>();
+  server.childPipeline(factory);
+  server.group(std::make_shared<IOThreadPoolExecutor>(4), nullptr);
+  server.bind(0);
+
+  SocketAddress address;
+  server.getSockets()[0]->getAddress(&address);
+
+  TestClient client;
+  client.pipelineFactory(std::make_shared<TestClientPipelineFactory>());
+
+  client.connect(address);
+  EventBaseManager::get()->getEventBase()->loop();
+
+  server.stop();
+
+  CHECK(factory->pipelines == 1);
+}
+
+TEST(Bootstrap, SharedThreadPool) {
+  // Check if reuse port is supported, if not, don't run this test
+  try {
+    EventBase base;
+    auto serverSocket = AsyncServerSocket::newSocket(&base);
+    serverSocket->bind(0);
+    serverSocket->listen(0);
+    serverSocket->startAccepting();
+    serverSocket->setReusePortEnabled(true);
+    serverSocket->stopAccepting();
+  } catch(...) {
+    LOG(INFO) << "Reuse port probably not supported";
+    return;
+  }
+
+  auto pool = std::make_shared<IOThreadPoolExecutor>(2);
+
+  TestServer server;
+  auto factory = std::make_shared<TestPipelineFactory>();
+  server.childPipeline(factory);
+  server.group(pool, pool);
+
+  server.bind(0);
+
+  SocketAddress address;
+  server.getSockets()[0]->getAddress(&address);
+
+  TestClient client;
+  client.pipelineFactory(std::make_shared<TestClientPipelineFactory>());
+  client.connect(address);
+
+  TestClient client2;
+  client2.pipelineFactory(std::make_shared<TestClientPipelineFactory>());
+  client2.connect(address);
+
+  TestClient client3;
+  client3.pipelineFactory(std::make_shared<TestClientPipelineFactory>());
+  client3.connect(address);
+
+  TestClient client4;
+  client4.pipelineFactory(std::make_shared<TestClientPipelineFactory>());
+  client4.connect(address);
+
+  TestClient client5;
+  client5.pipelineFactory(std::make_shared<TestClientPipelineFactory>());
+  client5.connect(address);
+
+  EventBaseManager::get()->getEventBase()->loop();
+
+  server.stop();
+  CHECK(factory->pipelines == 5);
+}
+
+TEST(Bootstrap, ExistingSocket) {
+  TestServer server;
+  auto factory = std::make_shared<TestPipelineFactory>();
+  server.childPipeline(factory);
+  folly::AsyncServerSocket::UniquePtr socket(new AsyncServerSocket);
+  server.bind(std::move(socket));
+}
+
+std::atomic<int> connections{0};
+
+class TestHandlerPipeline : public InboundHandler<void*> {
+ public:
+  void read(Context* ctx, void* conn) {
+    connections++;
+    return ctx->fireRead(conn);
+  }
+};
+
+template <typename HandlerPipeline>
+class TestHandlerPipelineFactory
+    : public PipelineFactory<ServerBootstrap<BytesPipeline>::AcceptPipeline> {
+ public:
+  std::unique_ptr<ServerBootstrap<BytesPipeline>::AcceptPipeline,
+                  folly::DelayedDestruction::Destructor>
+  newPipeline(std::shared_ptr<AsyncSocket>) {
+
+    std::unique_ptr<ServerBootstrap<BytesPipeline>::AcceptPipeline,
+                    folly::DelayedDestruction::Destructor> pipeline(
+                      new ServerBootstrap<BytesPipeline>::AcceptPipeline);
+    pipeline->addBack(HandlerPipeline());
+    return pipeline;
+  }
+};
+
+TEST(Bootstrap, LoadBalanceHandler) {
+  TestServer server;
+  auto factory = std::make_shared<TestPipelineFactory>();
+  server.childPipeline(factory);
+
+  auto pipelinefactory =
+    std::make_shared<TestHandlerPipelineFactory<TestHandlerPipeline>>();
+  server.pipeline(pipelinefactory);
+  server.bind(0);
+  auto base = EventBaseManager::get()->getEventBase();
+
+  SocketAddress address;
+  server.getSockets()[0]->getAddress(&address);
+
+  TestClient client;
+  client.pipelineFactory(std::make_shared<TestClientPipelineFactory>());
+  client.connect(address);
+  base->loop();
+  server.stop();
+
+  CHECK(factory->pipelines == 1);
+  CHECK(connections == 1);
+}
+
+class TestUDPPipeline : public InboundHandler<void*> {
+ public:
+  void read(Context* ctx, void* conn) {
+    connections++;
+  }
+};
+
+TEST(Bootstrap, UDP) {
+  TestServer server;
+  auto factory = std::make_shared<TestPipelineFactory>();
+  auto pipelinefactory =
+    std::make_shared<TestHandlerPipelineFactory<TestUDPPipeline>>();
+  server.pipeline(pipelinefactory);
+  server.channelFactory(std::make_shared<AsyncUDPServerSocketFactory>());
+  server.bind(0);
+}
+
+TEST(Bootstrap, UDPClientServerTest) {
+  connections = 0;
+
+  TestServer server;
+  auto factory = std::make_shared<TestPipelineFactory>();
+  auto pipelinefactory =
+    std::make_shared<TestHandlerPipelineFactory<TestUDPPipeline>>();
+  server.pipeline(pipelinefactory);
+  server.channelFactory(std::make_shared<AsyncUDPServerSocketFactory>());
+  server.bind(0);
+
+  auto base = EventBaseManager::get()->getEventBase();
+
+  SocketAddress address;
+  server.getSockets()[0]->getAddress(&address);
+
+  SocketAddress localhost("::1", 0);
+  AsyncUDPSocket client(base);
+  client.bind(localhost);
+  auto data = IOBuf::create(1);
+  data->append(1);
+  *(data->writableData()) = 'a';
+  client.write(address, std::move(data));
+  base->loop();
+  server.stop();
+
+  CHECK(connections == 1);
+}
diff --git a/folly/wangle/bootstrap/ServerBootstrap.cpp b/folly/wangle/bootstrap/ServerBootstrap.cpp
new file mode 100644
index 0000000..6b7a410
--- /dev/null
+++ b/folly/wangle/bootstrap/ServerBootstrap.cpp
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <folly/wangle/bootstrap/ServerBootstrap.h>
+#include <folly/wangle/concurrent/NamedThreadFactory.h>
+#include <folly/wangle/channel/Handler.h>
+#include <folly/io/async/EventBaseManager.h>
+
+namespace folly {
+
+void ServerWorkerPool::threadStarted(
+  folly::wangle::ThreadPoolExecutor::ThreadHandle* h) {
+  auto worker = acceptorFactory_->newAcceptor(exec_->getEventBase(h));
+  workers_.insert({h, worker});
+
+  for(auto socket : *sockets_) {
+    socket->getEventBase()->runImmediatelyOrRunInEventBaseThreadAndWait(
+      [this, worker, socket](){
+        socketFactory_->addAcceptCB(
+          socket, worker.get(), worker->getEventBase());
+    });
+  }
+}
+
+void ServerWorkerPool::threadStopped(
+  folly::wangle::ThreadPoolExecutor::ThreadHandle* h) {
+  auto worker = workers_.find(h);
+  CHECK(worker != workers_.end());
+
+  for (auto socket : *sockets_) {
+    socket->getEventBase()->runImmediatelyOrRunInEventBaseThreadAndWait(
+      [&]() {
+        socketFactory_->removeAcceptCB(
+          socket, worker->second.get(), nullptr);
+    });
+  }
+
+  if (!worker->second->getEventBase()->isInEventBaseThread()) {
+    worker->second->getEventBase()->runImmediatelyOrRunInEventBaseThreadAndWait(
+      [=]() {
+        worker->second->dropAllConnections();
+      });
+  } else {
+    worker->second->dropAllConnections();
+  }
+
+  workers_.erase(worker);
+}
+
+} // namespace
diff --git a/folly/wangle/channel/test/OutputBufferingHandlerTest.cpp b/folly/wangle/channel/test/OutputBufferingHandlerTest.cpp
new file mode 100644
index 0000000..0fce791
--- /dev/null
+++ b/folly/wangle/channel/test/OutputBufferingHandlerTest.cpp
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <folly/wangle/channel/StaticPipeline.h>
+#include <folly/wangle/channel/OutputBufferingHandler.h>
+#include <folly/wangle/channel/test/MockHandler.h>
+#include <folly/io/async/AsyncSocket.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace folly;
+using namespace folly::wangle;
+using namespace testing;
+
+typedef StrictMock<MockHandlerAdapter<
+  IOBufQueue&,
+  std::unique_ptr<IOBuf>>>
+MockBytesHandler;
+
+MATCHER_P(IOBufContains, str, "") { return arg->moveToFbString() == str; }
+
+TEST(OutputBufferingHandlerTest, Basic) {
+  MockBytesHandler mockHandler;
+  EXPECT_CALL(mockHandler, attachPipeline(_));
+  StaticPipeline<IOBufQueue&, std::unique_ptr<IOBuf>,
+    MockBytesHandler,
+    OutputBufferingHandler>
+  pipeline(&mockHandler, OutputBufferingHandler{});
+
+  EventBase eb;
+  auto socket = AsyncSocket::newSocket(&eb);
+  pipeline.setTransport(socket);
+
+  // Buffering should prevent writes until the EB loops, and the writes should
+  // be batched into one write call.
+  auto f1 = pipeline.write(IOBuf::copyBuffer("hello"));
+  auto f2 = pipeline.write(IOBuf::copyBuffer("world"));
+  EXPECT_FALSE(f1.isReady());
+  EXPECT_FALSE(f2.isReady());
+  EXPECT_CALL(mockHandler, write_(_, IOBufContains("helloworld")));
+  eb.loopOnce();
+  EXPECT_TRUE(f1.isReady());
+  EXPECT_TRUE(f2.isReady());
+  EXPECT_CALL(mockHandler, detachPipeline(_));
+
+ // Make sure the SharedPromise resets correctly
+  auto f = pipeline.write(IOBuf::copyBuffer("foo"));
+  EXPECT_FALSE(f.isReady());
+  EXPECT_CALL(mockHandler, write_(_, IOBufContains("foo")));
+  eb.loopOnce();
+  EXPECT_TRUE(f.isReady());
+}
diff --git a/folly/wangle/channel/test/PipelineTest.cpp b/folly/wangle/channel/test/PipelineTest.cpp
new file mode 100644
index 0000000..cdc4e98
--- /dev/null
+++ b/folly/wangle/channel/test/PipelineTest.cpp
@@ -0,0 +1,306 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <folly/wangle/channel/Handler.h>
+#include <folly/wangle/channel/Pipeline.h>
+#include <folly/wangle/channel/StaticPipeline.h>
+#include <folly/wangle/channel/AsyncSocketHandler.h>
+#include <folly/wangle/channel/OutputBufferingHandler.h>
+#include <folly/wangle/channel/test/MockHandler.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+
+using namespace folly;
+using namespace folly::wangle;
+using namespace testing;
+
+typedef StrictMock<MockHandlerAdapter<int, int>> IntHandler;
+class IntHandler2 : public StrictMock<MockHandlerAdapter<int, int>> {};
+
+ACTION(FireRead) {
+  arg0->fireRead(arg1);
+}
+
+ACTION(FireReadEOF) {
+  arg0->fireReadEOF();
+}
+
+ACTION(FireReadException) {
+  arg0->fireReadException(arg1);
+}
+
+ACTION(FireWrite) {
+  arg0->fireWrite(arg1);
+}
+
+ACTION(FireClose) {
+  arg0->fireClose();
+}
+
+// Test move only types, among other things
+TEST(PipelineTest, RealHandlersCompile) {
+  EventBase eb;
+  auto socket = AsyncSocket::newSocket(&eb);
+  // static
+  {
+    StaticPipeline<IOBufQueue&, std::unique_ptr<IOBuf>,
+      AsyncSocketHandler,
+      OutputBufferingHandler>
+    pipeline{AsyncSocketHandler(socket), OutputBufferingHandler()};
+    EXPECT_TRUE(pipeline.getHandler<AsyncSocketHandler>(0));
+    EXPECT_TRUE(pipeline.getHandler<OutputBufferingHandler>(1));
+  }
+  // dynamic
+  {
+    Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+    pipeline
+      .addBack(AsyncSocketHandler(socket))
+      .addBack(OutputBufferingHandler())
+      .finalize();
+    EXPECT_TRUE(pipeline.getHandler<AsyncSocketHandler>(0));
+    EXPECT_TRUE(pipeline.getHandler<OutputBufferingHandler>(1));
+  }
+}
+
+// Test that handlers correctly fire the next handler when directed
+TEST(PipelineTest, FireActions) {
+  IntHandler handler1;
+  IntHandler2 handler2;
+
+  {
+    InSequence sequence;
+    EXPECT_CALL(handler2, attachPipeline(_));
+    EXPECT_CALL(handler1, attachPipeline(_));
+  }
+
+  StaticPipeline<int, int, IntHandler, IntHandler2>
+  pipeline(&handler1, &handler2);
+
+  EXPECT_CALL(handler1, read_(_, _)).WillOnce(FireRead());
+  EXPECT_CALL(handler2, read_(_, _)).Times(1);
+  pipeline.read(1);
+
+  EXPECT_CALL(handler1, readEOF(_)).WillOnce(FireReadEOF());
+  EXPECT_CALL(handler2, readEOF(_)).Times(1);
+  pipeline.readEOF();
+
+  EXPECT_CALL(handler1, readException(_, _)).WillOnce(FireReadException());
+  EXPECT_CALL(handler2, readException(_, _)).Times(1);
+  pipeline.readException(make_exception_wrapper<std::runtime_error>("blah"));
+
+  EXPECT_CALL(handler2, write_(_, _)).WillOnce(FireWrite());
+  EXPECT_CALL(handler1, write_(_, _)).Times(1);
+  EXPECT_NO_THROW(pipeline.write(1).value());
+
+  EXPECT_CALL(handler2, close_(_)).WillOnce(FireClose());
+  EXPECT_CALL(handler1, close_(_)).Times(1);
+  EXPECT_NO_THROW(pipeline.close().value());
+
+  {
+    InSequence sequence;
+    EXPECT_CALL(handler1, detachPipeline(_));
+    EXPECT_CALL(handler2, detachPipeline(_));
+  }
+}
+
+// Test that nothing bad happens when actions reach the end of the pipeline
+// (a warning will be logged, however)
+TEST(PipelineTest, ReachEndOfPipeline) {
+  IntHandler handler;
+  EXPECT_CALL(handler, attachPipeline(_));
+  StaticPipeline<int, int, IntHandler>
+  pipeline(&handler);
+
+  EXPECT_CALL(handler, read_(_, _)).WillOnce(FireRead());
+  pipeline.read(1);
+
+  EXPECT_CALL(handler, readEOF(_)).WillOnce(FireReadEOF());
+  pipeline.readEOF();
+
+  EXPECT_CALL(handler, readException(_, _)).WillOnce(FireReadException());
+  pipeline.readException(make_exception_wrapper<std::runtime_error>("blah"));
+
+  EXPECT_CALL(handler, write_(_, _)).WillOnce(FireWrite());
+  EXPECT_NO_THROW(pipeline.write(1).value());
+
+  EXPECT_CALL(handler, close_(_)).WillOnce(FireClose());
+  EXPECT_NO_THROW(pipeline.close().value());
+
+  EXPECT_CALL(handler, detachPipeline(_));
+}
+
+// Test having the last read handler turn around and write
+TEST(PipelineTest, TurnAround) {
+  IntHandler handler1;
+  IntHandler2 handler2;
+
+  {
+    InSequence sequence;
+    EXPECT_CALL(handler2, attachPipeline(_));
+    EXPECT_CALL(handler1, attachPipeline(_));
+  }
+
+  StaticPipeline<int, int, IntHandler, IntHandler2>
+  pipeline(&handler1, &handler2);
+
+  EXPECT_CALL(handler1, read_(_, _)).WillOnce(FireRead());
+  EXPECT_CALL(handler2, read_(_, _)).WillOnce(FireWrite());
+  EXPECT_CALL(handler1, write_(_, _)).Times(1);
+  pipeline.read(1);
+
+  {
+    InSequence sequence;
+    EXPECT_CALL(handler1, detachPipeline(_));
+    EXPECT_CALL(handler2, detachPipeline(_));
+  }
+}
+
+TEST(PipelineTest, DynamicFireActions) {
+  IntHandler handler1, handler2, handler3;
+  EXPECT_CALL(handler2, attachPipeline(_));
+  StaticPipeline<int, int, IntHandler>
+  pipeline(&handler2);
+
+  {
+    InSequence sequence;
+    EXPECT_CALL(handler3, attachPipeline(_));
+    EXPECT_CALL(handler1, attachPipeline(_));
+  }
+
+  pipeline
+    .addFront(&handler1)
+    .addBack(&handler3)
+    .finalize();
+
+  EXPECT_TRUE(pipeline.getHandler<IntHandler>(0));
+  EXPECT_TRUE(pipeline.getHandler<IntHandler>(1));
+  EXPECT_TRUE(pipeline.getHandler<IntHandler>(2));
+
+  EXPECT_CALL(handler1, read_(_, _)).WillOnce(FireRead());
+  EXPECT_CALL(handler2, read_(_, _)).WillOnce(FireRead());
+  EXPECT_CALL(handler3, read_(_, _)).Times(1);
+  pipeline.read(1);
+
+  EXPECT_CALL(handler3, write_(_, _)).WillOnce(FireWrite());
+  EXPECT_CALL(handler2, write_(_, _)).WillOnce(FireWrite());
+  EXPECT_CALL(handler1, write_(_, _)).Times(1);
+  EXPECT_NO_THROW(pipeline.write(1).value());
+
+  {
+    InSequence sequence;
+    EXPECT_CALL(handler1, detachPipeline(_));
+    EXPECT_CALL(handler2, detachPipeline(_));
+    EXPECT_CALL(handler3, detachPipeline(_));
+  }
+}
+
+TEST(PipelineTest, DynamicAttachDetachOrder) {
+  IntHandler handler1, handler2;
+  Pipeline<int, int> pipeline;
+  {
+    InSequence sequence;
+    EXPECT_CALL(handler2, attachPipeline(_));
+    EXPECT_CALL(handler1, attachPipeline(_));
+  }
+  pipeline
+    .addBack(&handler1)
+    .addBack(&handler2)
+    .finalize();
+  {
+    InSequence sequence;
+    EXPECT_CALL(handler1, detachPipeline(_));
+    EXPECT_CALL(handler2, detachPipeline(_));
+  }
+}
+
+TEST(PipelineTest, GetContext) {
+  IntHandler handler;
+  EXPECT_CALL(handler, attachPipeline(_));
+  StaticPipeline<int, int, IntHandler> pipeline(&handler);
+  EXPECT_TRUE(handler.getContext());
+  EXPECT_CALL(handler, detachPipeline(_));
+}
+
+TEST(PipelineTest, HandlerInMultiplePipelines) {
+  IntHandler handler;
+  EXPECT_CALL(handler, attachPipeline(_)).Times(2);
+  StaticPipeline<int, int, IntHandler> pipeline1(&handler);
+  StaticPipeline<int, int, IntHandler> pipeline2(&handler);
+  EXPECT_FALSE(handler.getContext());
+  EXPECT_CALL(handler, detachPipeline(_)).Times(2);
+}
+
+TEST(PipelineTest, HandlerInPipelineTwice) {
+  auto handler = std::make_shared<IntHandler>();
+  EXPECT_CALL(*handler, attachPipeline(_)).Times(2);
+  Pipeline<int, int> pipeline;
+  pipeline.addBack(handler);
+  pipeline.addBack(handler);
+  pipeline.finalize();
+  EXPECT_FALSE(handler->getContext());
+  EXPECT_CALL(*handler, detachPipeline(_)).Times(2);
+}
+
+TEST(PipelineTest, NoDetachOnOwner) {
+  IntHandler handler;
+  EXPECT_CALL(handler, attachPipeline(_));
+  StaticPipeline<int, int, IntHandler> pipeline(&handler);
+  pipeline.setOwner(&handler);
+}
+
+template <class Rin, class Rout = Rin, class Win = Rout, class Wout = Rin>
+class ConcreteHandler : public Handler<Rin, Rout, Win, Wout> {
+  typedef typename Handler<Rin, Rout, Win, Wout>::Context Context;
+ public:
+  void read(Context* ctx, Rin msg) {}
+  Future<void> write(Context* ctx, Win msg) { return makeFuture(); }
+};
+
+typedef HandlerAdapter<std::string, std::string> StringHandler;
+typedef ConcreteHandler<int, std::string> IntToStringHandler;
+typedef ConcreteHandler<std::string, int> StringToIntHandler;
+
+TEST(Pipeline, MissingInboundOrOutbound) {
+  Pipeline<int, int> pipeline;
+  pipeline
+    .addBack(HandlerAdapter<std::string, std::string>{})
+    .finalize();
+  EXPECT_THROW(pipeline.read(0), std::invalid_argument);
+  EXPECT_THROW(pipeline.readEOF(), std::invalid_argument);
+  EXPECT_THROW(
+      pipeline.readException(exception_wrapper(std::runtime_error("blah"))),
+      std::invalid_argument);
+  EXPECT_THROW(pipeline.write(0), std::invalid_argument);
+  EXPECT_THROW(pipeline.close(), std::invalid_argument);
+}
+
+TEST(Pipeline, DynamicConstruction) {
+  {
+    Pipeline<std::string, std::string> pipeline;
+    pipeline.addBack(StringHandler());
+    pipeline.addBack(StringHandler());
+
+    // Exercise both addFront and addBack. Final pipeline is
+    // StI <-> ItS <-> StS <-> StS <-> StI <-> ItS
+    EXPECT_NO_THROW(
+      pipeline
+        .addFront(IntToStringHandler{})
+        .addFront(StringToIntHandler{})
+        .addBack(StringToIntHandler{})
+        .addBack(IntToStringHandler{})
+        .finalize());
+  }
+}
diff --git a/folly/wangle/codec/ByteToMessageCodec.cpp b/folly/wangle/codec/ByteToMessageCodec.cpp
new file mode 100644
index 0000000..e16183b
--- /dev/null
+++ b/folly/wangle/codec/ByteToMessageCodec.cpp
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <folly/wangle/codec/ByteToMessageCodec.h>
+
+namespace folly { namespace wangle {
+
+void ByteToMessageCodec::read(Context* ctx, IOBufQueue& q) {
+  size_t needed = 0;
+  std::unique_ptr<IOBuf> result;
+  while (true) {
+    result = decode(ctx, q, needed);
+    if (result) {
+      ctx->fireRead(std::move(result));
+    } else {
+      break;
+    }
+  }
+}
+
+}} // namespace
diff --git a/folly/wangle/codec/CodecTest.cpp b/folly/wangle/codec/CodecTest.cpp
new file mode 100644
index 0000000..ecca824
--- /dev/null
+++ b/folly/wangle/codec/CodecTest.cpp
@@ -0,0 +1,637 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <gtest/gtest.h>
+
+#include <folly/wangle/codec/FixedLengthFrameDecoder.h>
+#include <folly/wangle/codec/LengthFieldBasedFrameDecoder.h>
+#include <folly/wangle/codec/LengthFieldPrepender.h>
+#include <folly/wangle/codec/LineBasedFrameDecoder.h>
+
+using namespace folly;
+using namespace folly::wangle;
+using namespace folly::io;
+
+class FrameTester
+    : public InboundHandler<std::unique_ptr<IOBuf>> {
+ public:
+  explicit FrameTester(std::function<void(std::unique_ptr<IOBuf>)> test)
+    : test_(test) {}
+
+  void read(Context* ctx, std::unique_ptr<IOBuf> buf) {
+    test_(std::move(buf));
+  }
+
+  void readException(Context* ctx, exception_wrapper w) {
+    test_(nullptr);
+  }
+ private:
+  std::function<void(std::unique_ptr<IOBuf>)> test_;
+};
+
+class BytesReflector
+    : public BytesToBytesHandler {
+ public:
+
+  Future<void> write(Context* ctx, std::unique_ptr<IOBuf> buf) {
+    IOBufQueue q_(IOBufQueue::cacheChainLength());
+    q_.append(std::move(buf));
+    ctx->fireRead(q_);
+
+    return makeFuture();
+  }
+};
+
+TEST(FixedLengthFrameDecoder, FailWhenLengthFieldEndOffset) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(FixedLengthFrameDecoder(10))
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        auto sz = buf->computeChainDataLength();
+        called++;
+        EXPECT_EQ(sz, 10);
+      }))
+    .finalize();
+
+  auto buf3 = IOBuf::create(3);
+  buf3->append(3);
+  auto buf11 = IOBuf::create(11);
+  buf11->append(11);
+  auto buf16 = IOBuf::create(16);
+  buf16->append(16);
+
+  IOBufQueue q(IOBufQueue::cacheChainLength());
+
+  q.append(std::move(buf3));
+  pipeline.read(q);
+  EXPECT_EQ(called, 0);
+
+  q.append(std::move(buf11));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+
+  q.append(std::move(buf16));
+  pipeline.read(q);
+  EXPECT_EQ(called, 3);
+}
+
+TEST(LengthFieldFramePipeline, SimpleTest) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(BytesReflector())
+    .addBack(LengthFieldPrepender())
+    .addBack(LengthFieldBasedFrameDecoder())
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        auto sz = buf->computeChainDataLength();
+        called++;
+        EXPECT_EQ(sz, 2);
+      }))
+    .finalize();
+
+  auto buf = IOBuf::create(2);
+  buf->append(2);
+  pipeline.write(std::move(buf));
+  EXPECT_EQ(called, 1);
+}
+
+TEST(LengthFieldFramePipeline, LittleEndian) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(BytesReflector())
+    .addBack(LengthFieldBasedFrameDecoder(4, 100, 0, 0, 4, false))
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        auto sz = buf->computeChainDataLength();
+        called++;
+        EXPECT_EQ(sz, 1);
+      }))
+    .addBack(LengthFieldPrepender(4, 0, false, false))
+    .finalize();
+
+  auto buf = IOBuf::create(1);
+  buf->append(1);
+  pipeline.write(std::move(buf));
+  EXPECT_EQ(called, 1);
+}
+
+TEST(LengthFieldFrameDecoder, Simple) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(LengthFieldBasedFrameDecoder())
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        auto sz = buf->computeChainDataLength();
+        called++;
+        EXPECT_EQ(sz, 1);
+      }))
+    .finalize();
+
+  auto bufFrame = IOBuf::create(4);
+  bufFrame->append(4);
+  RWPrivateCursor c(bufFrame.get());
+  c.writeBE((uint32_t)1);
+  auto bufData = IOBuf::create(1);
+  bufData->append(1);
+
+  IOBufQueue q(IOBufQueue::cacheChainLength());
+
+  q.append(std::move(bufFrame));
+  pipeline.read(q);
+  EXPECT_EQ(called, 0);
+
+  q.append(std::move(bufData));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+}
+
+TEST(LengthFieldFrameDecoder, NoStrip) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(LengthFieldBasedFrameDecoder(2, 10, 0, 0, 0))
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        auto sz = buf->computeChainDataLength();
+        called++;
+        EXPECT_EQ(sz, 3);
+      }))
+    .finalize();
+
+  auto bufFrame = IOBuf::create(2);
+  bufFrame->append(2);
+  RWPrivateCursor c(bufFrame.get());
+  c.writeBE((uint16_t)1);
+  auto bufData = IOBuf::create(1);
+  bufData->append(1);
+
+  IOBufQueue q(IOBufQueue::cacheChainLength());
+
+  q.append(std::move(bufFrame));
+  pipeline.read(q);
+  EXPECT_EQ(called, 0);
+
+  q.append(std::move(bufData));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+}
+
+TEST(LengthFieldFrameDecoder, Adjustment) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(LengthFieldBasedFrameDecoder(2, 10, 0, -2, 0))
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        auto sz = buf->computeChainDataLength();
+        called++;
+        EXPECT_EQ(sz, 3);
+      }))
+    .finalize();
+
+  auto bufFrame = IOBuf::create(2);
+  bufFrame->append(2);
+  RWPrivateCursor c(bufFrame.get());
+  c.writeBE((uint16_t)3); // includes frame size
+  auto bufData = IOBuf::create(1);
+  bufData->append(1);
+
+  IOBufQueue q(IOBufQueue::cacheChainLength());
+
+  q.append(std::move(bufFrame));
+  pipeline.read(q);
+  EXPECT_EQ(called, 0);
+
+  q.append(std::move(bufData));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+}
+
+TEST(LengthFieldFrameDecoder, PreHeader) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(LengthFieldBasedFrameDecoder(2, 10, 2, 0, 0))
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        auto sz = buf->computeChainDataLength();
+        called++;
+        EXPECT_EQ(sz, 5);
+      }))
+    .finalize();
+
+  auto bufFrame = IOBuf::create(4);
+  bufFrame->append(4);
+  RWPrivateCursor c(bufFrame.get());
+  c.write((uint16_t)100); // header
+  c.writeBE((uint16_t)1); // frame size
+  auto bufData = IOBuf::create(1);
+  bufData->append(1);
+
+  IOBufQueue q(IOBufQueue::cacheChainLength());
+
+  q.append(std::move(bufFrame));
+  pipeline.read(q);
+  EXPECT_EQ(called, 0);
+
+  q.append(std::move(bufData));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+}
+
+TEST(LengthFieldFrameDecoder, PostHeader) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(LengthFieldBasedFrameDecoder(2, 10, 0, 2, 0))
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        auto sz = buf->computeChainDataLength();
+        called++;
+        EXPECT_EQ(sz, 5);
+      }))
+    .finalize();
+
+  auto bufFrame = IOBuf::create(4);
+  bufFrame->append(4);
+  RWPrivateCursor c(bufFrame.get());
+  c.writeBE((uint16_t)1); // frame size
+  c.write((uint16_t)100); // header
+  auto bufData = IOBuf::create(1);
+  bufData->append(1);
+
+  IOBufQueue q(IOBufQueue::cacheChainLength());
+
+  q.append(std::move(bufFrame));
+  pipeline.read(q);
+  EXPECT_EQ(called, 0);
+
+  q.append(std::move(bufData));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+}
+
+TEST(LengthFieldFrameDecoderStrip, PrePostHeader) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(LengthFieldBasedFrameDecoder(2, 10, 2, 2, 4))
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        auto sz = buf->computeChainDataLength();
+        called++;
+        EXPECT_EQ(sz, 3);
+      }))
+    .finalize();
+
+  auto bufFrame = IOBuf::create(6);
+  bufFrame->append(6);
+  RWPrivateCursor c(bufFrame.get());
+  c.write((uint16_t)100); // pre header
+  c.writeBE((uint16_t)1); // frame size
+  c.write((uint16_t)100); // post header
+  auto bufData = IOBuf::create(1);
+  bufData->append(1);
+
+  IOBufQueue q(IOBufQueue::cacheChainLength());
+
+  q.append(std::move(bufFrame));
+  pipeline.read(q);
+  EXPECT_EQ(called, 0);
+
+  q.append(std::move(bufData));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+}
+
+TEST(LengthFieldFrameDecoder, StripPrePostHeaderFrameInclHeader) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(LengthFieldBasedFrameDecoder(2, 10, 2, -2, 4))
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        auto sz = buf->computeChainDataLength();
+        called++;
+        EXPECT_EQ(sz, 3);
+      }))
+    .finalize();
+
+  auto bufFrame = IOBuf::create(6);
+  bufFrame->append(6);
+  RWPrivateCursor c(bufFrame.get());
+  c.write((uint16_t)100); // pre header
+  c.writeBE((uint16_t)5); // frame size
+  c.write((uint16_t)100); // post header
+  auto bufData = IOBuf::create(1);
+  bufData->append(1);
+
+  IOBufQueue q(IOBufQueue::cacheChainLength());
+
+  q.append(std::move(bufFrame));
+  pipeline.read(q);
+  EXPECT_EQ(called, 0);
+
+  q.append(std::move(bufData));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+}
+
+TEST(LengthFieldFrameDecoder, FailTestLengthFieldEndOffset) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(LengthFieldBasedFrameDecoder(4, 10, 4, -2, 4))
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        ASSERT_EQ(nullptr, buf);
+        called++;
+      }))
+    .finalize();
+
+  auto bufFrame = IOBuf::create(8);
+  bufFrame->append(8);
+  RWPrivateCursor c(bufFrame.get());
+  c.writeBE((uint32_t)0); // frame size
+  c.write((uint32_t)0); // crap
+
+  IOBufQueue q(IOBufQueue::cacheChainLength());
+
+  q.append(std::move(bufFrame));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+}
+
+TEST(LengthFieldFrameDecoder, FailTestLengthFieldFrameSize) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(LengthFieldBasedFrameDecoder(4, 10, 0, 0, 4))
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        ASSERT_EQ(nullptr, buf);
+        called++;
+      }))
+    .finalize();
+
+  auto bufFrame = IOBuf::create(16);
+  bufFrame->append(16);
+  RWPrivateCursor c(bufFrame.get());
+  c.writeBE((uint32_t)12); // frame size
+  c.write((uint32_t)0); // nothing
+  c.write((uint32_t)0); // nothing
+  c.write((uint32_t)0); // nothing
+
+  IOBufQueue q(IOBufQueue::cacheChainLength());
+
+  q.append(std::move(bufFrame));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+}
+
+TEST(LengthFieldFrameDecoder, FailTestLengthFieldInitialBytes) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(LengthFieldBasedFrameDecoder(4, 10, 0, 0, 10))
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        ASSERT_EQ(nullptr, buf);
+        called++;
+      }))
+    .finalize();
+
+  auto bufFrame = IOBuf::create(16);
+  bufFrame->append(16);
+  RWPrivateCursor c(bufFrame.get());
+  c.writeBE((uint32_t)4); // frame size
+  c.write((uint32_t)0); // nothing
+  c.write((uint32_t)0); // nothing
+  c.write((uint32_t)0); // nothing
+
+  IOBufQueue q(IOBufQueue::cacheChainLength());
+
+  q.append(std::move(bufFrame));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+}
+
+TEST(LineBasedFrameDecoder, Simple) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(LineBasedFrameDecoder(10))
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        auto sz = buf->computeChainDataLength();
+        called++;
+        EXPECT_EQ(sz, 3);
+      }))
+    .finalize();
+
+  auto buf = IOBuf::create(3);
+  buf->append(3);
+
+  IOBufQueue q(IOBufQueue::cacheChainLength());
+
+  q.append(std::move(buf));
+  pipeline.read(q);
+  EXPECT_EQ(called, 0);
+
+  buf = IOBuf::create(1);
+  buf->append(1);
+  RWPrivateCursor c(buf.get());
+  c.write<char>('\n');
+  q.append(std::move(buf));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+
+  buf = IOBuf::create(4);
+  buf->append(4);
+  RWPrivateCursor c1(buf.get());
+  c1.write(' ');
+  c1.write(' ');
+  c1.write(' ');
+
+  c1.write('\r');
+  q.append(std::move(buf));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+
+  buf = IOBuf::create(1);
+  buf->append(1);
+  RWPrivateCursor c2(buf.get());
+  c2.write('\n');
+  q.append(std::move(buf));
+  pipeline.read(q);
+  EXPECT_EQ(called, 2);
+}
+
+TEST(LineBasedFrameDecoder, SaveDelimiter) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(LineBasedFrameDecoder(10, false))
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        auto sz = buf->computeChainDataLength();
+        called++;
+        EXPECT_EQ(sz, 4);
+      }))
+    .finalize();
+
+  auto buf = IOBuf::create(3);
+  buf->append(3);
+
+  IOBufQueue q(IOBufQueue::cacheChainLength());
+
+  q.append(std::move(buf));
+  pipeline.read(q);
+  EXPECT_EQ(called, 0);
+
+  buf = IOBuf::create(1);
+  buf->append(1);
+  RWPrivateCursor c(buf.get());
+  c.write<char>('\n');
+  q.append(std::move(buf));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+
+  buf = IOBuf::create(3);
+  buf->append(3);
+  RWPrivateCursor c1(buf.get());
+  c1.write(' ');
+  c1.write(' ');
+  c1.write('\r');
+  q.append(std::move(buf));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+
+  buf = IOBuf::create(1);
+  buf->append(1);
+  RWPrivateCursor c2(buf.get());
+  c2.write('\n');
+  q.append(std::move(buf));
+  pipeline.read(q);
+  EXPECT_EQ(called, 2);
+}
+
+TEST(LineBasedFrameDecoder, Fail) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(LineBasedFrameDecoder(10))
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        ASSERT_EQ(nullptr, buf);
+        called++;
+      }))
+    .finalize();
+
+  auto buf = IOBuf::create(11);
+  buf->append(11);
+
+  IOBufQueue q(IOBufQueue::cacheChainLength());
+
+  q.append(std::move(buf));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+
+  buf = IOBuf::create(1);
+  buf->append(1);
+  q.append(std::move(buf));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+
+  buf = IOBuf::create(2);
+  buf->append(2);
+  RWPrivateCursor c(buf.get());
+  c.write(' ');
+  c.write<char>('\n');
+  q.append(std::move(buf));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+
+  buf = IOBuf::create(12);
+  buf->append(12);
+  RWPrivateCursor c2(buf.get());
+  for (int i = 0; i < 11; i++) {
+    c2.write(' ');
+  }
+  c2.write<char>('\n');
+  q.append(std::move(buf));
+  pipeline.read(q);
+  EXPECT_EQ(called, 2);
+}
+
+TEST(LineBasedFrameDecoder, NewLineOnly) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(LineBasedFrameDecoder(
+               10, true, LineBasedFrameDecoder::TerminatorType::NEWLINE))
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        auto sz = buf->computeChainDataLength();
+        called++;
+        EXPECT_EQ(sz, 1);
+      }))
+    .finalize();
+
+  auto buf = IOBuf::create(2);
+  buf->append(2);
+  RWPrivateCursor c(buf.get());
+  c.write<char>('\r');
+  c.write<char>('\n');
+
+  IOBufQueue q(IOBufQueue::cacheChainLength());
+
+  q.append(std::move(buf));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+}
+
+TEST(LineBasedFrameDecoder, CarriageNewLineOnly) {
+  Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>> pipeline;
+  int called = 0;
+
+  pipeline
+    .addBack(LineBasedFrameDecoder(
+              10, true, LineBasedFrameDecoder::TerminatorType::CARRIAGENEWLINE))
+    .addBack(FrameTester([&](std::unique_ptr<IOBuf> buf) {
+        auto sz = buf->computeChainDataLength();
+        called++;
+        EXPECT_EQ(sz, 1);
+      }))
+    .finalize();
+
+  auto buf = IOBuf::create(3);
+  buf->append(3);
+  RWPrivateCursor c(buf.get());
+  c.write<char>('\n');
+  c.write<char>('\r');
+  c.write<char>('\n');
+
+  IOBufQueue q(IOBufQueue::cacheChainLength());
+
+  q.append(std::move(buf));
+  pipeline.read(q);
+  EXPECT_EQ(called, 1);
+}
diff --git a/folly/wangle/codec/LengthFieldBasedFrameDecoder.cpp b/folly/wangle/codec/LengthFieldBasedFrameDecoder.cpp
new file mode 100644
index 0000000..5fff70d
--- /dev/null
+++ b/folly/wangle/codec/LengthFieldBasedFrameDecoder.cpp
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <folly/wangle/codec/LengthFieldBasedFrameDecoder.h>
+
+namespace folly { namespace wangle {
+
+LengthFieldBasedFrameDecoder::LengthFieldBasedFrameDecoder(
+  uint32_t lengthFieldLength,
+  uint32_t maxFrameLength,
+  uint32_t lengthFieldOffset,
+  uint32_t lengthAdjustment,
+  uint32_t initialBytesToStrip,
+  bool networkByteOrder)
+    : lengthFieldLength_(lengthFieldLength)
+    , maxFrameLength_(maxFrameLength)
+    , lengthFieldOffset_(lengthFieldOffset)
+    , lengthAdjustment_(lengthAdjustment)
+    , initialBytesToStrip_(initialBytesToStrip)
+    , networkByteOrder_(networkByteOrder)
+    , lengthFieldEndOffset_(lengthFieldOffset + lengthFieldLength) {
+  CHECK(maxFrameLength > 0);
+  CHECK(lengthFieldOffset <= maxFrameLength - lengthFieldLength);
+}
+
+std::unique_ptr<IOBuf> LengthFieldBasedFrameDecoder::decode(
+  Context* ctx, IOBufQueue& buf, size_t&) {
+  // discarding too long frame
+  if (buf.chainLength() < lengthFieldEndOffset_) {
+    return nullptr;
+  }
+
+  uint64_t frameLength = getUnadjustedFrameLength(
+    buf, lengthFieldOffset_, lengthFieldLength_, networkByteOrder_);
+
+  frameLength += lengthAdjustment_ + lengthFieldEndOffset_;
+
+  if (frameLength < lengthFieldEndOffset_) {
+    buf.trimStart(lengthFieldEndOffset_);
+    ctx->fireReadException(folly::make_exception_wrapper<std::runtime_error>(
+                             "Frame too small"));
+    return nullptr;
+  }
+
+  if (frameLength > maxFrameLength_) {
+    buf.trimStart(frameLength);
+    ctx->fireReadException(folly::make_exception_wrapper<std::runtime_error>(
+                             "Frame larger than " +
+                             folly::to<std::string>(maxFrameLength_)));
+    return nullptr;
+  }
+
+  if (buf.chainLength() < frameLength) {
+    return nullptr;
+  }
+
+  if (initialBytesToStrip_ > frameLength) {
+    buf.trimStart(frameLength);
+    ctx->fireReadException(folly::make_exception_wrapper<std::runtime_error>(
+                             "InitialBytesToSkip larger than frame"));
+    return nullptr;
+  }
+
+  buf.trimStart(initialBytesToStrip_);
+  int actualFrameLength = frameLength - initialBytesToStrip_;
+  return buf.split(actualFrameLength);
+}
+
+uint64_t LengthFieldBasedFrameDecoder::getUnadjustedFrameLength(
+  IOBufQueue& buf, int offset, int length, bool networkByteOrder) {
+  folly::io::Cursor c(buf.front());
+  uint64_t frameLength;
+
+  c.skip(offset);
+
+  switch(length) {
+    case 1:{
+      if (networkByteOrder) {
+        frameLength = c.readBE<uint8_t>();
+      } else {
+        frameLength = c.readLE<uint8_t>();
+      }
+      break;
+    }
+    case 2:{
+      if (networkByteOrder) {
+        frameLength = c.readBE<uint16_t>();
+      } else {
+        frameLength = c.readLE<uint16_t>();
+      }
+      break;
+    }
+    case 4:{
+      if (networkByteOrder) {
+        frameLength = c.readBE<uint32_t>();
+      } else {
+        frameLength = c.readLE<uint32_t>();
+      }
+      break;
+    }
+    case 8:{
+      if (networkByteOrder) {
+        frameLength = c.readBE<uint64_t>();
+      } else {
+        frameLength = c.readLE<uint64_t>();
+      }
+      break;
+    }
+  }
+
+  return frameLength;
+}
+
+
+}} // namespace
diff --git a/folly/wangle/codec/LengthFieldPrepender.cpp b/folly/wangle/codec/LengthFieldPrepender.cpp
new file mode 100644
index 0000000..88238e0
--- /dev/null
+++ b/folly/wangle/codec/LengthFieldPrepender.cpp
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <folly/wangle/codec/LengthFieldPrepender.h>
+
+namespace folly { namespace wangle {
+
+LengthFieldPrepender::LengthFieldPrepender(
+    int lengthFieldLength,
+    int lengthAdjustment,
+    bool lengthIncludesLengthField,
+    bool networkByteOrder)
+    : lengthFieldLength_(lengthFieldLength)
+    , lengthAdjustment_(lengthAdjustment)
+    , lengthIncludesLengthField_(lengthIncludesLengthField)
+    , networkByteOrder_(networkByteOrder) {
+    CHECK(lengthFieldLength == 1 ||
+          lengthFieldLength == 2 ||
+          lengthFieldLength == 4 ||
+          lengthFieldLength == 8 );
+  }
+
+Future<void> LengthFieldPrepender::write(
+    Context* ctx, std::unique_ptr<IOBuf> buf) {
+  int length = lengthAdjustment_ + buf->computeChainDataLength();
+  if (lengthIncludesLengthField_) {
+    length += lengthFieldLength_;
+  }
+
+  if (length < 0) {
+    throw std::runtime_error("Length field < 0");
+  }
+
+  auto len = IOBuf::create(lengthFieldLength_);
+  len->append(lengthFieldLength_);
+  folly::io::RWPrivateCursor c(len.get());
+
+  switch (lengthFieldLength_) {
+    case 1: {
+      if (length >= 256) {
+        throw std::runtime_error("length does not fit byte");
+      }
+      if (networkByteOrder_) {
+        c.writeBE((uint8_t)length);
+      } else {
+        c.writeLE((uint8_t)length);
+      }
+      break;
+    }
+    case 2: {
+      if (length >= 65536) {
+        throw std::runtime_error("length does not fit byte");
+      }
+      if (networkByteOrder_) {
+        c.writeBE((uint16_t)length);
+      } else {
+        c.writeLE((uint16_t)length);
+      }
+      break;
+    }
+    case 4: {
+      if (networkByteOrder_) {
+        c.writeBE((uint32_t)length);
+      } else {
+        c.writeLE((uint32_t)length);
+      }
+      break;
+    }
+    case 8: {
+      if (networkByteOrder_) {
+        c.writeBE((uint64_t)length);
+      } else {
+        c.writeLE((uint64_t)length);
+      }
+      break;
+    }
+    default: {
+      throw std::runtime_error("Invalid lengthFieldLength");
+    }
+  }
+
+  len->prependChain(std::move(buf));
+  return ctx->fireWrite(std::move(len));
+}
+
+
+}} // Namespace
diff --git a/folly/wangle/codec/LineBasedFrameDecoder.cpp b/folly/wangle/codec/LineBasedFrameDecoder.cpp
new file mode 100644
index 0000000..ab0bb07
--- /dev/null
+++ b/folly/wangle/codec/LineBasedFrameDecoder.cpp
@@ -0,0 +1,103 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <folly/wangle/codec/LineBasedFrameDecoder.h>
+
+namespace folly { namespace wangle {
+
+using folly::io::Cursor;
+
+LineBasedFrameDecoder::LineBasedFrameDecoder(uint32_t maxLength,
+                                             bool stripDelimiter,
+                                             TerminatorType terminatorType)
+    : maxLength_(maxLength)
+    , stripDelimiter_(stripDelimiter)
+    , terminatorType_(terminatorType) {}
+
+std::unique_ptr<IOBuf> LineBasedFrameDecoder::decode(
+  Context* ctx, IOBufQueue& buf, size_t&) {
+  int64_t eol = findEndOfLine(buf);
+
+  if (!discarding_) {
+    if (eol >= 0) {
+      Cursor c(buf.front());
+      c += eol;
+      auto delimLength = c.read<char>() == '\r' ? 2 : 1;
+      if (eol > maxLength_) {
+        buf.split(eol + delimLength);
+        fail(ctx, folly::to<std::string>(eol));
+        return nullptr;
+      }
+
+      std::unique_ptr<folly::IOBuf> frame;
+
+      if (stripDelimiter_) {
+        frame = buf.split(eol);
+        buf.trimStart(delimLength);
+      } else {
+        frame = buf.split(eol + delimLength);
+      }
+
+      return std::move(frame);
+    } else {
+      auto len = buf.chainLength();
+      if (len > maxLength_) {
+        discardedBytes_ = len;
+        buf.trimStart(len);
+        discarding_ = true;
+        fail(ctx, "over " + folly::to<std::string>(len));
+      }
+      return nullptr;
+    }
+  } else {
+    if (eol >= 0) {
+      Cursor c(buf.front());
+      c += eol;
+      auto delimLength = c.read<char>() == '\r' ? 2 : 1;
+      buf.trimStart(eol + delimLength);
+      discardedBytes_ = 0;
+      discarding_ = false;
+    } else {
+      discardedBytes_ = buf.chainLength();
+      buf.move();
+    }
+
+    return nullptr;
+  }
+}
+
+void LineBasedFrameDecoder::fail(Context* ctx, std::string len) {
+  ctx->fireReadException(
+    folly::make_exception_wrapper<std::runtime_error>(
+      "frame length" + len +
+      " exeeds max " + folly::to<std::string>(maxLength_)));
+}
+
+int64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& buf) {
+  Cursor c(buf.front());
+  for (uint32_t i = 0; i < maxLength_ && i < buf.chainLength(); i++) {
+    auto b = c.read<char>();
+    if (b == '\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE) {
+      return i;
+    } else if (terminatorType_ != TerminatorType::NEWLINE &&
+               b == '\r' && !c.isAtEnd() && c.read<char>() == '\n') {
+      return i;
+    }
+  }
+
+  return -1;
+}
+
+}} // namespace
diff --git a/folly/wangle/concurrent/CPUThreadPoolExecutor.cpp b/folly/wangle/concurrent/CPUThreadPoolExecutor.cpp
new file mode 100644
index 0000000..864bd3a
--- /dev/null
+++ b/folly/wangle/concurrent/CPUThreadPoolExecutor.cpp
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <folly/wangle/concurrent/CPUThreadPoolExecutor.h>
+#include <folly/wangle/concurrent/PriorityLifoSemMPMCQueue.h>
+
+namespace folly { namespace wangle {
+
+const size_t CPUThreadPoolExecutor::kDefaultMaxQueueSize = 1 << 14;
+
+CPUThreadPoolExecutor::CPUThreadPoolExecutor(
+    size_t numThreads,
+    std::unique_ptr<BlockingQueue<CPUTask>> taskQueue,
+    std::shared_ptr<ThreadFactory> threadFactory)
+    : ThreadPoolExecutor(numThreads, std::move(threadFactory)),
+      taskQueue_(std::move(taskQueue)) {
+  addThreads(numThreads);
+  CHECK(threadList_.get().size() == numThreads);
+}
+
+CPUThreadPoolExecutor::CPUThreadPoolExecutor(
+    size_t numThreads,
+    std::shared_ptr<ThreadFactory> threadFactory)
+    : CPUThreadPoolExecutor(
+          numThreads,
+          folly::make_unique<LifoSemMPMCQueue<CPUTask>>(
+              CPUThreadPoolExecutor::kDefaultMaxQueueSize),
+          std::move(threadFactory)) {}
+
+CPUThreadPoolExecutor::CPUThreadPoolExecutor(size_t numThreads)
+    : CPUThreadPoolExecutor(
+          numThreads,
+          std::make_shared<NamedThreadFactory>("CPUThreadPool")) {}
+
+CPUThreadPoolExecutor::CPUThreadPoolExecutor(
+    size_t numThreads,
+    int8_t numPriorities,
+    std::shared_ptr<ThreadFactory> threadFactory)
+    : CPUThreadPoolExecutor(
+          numThreads,
+          folly::make_unique<PriorityLifoSemMPMCQueue<CPUTask>>(
+              numPriorities,
+              CPUThreadPoolExecutor::kDefaultMaxQueueSize),
+          std::move(threadFactory)) {}
+
+CPUThreadPoolExecutor::CPUThreadPoolExecutor(
+    size_t numThreads,
+    int8_t numPriorities,
+    size_t maxQueueSize,
+    std::shared_ptr<ThreadFactory> threadFactory)
+    : CPUThreadPoolExecutor(
+          numThreads,
+          folly::make_unique<PriorityLifoSemMPMCQueue<CPUTask>>(
+              numPriorities,
+              maxQueueSize),
+          std::move(threadFactory)) {}
+
+CPUThreadPoolExecutor::~CPUThreadPoolExecutor() {
+  stop();
+  CHECK(threadsToStop_ == 0);
+}
+
+void CPUThreadPoolExecutor::add(Func func) {
+  add(std::move(func), std::chrono::milliseconds(0));
+}
+
+void CPUThreadPoolExecutor::add(
+    Func func,
+    std::chrono::milliseconds expiration,
+    Func expireCallback) {
+  // TODO handle enqueue failure, here and in other add() callsites
+  taskQueue_->add(
+      CPUTask(std::move(func), expiration, std::move(expireCallback)));
+}
+
+void CPUThreadPoolExecutor::addWithPriority(Func func, int8_t priority) {
+  add(std::move(func), priority, std::chrono::milliseconds(0));
+}
+
+void CPUThreadPoolExecutor::add(
+    Func func,
+    int8_t priority,
+    std::chrono::milliseconds expiration,
+    Func expireCallback) {
+  CHECK(getNumPriorities() > 0);
+  taskQueue_->addWithPriority(
+      CPUTask(std::move(func), expiration, std::move(expireCallback)),
+      priority);
+}
+
+uint8_t CPUThreadPoolExecutor::getNumPriorities() const {
+  return taskQueue_->getNumPriorities();
+}
+
+BlockingQueue<CPUThreadPoolExecutor::CPUTask>*
+CPUThreadPoolExecutor::getTaskQueue() {
+  return taskQueue_.get();
+}
+
+void CPUThreadPoolExecutor::threadRun(std::shared_ptr<Thread> thread) {
+  thread->startupBaton.post();
+  while (1) {
+    auto task = taskQueue_->take();
+    if (UNLIKELY(task.poison)) {
+      CHECK(threadsToStop_-- > 0);
+      for (auto& o : observers_) {
+        o->threadStopped(thread.get());
+      }
+
+      stoppedThreads_.add(thread);
+      return;
+    } else {
+      runTask(thread, std::move(task));
+    }
+
+    if (UNLIKELY(threadsToStop_ > 0 && !isJoin_)) {
+      if (--threadsToStop_ >= 0) {
+        stoppedThreads_.add(thread);
+        return;
+      } else {
+        threadsToStop_++;
+      }
+    }
+  }
+}
+
+void CPUThreadPoolExecutor::stopThreads(size_t n) {
+  CHECK(stoppedThreads_.size() == 0);
+  threadsToStop_ = n;
+  for (size_t i = 0; i < n; i++) {
+    taskQueue_->addWithPriority(CPUTask(), Executor::LO_PRI);
+  }
+}
+
+uint64_t CPUThreadPoolExecutor::getPendingTaskCount() {
+  return taskQueue_->size();
+}
+
+}} // folly::wangle
diff --git a/folly/wangle/concurrent/Codel.cpp b/folly/wangle/concurrent/Codel.cpp
new file mode 100644
index 0000000..74a832b
--- /dev/null
+++ b/folly/wangle/concurrent/Codel.cpp
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <folly/wangle/concurrent/Codel.h>
+#include <algorithm>
+#include <math.h>
+
+#ifndef NO_LIB_GFLAGS
+  #include <gflags/gflags.h>
+  DEFINE_int32(codel_interval, 100,
+               "Codel default interval time in ms");
+  DEFINE_int32(codel_target_delay, 5,
+               "Target codel queueing delay in ms");
+#endif
+
+namespace folly { namespace wangle {
+
+#ifdef NO_LIB_GFLAGS
+  int32_t FLAGS_codel_interval = 100;
+  int32_t FLAGS_codel_target_delay = 5;
+#endif
+
+Codel::Codel()
+    : codelMinDelay_(0),
+      codelIntervalTime_(std::chrono::steady_clock::now()),
+      codelResetDelay_(true),
+      overloaded_(false) {}
+
+bool Codel::overloaded(std::chrono::microseconds delay) {
+  bool ret = false;
+  auto now = std::chrono::steady_clock::now();
+
+  // Avoid another thread updating the value at the same time we are using it
+  // to calculate the overloaded state
+  auto minDelay = codelMinDelay_;
+
+  if (now  > codelIntervalTime_ &&
+      (!codelResetDelay_.load(std::memory_order_acquire)
+       && !codelResetDelay_.exchange(true))) {
+    codelIntervalTime_ = now + std::chrono::milliseconds(FLAGS_codel_interval);
+
+    if (minDelay > std::chrono::milliseconds(FLAGS_codel_target_delay)) {
+      overloaded_ = true;
+    } else {
+      overloaded_ = false;
+    }
+  }
+  // Care must be taken that only a single thread resets codelMinDelay_,
+  // and that it happens after the interval reset above
+  if (codelResetDelay_.load(std::memory_order_acquire) &&
+      codelResetDelay_.exchange(false)) {
+    codelMinDelay_ = delay;
+    // More than one request must come in during an interval before codel
+    // starts dropping requests
+    return false;
+  } else if(delay < codelMinDelay_) {
+    codelMinDelay_ = delay;
+  }
+
+  if (overloaded_ &&
+      delay > std::chrono::milliseconds(FLAGS_codel_target_delay * 2)) {
+    ret = true;
+  }
+
+  return ret;
+
+}
+
+int Codel::getLoad() {
+  return std::min(100, (int)codelMinDelay_.count() /
+                  (2 * FLAGS_codel_target_delay));
+}
+
+int Codel::getMinDelay() {
+  return (int) codelMinDelay_.count();
+}
+
+}} //namespace
diff --git a/folly/wangle/concurrent/GlobalExecutor.cpp b/folly/wangle/concurrent/GlobalExecutor.cpp
new file mode 100644
index 0000000..36a8215
--- /dev/null
+++ b/folly/wangle/concurrent/GlobalExecutor.cpp
@@ -0,0 +1,120 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <folly/Singleton.h>
+#include <folly/wangle/concurrent/IOExecutor.h>
+#include <folly/wangle/concurrent/IOThreadPoolExecutor.h>
+#include <folly/futures/InlineExecutor.h>
+
+using namespace folly;
+using namespace folly::wangle;
+
+namespace {
+
+// lock protecting global CPU executor
+struct CPUExecutorLock {};
+Singleton<RWSpinLock, CPUExecutorLock> globalCPUExecutorLock;
+// global CPU executor
+Singleton<std::weak_ptr<Executor>> globalCPUExecutor;
+// default global CPU executor is an InlineExecutor
+Singleton<std::shared_ptr<InlineExecutor>> globalInlineExecutor(
+    []{
+      return new std::shared_ptr<InlineExecutor>(
+          std::make_shared<InlineExecutor>());
+    });
+
+// lock protecting global IO executor
+struct IOExecutorLock {};
+Singleton<RWSpinLock, IOExecutorLock> globalIOExecutorLock;
+// global IO executor
+Singleton<std::weak_ptr<IOExecutor>> globalIOExecutor;
+// default global IO executor is an IOThreadPoolExecutor
+Singleton<std::shared_ptr<IOThreadPoolExecutor>> globalIOThreadPool(
+    []{
+      return new std::shared_ptr<IOThreadPoolExecutor>(
+          std::make_shared<IOThreadPoolExecutor>(
+              sysconf(_SC_NPROCESSORS_ONLN),
+              std::make_shared<NamedThreadFactory>("GlobalIOThreadPool")));
+    });
+
+}
+
+namespace folly { namespace wangle {
+
+template <class Exe, class DefaultExe, class LockTag>
+std::shared_ptr<Exe> getExecutor(
+    Singleton<std::weak_ptr<Exe>>& sExecutor,
+    Singleton<std::shared_ptr<DefaultExe>>& sDefaultExecutor,
+    Singleton<RWSpinLock, LockTag>& sExecutorLock) {
+  std::shared_ptr<Exe> executor;
+  auto singleton = sExecutor.get();
+  auto lock = sExecutorLock.get();
+
+  {
+    RWSpinLock::ReadHolder guard(lock);
+    if ((executor = sExecutor->lock())) {
+      return executor;
+    }
+  }
+
+
+  RWSpinLock::WriteHolder guard(lock);
+  executor = singleton->lock();
+  if (!executor) {
+    executor = *sDefaultExecutor.get();
+    *singleton = executor;
+  }
+  return executor;
+}
+
+template <class Exe, class LockTag>
+void setExecutor(
+    std::shared_ptr<Exe> executor,
+    Singleton<std::weak_ptr<Exe>>& sExecutor,
+    Singleton<RWSpinLock, LockTag>& sExecutorLock) {
+  RWSpinLock::WriteHolder guard(sExecutorLock.get());
+  *sExecutor.get() = std::move(executor);
+}
+
+std::shared_ptr<Executor> getCPUExecutor() {
+  return getExecutor(
+      globalCPUExecutor,
+      globalInlineExecutor,
+      globalCPUExecutorLock);
+}
+
+void setCPUExecutor(std::shared_ptr<Executor> executor) {
+  setExecutor(
+      std::move(executor),
+      globalCPUExecutor,
+      globalCPUExecutorLock);
+}
+
+std::shared_ptr<IOExecutor> getIOExecutor() {
+  return getExecutor(
+      globalIOExecutor,
+      globalIOThreadPool,
+      globalIOExecutorLock);
+}
+
+void setIOExecutor(std::shared_ptr<IOExecutor> executor) {
+  setExecutor(
+      std::move(executor),
+      globalIOExecutor,
+      globalIOExecutorLock);
+}
+
+}} // folly::wangle
diff --git a/folly/wangle/concurrent/IOThreadPoolExecutor.cpp b/folly/wangle/concurrent/IOThreadPoolExecutor.cpp
new file mode 100644
index 0000000..f8a68e2
--- /dev/null
+++ b/folly/wangle/concurrent/IOThreadPoolExecutor.cpp
@@ -0,0 +1,188 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <folly/wangle/concurrent/IOThreadPoolExecutor.h>
+
+#include <folly/MoveWrapper.h>
+#include <glog/logging.h>
+
+#include <folly/detail/MemoryIdler.h>
+
+namespace folly { namespace wangle {
+
+using folly::detail::MemoryIdler;
+
+/* Class that will free jemalloc caches and madvise the stack away
+ * if the event loop is unused for some period of time
+ */
+class MemoryIdlerTimeout
+    : public AsyncTimeout , public EventBase::LoopCallback {
+ public:
+  explicit MemoryIdlerTimeout(EventBase* b) : AsyncTimeout(b), base_(b) {}
+
+  virtual void timeoutExpired() noexcept {
+    idled = true;
+  }
+
+  virtual void runLoopCallback() noexcept {
+    if (idled) {
+      MemoryIdler::flushLocalMallocCaches();
+      MemoryIdler::unmapUnusedStack(MemoryIdler::kDefaultStackToRetain);
+
+      idled = false;
+    } else {
+      std::chrono::steady_clock::duration idleTimeout =
+        MemoryIdler::defaultIdleTimeout.load(
+          std::memory_order_acquire);
+
+      idleTimeout = MemoryIdler::getVariationTimeout(idleTimeout);
+
+      scheduleTimeout(std::chrono::duration_cast<std::chrono::milliseconds>(
+                        idleTimeout).count());
+    }
+
+    // reschedule this callback for the next event loop.
+    base_->runBeforeLoop(this);
+  }
+ private:
+  EventBase* base_;
+  bool idled{false};
+} ;
+
+IOThreadPoolExecutor::IOThreadPoolExecutor(
+    size_t numThreads,
+    std::shared_ptr<ThreadFactory> threadFactory,
+    EventBaseManager* ebm)
+  : ThreadPoolExecutor(numThreads, std::move(threadFactory)),
+    nextThread_(0),
+    eventBaseManager_(ebm) {
+  addThreads(numThreads);
+  CHECK(threadList_.get().size() == numThreads);
+}
+
+IOThreadPoolExecutor::~IOThreadPoolExecutor() {
+  stop();
+}
+
+void IOThreadPoolExecutor::add(Func func) {
+  add(std::move(func), std::chrono::milliseconds(0));
+}
+
+void IOThreadPoolExecutor::add(
+    Func func,
+    std::chrono::milliseconds expiration,
+    Func expireCallback) {
+  RWSpinLock::ReadHolder{&threadListLock_};
+  if (threadList_.get().empty()) {
+    throw std::runtime_error("No threads available");
+  }
+  auto ioThread = pickThread();
+
+  auto moveTask = folly::makeMoveWrapper(
+      Task(std::move(func), expiration, std::move(expireCallback)));
+  auto wrappedFunc = [ioThread, moveTask] () mutable {
+    runTask(ioThread, std::move(*moveTask));
+    ioThread->pendingTasks--;
+  };
+
+  ioThread->pendingTasks++;
+  if (!ioThread->eventBase->runInEventBaseThread(std::move(wrappedFunc))) {
+    ioThread->pendingTasks--;
+    throw std::runtime_error("Unable to run func in event base thread");
+  }
+}
+
+std::shared_ptr<IOThreadPoolExecutor::IOThread>
+IOThreadPoolExecutor::pickThread() {
+  if (*thisThread_) {
+    return *thisThread_;
+  }
+  auto thread = threadList_.get()[nextThread_++ % threadList_.get().size()];
+  return std::static_pointer_cast<IOThread>(thread);
+}
+
+EventBase* IOThreadPoolExecutor::getEventBase() {
+  return pickThread()->eventBase;
+}
+
+EventBase* IOThreadPoolExecutor::getEventBase(
+    ThreadPoolExecutor::ThreadHandle* h) {
+  auto thread = dynamic_cast<IOThread*>(h);
+
+  if (thread) {
+    return thread->eventBase;
+  }
+
+  return nullptr;
+}
+
+EventBaseManager* IOThreadPoolExecutor::getEventBaseManager() {
+  return eventBaseManager_;
+}
+
+std::shared_ptr<ThreadPoolExecutor::Thread>
+IOThreadPoolExecutor::makeThread() {
+  return std::make_shared<IOThread>(this);
+}
+
+void IOThreadPoolExecutor::threadRun(ThreadPtr thread) {
+  const auto ioThread = std::static_pointer_cast<IOThread>(thread);
+  ioThread->eventBase = eventBaseManager_->getEventBase();
+  thisThread_.reset(new std::shared_ptr<IOThread>(ioThread));
+
+  auto idler = new MemoryIdlerTimeout(ioThread->eventBase);
+  ioThread->eventBase->runBeforeLoop(idler);
+
+  thread->startupBaton.post();
+  while (ioThread->shouldRun) {
+    ioThread->eventBase->loopForever();
+  }
+  if (isJoin_) {
+    while (ioThread->pendingTasks > 0) {
+      ioThread->eventBase->loopOnce();
+    }
+  }
+  stoppedThreads_.add(ioThread);
+}
+
+// threadListLock_ is writelocked
+void IOThreadPoolExecutor::stopThreads(size_t n) {
+  for (size_t i = 0; i < n; i++) {
+    const auto ioThread = std::static_pointer_cast<IOThread>(
+        threadList_.get()[i]);
+    for (auto& o : observers_) {
+      o->threadStopped(ioThread.get());
+    }
+    ioThread->shouldRun = false;
+    ioThread->eventBase->terminateLoopSoon();
+  }
+}
+
+// threadListLock_ is readlocked
+uint64_t IOThreadPoolExecutor::getPendingTaskCount() {
+  uint64_t count = 0;
+  for (const auto& thread : threadList_.get()) {
+    auto ioThread = std::static_pointer_cast<IOThread>(thread);
+    size_t pendingTasks = ioThread->pendingTasks;
+    if (pendingTasks > 0 && !ioThread->idle) {
+      pendingTasks--;
+    }
+    count += pendingTasks;
+  }
+  return count;
+}
+
+}} // folly::wangle
diff --git a/folly/wangle/concurrent/ThreadPoolExecutor.cpp b/folly/wangle/concurrent/ThreadPoolExecutor.cpp
new file mode 100644
index 0000000..2cf4029
--- /dev/null
+++ b/folly/wangle/concurrent/ThreadPoolExecutor.cpp
@@ -0,0 +1,202 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <folly/wangle/concurrent/ThreadPoolExecutor.h>
+
+namespace folly { namespace wangle {
+
+ThreadPoolExecutor::ThreadPoolExecutor(
+    size_t numThreads,
+    std::shared_ptr<ThreadFactory> threadFactory)
+    : threadFactory_(std::move(threadFactory)),
+      taskStatsSubject_(std::make_shared<Subject<TaskStats>>()) {}
+
+ThreadPoolExecutor::~ThreadPoolExecutor() {
+  CHECK(threadList_.get().size() == 0);
+}
+
+ThreadPoolExecutor::Task::Task(
+    Func&& func,
+    std::chrono::milliseconds expiration,
+    Func&& expireCallback)
+    : func_(std::move(func)),
+      expiration_(expiration),
+      expireCallback_(std::move(expireCallback)) {
+  // Assume that the task in enqueued on creation
+  enqueueTime_ = std::chrono::steady_clock::now();
+}
+
+void ThreadPoolExecutor::runTask(
+    const ThreadPtr& thread,
+    Task&& task) {
+  thread->idle = false;
+  auto startTime = std::chrono::steady_clock::now();
+  task.stats_.waitTime = startTime - task.enqueueTime_;
+  if (task.expiration_ > std::chrono::milliseconds(0) &&
+      task.stats_.waitTime >= task.expiration_) {
+    task.stats_.expired = true;
+    if (task.expireCallback_ != nullptr) {
+      task.expireCallback_();
+    }
+  } else {
+    try {
+      task.func_();
+    } catch (const std::exception& e) {
+      LOG(ERROR) << "ThreadPoolExecutor: func threw unhandled " <<
+                    typeid(e).name() << " exception: " << e.what();
+    } catch (...) {
+      LOG(ERROR) << "ThreadPoolExecutor: func threw unhandled non-exception "
+                    "object";
+    }
+    task.stats_.runTime = std::chrono::steady_clock::now() - startTime;
+  }
+  thread->idle = true;
+  thread->taskStatsSubject->onNext(std::move(task.stats_));
+}
+
+size_t ThreadPoolExecutor::numThreads() {
+  RWSpinLock::ReadHolder{&threadListLock_};
+  return threadList_.get().size();
+}
+
+void ThreadPoolExecutor::setNumThreads(size_t n) {
+  RWSpinLock::WriteHolder{&threadListLock_};
+  const auto current = threadList_.get().size();
+  if (n > current ) {
+    addThreads(n - current);
+  } else if (n < current) {
+    removeThreads(current - n, true);
+  }
+  CHECK(threadList_.get().size() == n);
+}
+
+// threadListLock_ is writelocked
+void ThreadPoolExecutor::addThreads(size_t n) {
+  std::vector<ThreadPtr> newThreads;
+  for (size_t i = 0; i < n; i++) {
+    newThreads.push_back(makeThread());
+  }
+  for (auto& thread : newThreads) {
+    // TODO need a notion of failing to create the thread
+    // and then handling for that case
+    thread->handle = threadFactory_->newThread(
+        std::bind(&ThreadPoolExecutor::threadRun, this, thread));
+    threadList_.add(thread);
+  }
+  for (auto& thread : newThreads) {
+    thread->startupBaton.wait();
+  }
+  for (auto& o : observers_) {
+    for (auto& thread : newThreads) {
+      o->threadStarted(thread.get());
+    }
+  }
+}
+
+// threadListLock_ is writelocked
+void ThreadPoolExecutor::removeThreads(size_t n, bool isJoin) {
+  CHECK(n <= threadList_.get().size());
+  CHECK(stoppedThreads_.size() == 0);
+  isJoin_ = isJoin;
+  stopThreads(n);
+  for (size_t i = 0; i < n; i++) {
+    auto thread = stoppedThreads_.take();
+    thread->handle.join();
+    threadList_.remove(thread);
+  }
+  CHECK(stoppedThreads_.size() == 0);
+}
+
+void ThreadPoolExecutor::stop() {
+  RWSpinLock::WriteHolder{&threadListLock_};
+  removeThreads(threadList_.get().size(), false);
+  CHECK(threadList_.get().size() == 0);
+}
+
+void ThreadPoolExecutor::join() {
+  RWSpinLock::WriteHolder{&threadListLock_};
+  removeThreads(threadList_.get().size(), true);
+  CHECK(threadList_.get().size() == 0);
+}
+
+ThreadPoolExecutor::PoolStats ThreadPoolExecutor::getPoolStats() {
+  RWSpinLock::ReadHolder{&threadListLock_};
+  ThreadPoolExecutor::PoolStats stats;
+  stats.threadCount = threadList_.get().size();
+  for (auto thread : threadList_.get()) {
+    if (thread->idle) {
+      stats.idleThreadCount++;
+    } else {
+      stats.activeThreadCount++;
+    }
+  }
+  stats.pendingTaskCount = getPendingTaskCount();
+  stats.totalTaskCount = stats.pendingTaskCount + stats.activeThreadCount;
+  return stats;
+}
+
+std::atomic<uint64_t> ThreadPoolExecutor::Thread::nextId(0);
+
+void ThreadPoolExecutor::StoppedThreadQueue::add(
+    ThreadPoolExecutor::ThreadPtr item) {
+  std::lock_guard<std::mutex> guard(mutex_);
+  queue_.push(std::move(item));
+  sem_.post();
+}
+
+ThreadPoolExecutor::ThreadPtr ThreadPoolExecutor::StoppedThreadQueue::take() {
+  while(1) {
+    {
+      std::lock_guard<std::mutex> guard(mutex_);
+      if (queue_.size() > 0) {
+        auto item = std::move(queue_.front());
+        queue_.pop();
+        return item;
+      }
+    }
+    sem_.wait();
+  }
+}
+
+size_t ThreadPoolExecutor::StoppedThreadQueue::size() {
+  std::lock_guard<std::mutex> guard(mutex_);
+  return queue_.size();
+}
+
+void ThreadPoolExecutor::addObserver(std::shared_ptr<Observer> o) {
+  RWSpinLock::ReadHolder{&threadListLock_};
+  observers_.push_back(o);
+  for (auto& thread : threadList_.get()) {
+    o->threadPreviouslyStarted(thread.get());
+  }
+}
+
+void ThreadPoolExecutor::removeObserver(std::shared_ptr<Observer> o) {
+  RWSpinLock::ReadHolder{&threadListLock_};
+  for (auto& thread : threadList_.get()) {
+    o->threadNotYetStopped(thread.get());
+  }
+
+  for (auto it = observers_.begin(); it != observers_.end(); it++) {
+    if (*it == o) {
+      observers_.erase(it);
+      return;
+    }
+  }
+  DCHECK(false);
+}
+
+}} // folly::wangle
diff --git a/folly/wangle/concurrent/test/CodelTest.cpp b/folly/wangle/concurrent/test/CodelTest.cpp
new file mode 100644
index 0000000..fd420ba
--- /dev/null
+++ b/folly/wangle/concurrent/test/CodelTest.cpp
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <chrono>
+#include <folly/wangle/concurrent/Codel.h>
+#include <gtest/gtest.h>
+#include <thread>
+
+TEST(CodelTest, Basic) {
+  using std::chrono::milliseconds;
+  folly::wangle::Codel c;
+  std::this_thread::sleep_for(milliseconds(110));
+  // This interval is overloaded
+  EXPECT_FALSE(c.overloaded(milliseconds(100)));
+  std::this_thread::sleep_for(milliseconds(90));
+  // At least two requests must happen in an interval before they will fail
+  EXPECT_FALSE(c.overloaded(milliseconds(50)));
+  EXPECT_TRUE(c.overloaded(milliseconds(50)));
+  std::this_thread::sleep_for(milliseconds(110));
+  // Previous interval is overloaded, but 2ms isn't enough to fail
+  EXPECT_FALSE(c.overloaded(milliseconds(2)));
+  std::this_thread::sleep_for(milliseconds(90));
+  // 20 ms > target interval * 2
+  EXPECT_TRUE(c.overloaded(milliseconds(20)));
+}
diff --git a/folly/wangle/concurrent/test/GlobalExecutorTest.cpp b/folly/wangle/concurrent/test/GlobalExecutorTest.cpp
new file mode 100644
index 0000000..6fedebb
--- /dev/null
+++ b/folly/wangle/concurrent/test/GlobalExecutorTest.cpp
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+#include <folly/wangle/concurrent/GlobalExecutor.h>
+#include <folly/wangle/concurrent/IOExecutor.h>
+
+using namespace folly::wangle;
+
+TEST(GlobalExecutorTest, GlobalCPUExecutor) {
+  class DummyExecutor : public folly::Executor {
+   public:
+    void add(folly::Func f) override {
+      f();
+      count++;
+    }
+    int count{0};
+  };
+
+  // The default CPU executor is a synchronous inline executor, lets verify
+  // that work we add is executed
+  auto count = 0;
+  auto f = [&](){ count++; };
+
+  // Don't explode, we should create the default global CPUExecutor lazily here.
+  getCPUExecutor()->add(f);
+  EXPECT_EQ(1, count);
+
+  {
+    auto dummy = std::make_shared<DummyExecutor>();
+    setCPUExecutor(dummy);
+    getCPUExecutor()->add(f);
+    // Make sure we were properly installed.
+    EXPECT_EQ(1, dummy->count);
+    EXPECT_EQ(2, count);
+  }
+
+  // Don't explode, we should restore the default global CPUExecutor because our
+  // weak reference to dummy has expired
+  getCPUExecutor()->add(f);
+  EXPECT_EQ(3, count);
+}
+
+TEST(GlobalExecutorTest, GlobalIOExecutor) {
+  class DummyExecutor : public IOExecutor {
+   public:
+    void add(folly::Func f) override {
+      count++;
+    }
+    folly::EventBase* getEventBase() override {
+      return nullptr;
+    }
+    int count{0};
+  };
+
+  auto f = [](){};
+
+  // Don't explode, we should create the default global IOExecutor lazily here.
+  getIOExecutor()->add(f);
+
+  {
+    auto dummy = std::make_shared<DummyExecutor>();
+    setIOExecutor(dummy);
+    getIOExecutor()->add(f);
+    // Make sure we were properly installed.
+    EXPECT_EQ(1, dummy->count);
+  }
+
+  // Don't explode, we should restore the default global IOExecutor because our
+  // weak reference to dummy has expired
+  getIOExecutor()->add(f);
+}
diff --git a/folly/wangle/concurrent/test/ThreadPoolExecutorTest.cpp b/folly/wangle/concurrent/test/ThreadPoolExecutorTest.cpp
new file mode 100644
index 0000000..8a6fcc0
--- /dev/null
+++ b/folly/wangle/concurrent/test/ThreadPoolExecutorTest.cpp
@@ -0,0 +1,395 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <folly/wangle/concurrent/FutureExecutor.h>
+#include <folly/wangle/concurrent/ThreadPoolExecutor.h>
+#include <folly/wangle/concurrent/CPUThreadPoolExecutor.h>
+#include <folly/wangle/concurrent/IOThreadPoolExecutor.h>
+#include <glog/logging.h>
+#include <gtest/gtest.h>
+
+using namespace folly;
+using namespace folly::wangle;
+using namespace std::chrono;
+
+static folly::Func burnMs(uint64_t ms) {
+  return [ms]() { std::this_thread::sleep_for(milliseconds(ms)); };
+}
+
+template <class TPE>
+static void basic() {
+  // Create and destroy
+  TPE tpe(10);
+}
+
+TEST(ThreadPoolExecutorTest, CPUBasic) {
+  basic<CPUThreadPoolExecutor>();
+}
+
+TEST(IOThreadPoolExecutorTest, IOBasic) {
+  basic<IOThreadPoolExecutor>();
+}
+
+template <class TPE>
+static void resize() {
+  TPE tpe(100);
+  EXPECT_EQ(100, tpe.numThreads());
+  tpe.setNumThreads(50);
+  EXPECT_EQ(50, tpe.numThreads());
+  tpe.setNumThreads(150);
+  EXPECT_EQ(150, tpe.numThreads());
+}
+
+TEST(ThreadPoolExecutorTest, CPUResize) {
+  resize<CPUThreadPoolExecutor>();
+}
+
+TEST(ThreadPoolExecutorTest, IOResize) {
+  resize<IOThreadPoolExecutor>();
+}
+
+template <class TPE>
+static void stop() {
+  TPE tpe(1);
+  std::atomic<int> completed(0);
+  auto f = [&](){
+    burnMs(10)();
+    completed++;
+  };
+  for (int i = 0; i < 1000; i++) {
+    tpe.add(f);
+  }
+  tpe.stop();
+  EXPECT_GT(1000, completed);
+}
+
+// IOThreadPoolExecutor's stop() behaves like join(). Outstanding tasks belong
+// to the event base, will be executed upon its destruction, and cannot be
+// taken back.
+template <>
+void stop<IOThreadPoolExecutor>() {
+  IOThreadPoolExecutor tpe(1);
+  std::atomic<int> completed(0);
+  auto f = [&](){
+    burnMs(10)();
+    completed++;
+  };
+  for (int i = 0; i < 10; i++) {
+    tpe.add(f);
+  }
+  tpe.stop();
+  EXPECT_EQ(10, completed);
+}
+
+TEST(ThreadPoolExecutorTest, CPUStop) {
+  stop<CPUThreadPoolExecutor>();
+}
+
+TEST(ThreadPoolExecutorTest, IOStop) {
+  stop<IOThreadPoolExecutor>();
+}
+
+template <class TPE>
+static void join() {
+  TPE tpe(10);
+  std::atomic<int> completed(0);
+  auto f = [&](){
+    burnMs(1)();
+    completed++;
+  };
+  for (int i = 0; i < 1000; i++) {
+    tpe.add(f);
+  }
+  tpe.join();
+  EXPECT_EQ(1000, completed);
+}
+
+TEST(ThreadPoolExecutorTest, CPUJoin) {
+  join<CPUThreadPoolExecutor>();
+}
+
+TEST(ThreadPoolExecutorTest, IOJoin) {
+  join<IOThreadPoolExecutor>();
+}
+
+template <class TPE>
+static void resizeUnderLoad() {
+  TPE tpe(10);
+  std::atomic<int> completed(0);
+  auto f = [&](){
+    burnMs(1)();
+    completed++;
+  };
+  for (int i = 0; i < 1000; i++) {
+    tpe.add(f);
+  }
+  tpe.setNumThreads(5);
+  tpe.setNumThreads(15);
+  tpe.join();
+  EXPECT_EQ(1000, completed);
+}
+
+TEST(ThreadPoolExecutorTest, CPUResizeUnderLoad) {
+  resizeUnderLoad<CPUThreadPoolExecutor>();
+}
+
+TEST(ThreadPoolExecutorTest, IOResizeUnderLoad) {
+  resizeUnderLoad<IOThreadPoolExecutor>();
+}
+
+template <class TPE>
+static void poolStats() {
+  folly::Baton<> startBaton, endBaton;
+  TPE tpe(1);
+  auto stats = tpe.getPoolStats();
+  EXPECT_EQ(1, stats.threadCount);
+  EXPECT_EQ(1, stats.idleThreadCount);
+  EXPECT_EQ(0, stats.activeThreadCount);
+  EXPECT_EQ(0, stats.pendingTaskCount);
+  EXPECT_EQ(0, stats.totalTaskCount);
+  tpe.add([&](){ startBaton.post(); endBaton.wait(); });
+  tpe.add([&](){});
+  startBaton.wait();
+  stats = tpe.getPoolStats();
+  EXPECT_EQ(1, stats.threadCount);
+  EXPECT_EQ(0, stats.idleThreadCount);
+  EXPECT_EQ(1, stats.activeThreadCount);
+  EXPECT_EQ(1, stats.pendingTaskCount);
+  EXPECT_EQ(2, stats.totalTaskCount);
+  endBaton.post();
+}
+
+TEST(ThreadPoolExecutorTest, CPUPoolStats) {
+  poolStats<CPUThreadPoolExecutor>();
+}
+
+TEST(ThreadPoolExecutorTest, IOPoolStats) {
+  poolStats<IOThreadPoolExecutor>();
+}
+
+template <class TPE>
+static void taskStats() {
+  TPE tpe(1);
+  std::atomic<int> c(0);
+  auto s = tpe.subscribeToTaskStats(
+      Observer<ThreadPoolExecutor::TaskStats>::create(
+          [&](ThreadPoolExecutor::TaskStats stats) {
+        int i = c++;
+        EXPECT_LT(milliseconds(0), stats.runTime);
+        if (i == 1) {
+          EXPECT_LT(milliseconds(0), stats.waitTime);
+        }
+      }));
+  tpe.add(burnMs(10));
+  tpe.add(burnMs(10));
+  tpe.join();
+  EXPECT_EQ(2, c);
+}
+
+TEST(ThreadPoolExecutorTest, CPUTaskStats) {
+  taskStats<CPUThreadPoolExecutor>();
+}
+
+TEST(ThreadPoolExecutorTest, IOTaskStats) {
+  taskStats<IOThreadPoolExecutor>();
+}
+
+template <class TPE>
+static void expiration() {
+  TPE tpe(1);
+  std::atomic<int> statCbCount(0);
+  auto s = tpe.subscribeToTaskStats(
+      Observer<ThreadPoolExecutor::TaskStats>::create(
+          [&](ThreadPoolExecutor::TaskStats stats) {
+        int i = statCbCount++;
+        if (i == 0) {
+          EXPECT_FALSE(stats.expired);
+        } else if (i == 1) {
+          EXPECT_TRUE(stats.expired);
+        } else {
+          FAIL();
+        }
+      }));
+  std::atomic<int> expireCbCount(0);
+  auto expireCb = [&] () { expireCbCount++; };
+  tpe.add(burnMs(10), seconds(60), expireCb);
+  tpe.add(burnMs(10), milliseconds(10), expireCb);
+  tpe.join();
+  EXPECT_EQ(2, statCbCount);
+  EXPECT_EQ(1, expireCbCount);
+}
+
+TEST(ThreadPoolExecutorTest, CPUExpiration) {
+  expiration<CPUThreadPoolExecutor>();
+}
+
+TEST(ThreadPoolExecutorTest, IOExpiration) {
+  expiration<IOThreadPoolExecutor>();
+}
+
+template <typename TPE>
+static void futureExecutor() {
+  FutureExecutor<TPE> fe(2);
+  std::atomic<int> c{0};
+  fe.addFuture([] () { return makeFuture<int>(42); }).then(
+    [&] (Try<int>&& t) {
+      c++;
+      EXPECT_EQ(42, t.value());
+    });
+  fe.addFuture([] () { return 100; }).then(
+    [&] (Try<int>&& t) {
+      c++;
+      EXPECT_EQ(100, t.value());
+    });
+  fe.addFuture([] () { return makeFuture(); }).then(
+    [&] (Try<void>&& t) {
+      c++;
+      EXPECT_NO_THROW(t.value());
+    });
+  fe.addFuture([] () { return; }).then(
+    [&] (Try<void>&& t) {
+      c++;
+      EXPECT_NO_THROW(t.value());
+    });
+  fe.addFuture([] () { throw std::runtime_error("oops"); }).then(
+    [&] (Try<void>&& t) {
+      c++;
+      EXPECT_THROW(t.value(), std::runtime_error);
+    });
+  // Test doing actual async work
+  folly::Baton<> baton;
+  fe.addFuture([&] () {
+    auto p = std::make_shared<Promise<int>>();
+    std::thread t([p](){
+      burnMs(10)();
+      p->setValue(42);
+    });
+    t.detach();
+    return p->getFuture();
+  }).then([&] (Try<int>&& t) {
+    EXPECT_EQ(42, t.value());
+    c++;
+    baton.post();
+  });
+  baton.wait();
+  fe.join();
+  EXPECT_EQ(6, c);
+}
+
+TEST(ThreadPoolExecutorTest, CPUFuturePool) {
+  futureExecutor<CPUThreadPoolExecutor>();
+}
+
+TEST(ThreadPoolExecutorTest, IOFuturePool) {
+  futureExecutor<IOThreadPoolExecutor>();
+}
+
+TEST(ThreadPoolExecutorTest, PriorityPreemptionTest) {
+  bool tookLopri = false;
+  auto completed = 0;
+  auto hipri = [&] {
+    EXPECT_FALSE(tookLopri);
+    completed++;
+  };
+  auto lopri = [&] {
+    tookLopri = true;
+    completed++;
+  };
+  CPUThreadPoolExecutor pool(0, 2);
+  for (int i = 0; i < 50; i++) {
+    pool.addWithPriority(lopri, Executor::LO_PRI);
+  }
+  for (int i = 0; i < 50; i++) {
+    pool.addWithPriority(hipri, Executor::HI_PRI);
+  }
+  pool.setNumThreads(1);
+  pool.join();
+  EXPECT_EQ(100, completed);
+}
+
+class TestObserver : public ThreadPoolExecutor::Observer {
+ public:
+  void threadStarted(ThreadPoolExecutor::ThreadHandle*) {
+    threads_++;
+  }
+  void threadStopped(ThreadPoolExecutor::ThreadHandle*) {
+    threads_--;
+  }
+  void threadPreviouslyStarted(ThreadPoolExecutor::ThreadHandle*) {
+    threads_++;
+  }
+  void threadNotYetStopped(ThreadPoolExecutor::ThreadHandle*) {
+    threads_--;
+  }
+  void checkCalls() {
+    ASSERT_EQ(threads_, 0);
+  }
+ private:
+  std::atomic<int> threads_{0};
+};
+
+TEST(ThreadPoolExecutorTest, IOObserver) {
+  auto observer = std::make_shared<TestObserver>();
+
+  {
+    IOThreadPoolExecutor exe(10);
+    exe.addObserver(observer);
+    exe.setNumThreads(3);
+    exe.setNumThreads(0);
+    exe.setNumThreads(7);
+    exe.removeObserver(observer);
+    exe.setNumThreads(10);
+  }
+
+  observer->checkCalls();
+}
+
+TEST(ThreadPoolExecutorTest, CPUObserver) {
+  auto observer = std::make_shared<TestObserver>();
+
+  {
+    CPUThreadPoolExecutor exe(10);
+    exe.addObserver(observer);
+    exe.setNumThreads(3);
+    exe.setNumThreads(0);
+    exe.setNumThreads(7);
+    exe.removeObserver(observer);
+    exe.setNumThreads(10);
+  }
+
+  observer->checkCalls();
+}
+
+TEST(ThreadPoolExecutorTest, AddWithPriority) {
+  std::atomic_int c{0};
+  auto f = [&]{ c++; };
+
+  // IO exe doesn't support priorities
+  IOThreadPoolExecutor ioExe(10);
+  EXPECT_THROW(ioExe.addWithPriority(f, 0), std::runtime_error);
+
+  CPUThreadPoolExecutor cpuExe(10, 3);
+  cpuExe.addWithPriority(f, -1);
+  cpuExe.addWithPriority(f, 0);
+  cpuExe.addWithPriority(f, 1);
+  cpuExe.addWithPriority(f, -2); // will add at the lowest priority
+  cpuExe.addWithPriority(f, 2);  // will add at the highest priority
+  cpuExe.addWithPriority(f, Executor::LO_PRI);
+  cpuExe.addWithPriority(f, Executor::HI_PRI);
+  cpuExe.join();
+
+  EXPECT_EQ(7, c);
+}
diff --git a/folly/wangle/rx/Dummy.cpp b/folly/wangle/rx/Dummy.cpp
new file mode 100644
index 0000000..ec999ca
--- /dev/null
+++ b/folly/wangle/rx/Dummy.cpp
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// fbbuild is too dumb to know that .h files in the directory affect
+// our project, unless we have a .cpp file in the target, in the same
+// directory.
diff --git a/folly/wangle/rx/test/RxBenchmark.cpp b/folly/wangle/rx/test/RxBenchmark.cpp
new file mode 100644
index 0000000..4e17494
--- /dev/null
+++ b/folly/wangle/rx/test/RxBenchmark.cpp
@@ -0,0 +1,155 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <folly/Benchmark.h>
+#include <folly/wangle/rx/Observer.h>
+#include <folly/wangle/rx/Subject.h>
+#include <gflags/gflags.h>
+
+using namespace folly::wangle;
+using folly::BenchmarkSuspender;
+
+static std::unique_ptr<Observer<int>> makeObserver() {
+  return Observer<int>::create([&] (int x) {});
+}
+
+void subscribeImpl(uint iters, int N, bool countUnsubscribe) {
+  for (uint iter = 0; iter < iters; iter++) {
+    BenchmarkSuspender bs;
+    Subject<int> subject;
+    std::vector<std::unique_ptr<Observer<int>>> observers;
+    std::vector<Subscription<int>> subscriptions;
+    subscriptions.reserve(N);
+    for (int i = 0; i < N; i++) {
+      observers.push_back(makeObserver());
+    }
+    bs.dismiss();
+    for (int i = 0; i < N; i++) {
+      subscriptions.push_back(subject.subscribe(std::move(observers[i])));
+    }
+    if (countUnsubscribe) {
+      subscriptions.clear();
+    }
+    bs.rehire();
+  }
+}
+
+void subscribeAndUnsubscribe(uint iters, int N) {
+  subscribeImpl(iters, N, true);
+}
+
+void subscribe(uint iters, int N) {
+  subscribeImpl(iters, N, false);
+}
+
+void observe(uint iters, int N) {
+  for (uint iter = 0; iter < iters; iter++) {
+    BenchmarkSuspender bs;
+    Subject<int> subject;
+    std::vector<std::unique_ptr<Observer<int>>> observers;
+    for (int i = 0; i < N; i++) {
+      observers.push_back(makeObserver());
+    }
+    bs.dismiss();
+    for (int i = 0; i < N; i++) {
+      subject.observe(std::move(observers[i]));
+    }
+    bs.rehire();
+  }
+}
+
+void inlineObserve(uint iters, int N) {
+  for (uint iter = 0; iter < iters; iter++) {
+    BenchmarkSuspender bs;
+    Subject<int> subject;
+    std::vector<Observer<int>*> observers;
+    for (int i = 0; i < N; i++) {
+      observers.push_back(makeObserver().release());
+    }
+    bs.dismiss();
+    for (int i = 0; i < N; i++) {
+      subject.observe(observers[i]);
+    }
+    bs.rehire();
+    for (int i = 0; i < N; i++) {
+      delete observers[i];
+    }
+  }
+}
+
+void notifySubscribers(uint iters, int N) {
+  for (uint iter = 0; iter < iters; iter++) {
+    BenchmarkSuspender bs;
+    Subject<int> subject;
+    std::vector<std::unique_ptr<Observer<int>>> observers;
+    std::vector<Subscription<int>> subscriptions;
+    subscriptions.reserve(N);
+    for (int i = 0; i < N; i++) {
+      observers.push_back(makeObserver());
+    }
+    for (int i = 0; i < N; i++) {
+      subscriptions.push_back(subject.subscribe(std::move(observers[i])));
+    }
+    bs.dismiss();
+    subject.onNext(42);
+    bs.rehire();
+  }
+}
+
+void notifyInlineObservers(uint iters, int N) {
+  for (uint iter = 0; iter < iters; iter++) {
+    BenchmarkSuspender bs;
+    Subject<int> subject;
+    std::vector<Observer<int>*> observers;
+    for (int i = 0; i < N; i++) {
+      observers.push_back(makeObserver().release());
+    }
+    for (int i = 0; i < N; i++) {
+      subject.observe(observers[i]);
+    }
+    bs.dismiss();
+    subject.onNext(42);
+    bs.rehire();
+  }
+}
+
+BENCHMARK_PARAM(subscribeAndUnsubscribe, 1);
+BENCHMARK_RELATIVE_PARAM(subscribe, 1);
+BENCHMARK_RELATIVE_PARAM(observe, 1);
+BENCHMARK_RELATIVE_PARAM(inlineObserve, 1);
+
+BENCHMARK_DRAW_LINE();
+
+BENCHMARK_PARAM(subscribeAndUnsubscribe, 1000);
+BENCHMARK_RELATIVE_PARAM(subscribe, 1000);
+BENCHMARK_RELATIVE_PARAM(observe, 1000);
+BENCHMARK_RELATIVE_PARAM(inlineObserve, 1000);
+
+BENCHMARK_DRAW_LINE();
+
+BENCHMARK_PARAM(notifySubscribers, 1);
+BENCHMARK_RELATIVE_PARAM(notifyInlineObservers, 1);
+
+BENCHMARK_DRAW_LINE();
+
+BENCHMARK_PARAM(notifySubscribers, 1000);
+BENCHMARK_RELATIVE_PARAM(notifyInlineObservers, 1000);
+
+int main(int argc, char** argv) {
+  gflags::ParseCommandLineFlags(&argc, &argv, true);
+  folly::runBenchmarks();
+  return 0;
+}
diff --git a/folly/wangle/rx/test/RxTest.cpp b/folly/wangle/rx/test/RxTest.cpp
new file mode 100644
index 0000000..012a8c2
--- /dev/null
+++ b/folly/wangle/rx/test/RxTest.cpp
@@ -0,0 +1,195 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <folly/wangle/rx/Observer.h>
+#include <folly/wangle/rx/Subject.h>
+#include <gtest/gtest.h>
+
+using namespace folly::wangle;
+
+static std::unique_ptr<Observer<int>> incrementer(int& counter) {
+  return Observer<int>::create([&] (int x) {
+    counter++;
+  });
+}
+
+TEST(RxTest, Observe) {
+  Subject<int> subject;
+  auto count = 0;
+  subject.observe(incrementer(count));
+  subject.onNext(1);
+  EXPECT_EQ(1, count);
+}
+
+TEST(RxTest, ObserveInline) {
+  Subject<int> subject;
+  auto count = 0;
+  auto o = incrementer(count).release();
+  subject.observe(o);
+  subject.onNext(1);
+  EXPECT_EQ(1, count);
+  delete o;
+}
+
+TEST(RxTest, Subscription) {
+  Subject<int> subject;
+  auto count = 0;
+  {
+    auto s = subject.subscribe(incrementer(count));
+    subject.onNext(1);
+  }
+  // The subscription has gone out of scope so no one should get this.
+  subject.onNext(2);
+  EXPECT_EQ(1, count);
+}
+
+TEST(RxTest, SubscriptionMove) {
+  Subject<int> subject;
+  auto count = 0;
+  auto s = subject.subscribe(incrementer(count));
+  auto s2 = subject.subscribe(incrementer(count));
+  s2 = std::move(s);
+  subject.onNext(1);
+  Subscription<int> s3(std::move(s2));
+  subject.onNext(2);
+  EXPECT_EQ(2, count);
+}
+
+TEST(RxTest, SubscriptionOutlivesSubject) {
+  Subscription<int> s;
+  {
+    Subject<int> subject;
+    s = subject.subscribe(Observer<int>::create([](int){}));
+  }
+  // Don't explode when s is destroyed
+}
+
+TEST(RxTest, SubscribeDuringCallback) {
+  // A subscriber who was subscribed in the course of a callback should get
+  // subsequent updates but not the current update.
+  Subject<int> subject;
+  int outerCount = 0, innerCount = 0;
+  Subscription<int> s1, s2;
+  s1 = subject.subscribe(Observer<int>::create([&] (int x) {
+    outerCount++;
+    s2 = subject.subscribe(incrementer(innerCount));
+  }));
+  subject.onNext(42);
+  subject.onNext(0xDEADBEEF);
+  EXPECT_EQ(2, outerCount);
+  EXPECT_EQ(1, innerCount);
+}
+
+TEST(RxTest, ObserveDuringCallback) {
+  Subject<int> subject;
+  int outerCount = 0, innerCount = 0;
+  subject.observe(Observer<int>::create([&] (int x) {
+    outerCount++;
+    subject.observe(incrementer(innerCount));
+  }));
+  subject.onNext(42);
+  subject.onNext(0xDEADBEEF);
+  EXPECT_EQ(2, outerCount);
+  EXPECT_EQ(1, innerCount);
+}
+
+TEST(RxTest, ObserveInlineDuringCallback) {
+  Subject<int> subject;
+  int outerCount = 0, innerCount = 0;
+  auto innerO = incrementer(innerCount).release();
+  auto outerO = Observer<int>::create([&] (int x) {
+    outerCount++;
+    subject.observe(innerO);
+  }).release();
+  subject.observe(outerO);
+  subject.onNext(42);
+  subject.onNext(0xDEADBEEF);
+  EXPECT_EQ(2, outerCount);
+  EXPECT_EQ(1, innerCount);
+  delete innerO;
+  delete outerO;
+}
+
+TEST(RxTest, UnsubscribeDuringCallback) {
+  // A subscriber who was unsubscribed in the course of a callback should get
+  // the current update but not subsequent ones
+  Subject<int> subject;
+  int count1 = 0, count2 = 0;
+  auto s1 = subject.subscribe(incrementer(count1));
+  auto s2 = subject.subscribe(Observer<int>::create([&] (int x) {
+    count2++;
+    s1.~Subscription();
+  }));
+  subject.onNext(1);
+  subject.onNext(2);
+  EXPECT_EQ(1, count1);
+  EXPECT_EQ(2, count2);
+}
+
+TEST(RxTest, SubscribeUnsubscribeDuringCallback) {
+  // A subscriber who was subscribed and unsubscribed in the course of a
+  // callback should not get any updates
+  Subject<int> subject;
+  int outerCount = 0, innerCount = 0;
+  auto s2 = subject.subscribe(Observer<int>::create([&] (int x) {
+    outerCount++;
+    auto s2 = subject.subscribe(incrementer(innerCount));
+  }));
+  subject.onNext(1);
+  subject.onNext(2);
+  EXPECT_EQ(2, outerCount);
+  EXPECT_EQ(0, innerCount);
+}
+
+// Move only type
+typedef std::unique_ptr<int> MO;
+static MO makeMO() { return folly::make_unique<int>(1); }
+template <typename T>
+static ObserverPtr<T> makeMOObserver() {
+  return Observer<T>::create([](const T& mo) {
+    EXPECT_EQ(1, *mo);
+  });
+}
+
+TEST(RxTest, MoveOnlyRvalue) {
+  Subject<MO> subject;
+  auto s1 = subject.subscribe(makeMOObserver<MO>());
+  auto s2 = subject.subscribe(makeMOObserver<MO>());
+  auto mo = makeMO();
+  // Can't bind lvalues to rvalue references
+  // subject.onNext(mo);
+  subject.onNext(std::move(mo));
+  subject.onNext(makeMO());
+}
+
+// Copy only type
+struct CO {
+  CO() = default;
+  CO(const CO&) = default;
+  CO(CO&&) = delete;
+};
+
+template <typename T>
+static ObserverPtr<T> makeCOObserver() {
+  return Observer<T>::create([](const T& mo) {});
+}
+
+TEST(RxTest, CopyOnly) {
+  Subject<CO> subject;
+  auto s1 = subject.subscribe(makeCOObserver<CO>());
+  CO co;
+  subject.onNext(co);
+}
diff --git a/folly/wangle/service/ServiceTest.cpp b/folly/wangle/service/ServiceTest.cpp
new file mode 100644
index 0000000..4bf37df
--- /dev/null
+++ b/folly/wangle/service/ServiceTest.cpp
@@ -0,0 +1,258 @@
+/*
+ * Copyright 2015 Facebook, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <gtest/gtest.h>
+
+#include <folly/wangle/codec/StringCodec.h>
+#include <folly/wangle/codec/ByteToMessageCodec.h>
+#include <folly/wangle/service/ClientDispatcher.h>
+#include <folly/wangle/service/ServerDispatcher.h>
+#include <folly/wangle/service/Service.h>
+
+namespace folly {
+
+using namespace wangle;
+
+typedef Pipeline<IOBufQueue&, std::string> ServicePipeline;
+
+class SimpleDecode : public ByteToMessageCodec {
+ public:
+  virtual std::unique_ptr<IOBuf> decode(
+    Context* ctx, IOBufQueue& buf, size_t&) {
+    return buf.move();
+  }
+};
+
+class EchoService : public Service<std::string, std::string> {
+ public:
+  virtual Future<std::string> operator()(std::string req) override {
+    return req;
+  }
+};
+
+class EchoIntService : public Service<std::string, int> {
+ public:
+  virtual Future<int> operator()(std::string req) override {
+    return folly::to<int>(req);
+  }
+};
+
+template <typename Req, typename Resp>
+class ServerPipelineFactory
+    : public PipelineFactory<ServicePipeline> {
+ public:
+
+  std::unique_ptr<ServicePipeline, folly::DelayedDestruction::Destructor>
+  newPipeline(std::shared_ptr<AsyncSocket> socket) override {
+    std::unique_ptr<ServicePipeline, folly::DelayedDestruction::Destructor> pipeline(
+      new ServicePipeline());
+    pipeline->addBack(AsyncSocketHandler(socket));
+    pipeline->addBack(SimpleDecode());
+    pipeline->addBack(StringCodec());
+    pipeline->addBack(SerialServerDispatcher<Req, Resp>(&service_));
+    pipeline->finalize();
+    return pipeline;
+  }
+
+ private:
+  EchoService service_;
+};
+
+template <typename Req, typename Resp>
+class ClientPipelineFactory : public PipelineFactory<ServicePipeline> {
+ public:
+
+  std::unique_ptr<ServicePipeline, folly::DelayedDestruction::Destructor>
+  newPipeline(std::shared_ptr<AsyncSocket> socket) override {
+    std::unique_ptr<ServicePipeline, folly::DelayedDestruction::Destructor> pipeline(
+      new ServicePipeline());
+    pipeline->addBack(AsyncSocketHandler(socket));
+    pipeline->addBack(SimpleDecode());
+    pipeline->addBack(StringCodec());
+    pipeline->finalize();
+    return pipeline;
+   }
+};
+
+template <typename Pipeline, typename Req, typename Resp>
+class ClientServiceFactory : public ServiceFactory<Pipeline, Req, Resp> {
+ public:
+  class ClientService : public Service<Req, Resp> {
+   public:
+    explicit ClientService(Pipeline* pipeline) {
+      dispatcher_.setPipeline(pipeline);
+    }
+    Future<Resp> operator()(Req request) override {
+      return dispatcher_(std::move(request));
+    }
+   private:
+    SerialClientDispatcher<Pipeline, Req, Resp> dispatcher_;
+  };
+
+  Future<std::shared_ptr<Service<Req, Resp>>> operator() (
+    std::shared_ptr<ClientBootstrap<Pipeline>> client) override {
+    return Future<std::shared_ptr<Service<Req, Resp>>>(
+      std::make_shared<ClientService>(client->getPipeline()));
+  }
+};
+
+TEST(Wangle, ClientServerTest) {
+  int port = 1234;
+  // server
+
+  ServerBootstrap<ServicePipeline> server;
+  server.childPipeline(
+    std::make_shared<ServerPipelineFactory<std::string, std::string>>());
+  server.bind(port);
+
+  // client
+  auto client = std::make_shared<ClientBootstrap<ServicePipeline>>();
+  ClientServiceFactory<ServicePipeline, std::string, std::string> serviceFactory;
+  client->pipelineFactory(
+    std::make_shared<ClientPipelineFactory<std::string, std::string>>());
+  SocketAddress addr("127.0.0.1", port);
+  client->connect(addr);
+  auto service = serviceFactory(client).value();
+  auto rep = (*service)("test");
+
+  rep.then([&](std::string value) {
+    EXPECT_EQ("test", value);
+    EventBaseManager::get()->getEventBase()->terminateLoopSoon();
+
+  });
+  EventBaseManager::get()->getEventBase()->loopForever();
+  server.stop();
+  client.reset();
+}
+
+class AppendFilter : public ServiceFilter<std::string, std::string> {
+ public:
+  explicit AppendFilter(
+    std::shared_ptr<Service<std::string, std::string>> service) :
+      ServiceFilter<std::string, std::string>(service) {}
+
+  virtual Future<std::string> operator()(std::string req) {
+    return (*service_)(req + "\n");
+  }
+};
+
+class IntToStringFilter
+    : public ServiceFilter<int, int, std::string, std::string> {
+ public:
+  explicit IntToStringFilter(
+    std::shared_ptr<Service<std::string, std::string>> service) :
+      ServiceFilter<int, int, std::string, std::string>(service) {}
+
+  virtual Future<int> operator()(int req) {
+    return (*service_)(folly::to<std::string>(req)).then([](std::string resp) {
+      return folly::to<int>(resp);
+    });
+  }
+};
+
+TEST(Wangle, FilterTest) {
+  auto service = std::make_shared<EchoService>();
+  auto filter = std::make_shared<AppendFilter>(service);
+  auto result = (*filter)("test");
+  EXPECT_EQ(result.value(), "test\n");
+}
+
+TEST(Wangle, ComplexFilterTest) {
+  auto service = std::make_shared<EchoService>();
+  auto filter = std::make_shared<IntToStringFilter>(service);
+  auto result = (*filter)(1);
+  EXPECT_EQ(result.value(), 1);
+}
+
+class ChangeTypeFilter
+    : public ServiceFilter<int, std::string, std::string, int> {
+ public:
+  explicit ChangeTypeFilter(
+    std::shared_ptr<Service<std::string, int>> service) :
+      ServiceFilter<int, std::string, std::string, int>(service) {}
+
+  virtual Future<std::string> operator()(int req) {
+    return (*service_)(folly::to<std::string>(req)).then([](int resp) {
+      return folly::to<std::string>(resp);
+    });
+  }
+};
+
+TEST(Wangle, SuperComplexFilterTest) {
+  auto service = std::make_shared<EchoIntService>();
+  auto filter = std::make_shared<ChangeTypeFilter>(service);
+  auto result = (*filter)(1);
+  EXPECT_EQ(result.value(), "1");
+}
+
+template <typename Pipeline, typename Req, typename Resp>
+class ConnectionCountFilter : public ServiceFactoryFilter<Pipeline, Req, Resp> {
+ public:
+  explicit ConnectionCountFilter(
+    std::shared_ptr<ServiceFactory<Pipeline, Req, Resp>> factory)
+      : ServiceFactoryFilter<Pipeline, Req, Resp>(factory) {}
+
+    virtual Future<std::shared_ptr<Service<Req, Resp>>> operator()(
+      std::shared_ptr<ClientBootstrap<Pipeline>> client) {
+      connectionCount++;
+      return (*this->serviceFactory_)(client);
+    }
+
+  int connectionCount{0};
+};
+
+TEST(Wangle, ServiceFactoryFilter) {
+  auto clientFactory =
+    std::make_shared<
+    ClientServiceFactory<ServicePipeline, std::string, std::string>>();
+  auto countingFactory =
+    std::make_shared<
+    ConnectionCountFilter<ServicePipeline, std::string, std::string>>(
+      clientFactory);
+
+  auto client = std::make_shared<ClientBootstrap<ServicePipeline>>();
+
+  client->pipelineFactory(
+    std::make_shared<ClientPipelineFactory<std::string, std::string>>());
+  // It doesn't matter if connect succeds or not, but it needs to be called
+  // to create a pipeline
+  client->connect(folly::SocketAddress("::1", 8090));
+
+  auto service = (*countingFactory)(client).value();
+
+  // After the first service goes away, the client can be reused
+  service = (*countingFactory)(client).value();
+  EXPECT_EQ(2, countingFactory->connectionCount);
+}
+
+TEST(Wangle, FactoryToService) {
+  auto constfactory =
+    std::make_shared<ConstFactory<ServicePipeline, std::string, std::string>>(
+    std::make_shared<EchoService>());
+  FactoryToService<ServicePipeline, std::string, std::string> service(
+    constfactory);
+
+  EXPECT_EQ("test", service("test").value());
+}
+
+int main(int argc, char** argv) {
+  testing::InitGoogleTest(&argc, argv);
+  google::InitGoogleLogging(argv[0]);
+  gflags::ParseCommandLineFlags(&argc, &argv, true);
+
+  return RUN_ALL_TESTS();
+}
+
+} // namespace
diff --git a/folly/wangle/ssl/PasswordInFile.cpp b/folly/wangle/ssl/PasswordInFile.cpp
new file mode 100644
index 0000000..3c1c413
--- /dev/null
+++ b/folly/wangle/ssl/PasswordInFile.cpp
@@ -0,0 +1,31 @@
+/*
+ *  Copyright (c) 2015, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+#include <folly/wangle/ssl/PasswordInFile.h>
+
+#include <folly/FileUtil.h>
+
+using namespace std;
+
+namespace folly {
+
+PasswordInFile::PasswordInFile(const string& file)
+    : fileName_(file) {
+  folly::readFile(file.c_str(), password_);
+  auto p = password_.find('\0');
+  if (p != std::string::npos) {
+    password_.erase(p);
+  }
+}
+
+PasswordInFile::~PasswordInFile() {
+  OPENSSL_cleanse((char *)password_.data(), password_.length());
+}
+
+}
diff --git a/folly/wangle/ssl/SSLContextManager.cpp b/folly/wangle/ssl/SSLContextManager.cpp
new file mode 100644
index 0000000..101dde7
--- /dev/null
+++ b/folly/wangle/ssl/SSLContextManager.cpp
@@ -0,0 +1,651 @@
+/*
+ *  Copyright (c) 2015, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+#include <folly/wangle/ssl/SSLContextManager.h>
+
+#include <folly/wangle/ssl/ClientHelloExtStats.h>
+#include <folly/wangle/ssl/DHParam.h>
+#include <folly/wangle/ssl/PasswordInFile.h>
+#include <folly/wangle/ssl/SSLCacheOptions.h>
+#include <folly/wangle/ssl/SSLSessionCacheManager.h>
+#include <folly/wangle/ssl/SSLUtil.h>
+#include <folly/wangle/ssl/TLSTicketKeyManager.h>
+#include <folly/wangle/ssl/TLSTicketKeySeeds.h>
+
+#include <folly/Conv.h>
+#include <folly/ScopeGuard.h>
+#include <folly/String.h>
+#include <functional>
+#include <openssl/asn1.h>
+#include <openssl/ssl.h>
+#include <string>
+#include <folly/io/async/EventBase.h>
+
+#define OPENSSL_MISSING_FEATURE(name) \
+do { \
+  throw std::runtime_error("missing " #name " support in openssl");  \
+} while(0)
+
+
+using std::string;
+using std::shared_ptr;
+
+/**
+ * SSLContextManager helps to create and manage all SSL_CTX,
+ * SSLSessionCacheManager and TLSTicketManager for a listening
+ * VIP:PORT. (Note, in SNI, a listening VIP:PORT can have >1 SSL_CTX(s)).
+ *
+ * Other responsibilities:
+ * 1. It also handles the SSL_CTX selection after getting the tlsext_hostname
+ *    in the client hello message.
+ *
+ * Usage:
+ * 1. Each listening VIP:PORT serving SSL should have one SSLContextManager.
+ *    It maps to Acceptor in the wangle vocabulary.
+ *
+ * 2. Create a SSLContextConfig object (e.g. by parsing the JSON config).
+ *
+ * 3. Call SSLContextManager::addSSLContextConfig() which will
+ *    then create and configure the SSL_CTX
+ *
+ * Note: Each Acceptor, with SSL support, should have one SSLContextManager to
+ * manage all SSL_CTX for the VIP:PORT.
+ */
+
+namespace folly {
+
+namespace {
+
+X509* getX509(SSL_CTX* ctx) {
+  SSL* ssl = SSL_new(ctx);
+  SSL_set_connect_state(ssl);
+  X509* x509 = SSL_get_certificate(ssl);
+  CRYPTO_add(&x509->references, 1, CRYPTO_LOCK_X509);
+  SSL_free(ssl);
+  return x509;
+}
+
+void set_key_from_curve(SSL_CTX* ctx, const std::string& curveName) {
+#if OPENSSL_VERSION_NUMBER >= 0x0090800fL
+#ifndef OPENSSL_NO_ECDH
+  EC_KEY* ecdh = nullptr;
+  int nid;
+
+  /*
+   * Elliptic-Curve Diffie-Hellman parameters are either "named curves"
+   * from RFC 4492 section 5.1.1, or explicitly described curves over
+   * binary fields. OpenSSL only supports the "named curves", which provide
+   * maximum interoperability.
+   */
+
+  nid = OBJ_sn2nid(curveName.c_str());
+  if (nid == 0) {
+    LOG(FATAL) << "Unknown curve name:" << curveName.c_str();
+    return;
+  }
+  ecdh = EC_KEY_new_by_curve_name(nid);
+  if (ecdh == nullptr) {
+    LOG(FATAL) << "Unable to create curve:" << curveName.c_str();
+    return;
+  }
+
+  SSL_CTX_set_tmp_ecdh(ctx, ecdh);
+  EC_KEY_free(ecdh);
+#endif
+#endif
+}
+
+// Helper to create TLSTicketKeyManger and aware of the needed openssl
+// version/feature.
+std::unique_ptr<TLSTicketKeyManager> createTicketManagerHelper(
+  std::shared_ptr<folly::SSLContext> ctx,
+  const TLSTicketKeySeeds* ticketSeeds,
+  const SSLContextConfig& ctxConfig,
+  SSLStats* stats) {
+
+  std::unique_ptr<TLSTicketKeyManager> ticketManager;
+#ifdef SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB
+  if (ticketSeeds && ctxConfig.sessionTicketEnabled) {
+    ticketManager = folly::make_unique<TLSTicketKeyManager>(ctx.get(), stats);
+    ticketManager->setTLSTicketKeySeeds(
+      ticketSeeds->oldSeeds,
+      ticketSeeds->currentSeeds,
+      ticketSeeds->newSeeds);
+  } else {
+    ctx->setOptions(SSL_OP_NO_TICKET);
+  }
+#else
+  if (ticketSeeds && ctxConfig.sessionTicketEnabled) {
+    OPENSSL_MISSING_FEATURE(TLSTicket);
+  }
+#endif
+  return ticketManager;
+}
+
+std::string flattenList(const std::list<std::string>& list) {
+  std::string s;
+  bool first = true;
+  for (auto& item : list) {
+    if (first) {
+      first = false;
+    } else {
+      s.append(", ");
+    }
+    s.append(item);
+  }
+  return s;
+}
+
+}
+
+SSLContextManager::~SSLContextManager() {}
+
+SSLContextManager::SSLContextManager(
+  EventBase* eventBase,
+  const std::string& vipName,
+  bool strict,
+  SSLStats* stats) :
+    stats_(stats),
+    eventBase_(eventBase),
+    strict_(strict) {
+}
+
+void SSLContextManager::addSSLContextConfig(
+  const SSLContextConfig& ctxConfig,
+  const SSLCacheOptions& cacheOptions,
+  const TLSTicketKeySeeds* ticketSeeds,
+  const folly::SocketAddress& vipAddress,
+  const std::shared_ptr<SSLCacheProvider>& externalCache) {
+
+  unsigned numCerts = 0;
+  std::string commonName;
+  std::string lastCertPath;
+  std::unique_ptr<std::list<std::string>> subjectAltName;
+  auto sslCtx = std::make_shared<SSLContext>(ctxConfig.sslVersion);
+  for (const auto& cert : ctxConfig.certificates) {
+    try {
+      sslCtx->loadCertificate(cert.certPath.c_str());
+    } catch (const std::exception& ex) {
+      // The exception isn't very useful without the certificate path name,
+      // so throw a new exception that includes the path to the certificate.
+      string msg = folly::to<string>("error loading SSL certificate ",
+                                     cert.certPath, ": ",
+                                     folly::exceptionStr(ex));
+      LOG(ERROR) << msg;
+      throw std::runtime_error(msg);
+    }
+
+    // Verify that the Common Name and (if present) Subject Alternative Names
+    // are the same for all the certs specified for the SSL context.
+    numCerts++;
+    X509* x509 = getX509(sslCtx->getSSLCtx());
+    auto guard = folly::makeGuard([x509] { X509_free(x509); });
+    auto cn = SSLUtil::getCommonName(x509);
+    if (!cn) {
+      throw std::runtime_error(folly::to<string>("Cannot get CN for X509 ",
+                                                 cert.certPath));
+    }
+    auto altName = SSLUtil::getSubjectAltName(x509);
+    VLOG(2) << "cert " << cert.certPath << " CN: " << *cn;
+    if (altName) {
+      altName->sort();
+      VLOG(2) << "cert " << cert.certPath << " SAN: " << flattenList(*altName);
+    } else {
+      VLOG(2) << "cert " << cert.certPath << " SAN: " << "{none}";
+    }
+    if (numCerts == 1) {
+      commonName = *cn;
+      subjectAltName = std::move(altName);
+    } else {
+      if (commonName != *cn) {
+        throw std::runtime_error(folly::to<string>("X509 ", cert.certPath,
+                                          " does not have same CN as ",
+                                          lastCertPath));
+      }
+      if (altName == nullptr) {
+        if (subjectAltName != nullptr) {
+          throw std::runtime_error(folly::to<string>("X509 ", cert.certPath,
+                                            " does not have same SAN as ",
+                                            lastCertPath));
+        }
+      } else {
+        if ((subjectAltName == nullptr) || (*altName != *subjectAltName)) {
+          throw std::runtime_error(folly::to<string>("X509 ", cert.certPath,
+                                            " does not have same SAN as ",
+                                            lastCertPath));
+        }
+      }
+    }
+    lastCertPath = cert.certPath;
+
+    // TODO t4438250 - Add ECDSA support to the crypto_ssl offload server
+    //                 so we can avoid storing the ECDSA private key in the
+    //                 address space of the Internet-facing process.  For
+    //                 now, if cert name includes "-EC" to denote elliptic
+    //                 curve, we load its private key even if the server as
+    //                 a whole has been configured for async crypto.
+    if (ctxConfig.isLocalPrivateKey ||
+        (cert.certPath.find("-EC") != std::string::npos)) {
+      // The private key lives in the same process
+
+      // This needs to be called before loadPrivateKey().
+      if (!cert.passwordPath.empty()) {
+        auto sslPassword = std::make_shared<PasswordInFile>(cert.passwordPath);
+        sslCtx->passwordCollector(sslPassword);
+      }
+
+      try {
+        sslCtx->loadPrivateKey(cert.keyPath.c_str());
+      } catch (const std::exception& ex) {
+        // Throw an error that includes the key path, so the user can tell
+        // which key had a problem.
+        string msg = folly::to<string>("error loading private SSL key ",
+                                       cert.keyPath, ": ",
+                                       folly::exceptionStr(ex));
+        LOG(ERROR) << msg;
+        throw std::runtime_error(msg);
+      }
+    }
+  }
+  if (!ctxConfig.isLocalPrivateKey) {
+    enableAsyncCrypto(sslCtx);
+  }
+
+  // Let the server pick the highest performing cipher from among the client's
+  // choices.
+  //
+  // Let's use a unique private key for all DH key exchanges.
+  //
+  // Because some old implementations choke on empty fragments, most SSL
+  // applications disable them (it's part of SSL_OP_ALL).  This
+  // will improve performance and decrease write buffer fragmentation.
+  sslCtx->setOptions(SSL_OP_CIPHER_SERVER_PREFERENCE |
+    SSL_OP_SINGLE_DH_USE |
+    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
+
+  // Configure SSL ciphers list
+  if (!ctxConfig.tls11Ciphers.empty()) {
+    // FIXME: create a dummy SSL_CTX for cipher testing purpose? It can
+    //        remove the ordering dependency
+
+    // Test to see if the specified TLS1.1 ciphers are valid.  Note that
+    // these will be overwritten by the ciphers() call below.
+    sslCtx->setCiphersOrThrow(ctxConfig.tls11Ciphers);
+  }
+
+  // Important that we do this *after* checking the TLS1.1 ciphers above,
+  // since we test their validity by actually setting them.
+  sslCtx->ciphers(ctxConfig.sslCiphers);
+
+  // Use a fix DH param
+  DH* dh = get_dh2048();
+  SSL_CTX_set_tmp_dh(sslCtx->getSSLCtx(), dh);
+  DH_free(dh);
+
+  const string& curve = ctxConfig.eccCurveName;
+  if (!curve.empty()) {
+    set_key_from_curve(sslCtx->getSSLCtx(), curve);
+  }
+
+  if (!ctxConfig.clientCAFile.empty()) {
+    try {
+      sslCtx->setVerificationOption(SSLContext::VERIFY_REQ_CLIENT_CERT);
+      sslCtx->loadTrustedCertificates(ctxConfig.clientCAFile.c_str());
+      sslCtx->loadClientCAList(ctxConfig.clientCAFile.c_str());
+    } catch (const std::exception& ex) {
+      string msg = folly::to<string>("error loading client CA",
+                                     ctxConfig.clientCAFile, ": ",
+                                     folly::exceptionStr(ex));
+      LOG(ERROR) << msg;
+      throw std::runtime_error(msg);
+    }
+  }
+
+  // - start - SSL session cache config
+  // the internal cache never does what we want (per-thread-per-vip).
+  // Disable it.  SSLSessionCacheManager will set it appropriately.
+  SSL_CTX_set_session_cache_mode(sslCtx->getSSLCtx(), SSL_SESS_CACHE_OFF);
+  SSL_CTX_set_timeout(sslCtx->getSSLCtx(),
+                      cacheOptions.sslCacheTimeout.count());
+  std::unique_ptr<SSLSessionCacheManager> sessionCacheManager;
+  if (ctxConfig.sessionCacheEnabled &&
+      cacheOptions.maxSSLCacheSize > 0 &&
+      cacheOptions.sslCacheFlushSize > 0) {
+    sessionCacheManager =
+      folly::make_unique<SSLSessionCacheManager>(
+        cacheOptions.maxSSLCacheSize,
+        cacheOptions.sslCacheFlushSize,
+        sslCtx.get(),
+        vipAddress,
+        commonName,
+        eventBase_,
+        stats_,
+        externalCache);
+  }
+  // - end - SSL session cache config
+
+  std::unique_ptr<TLSTicketKeyManager> ticketManager =
+    createTicketManagerHelper(sslCtx, ticketSeeds, ctxConfig, stats_);
+
+  // finalize sslCtx setup by the individual features supported by openssl
+  ctxSetupByOpensslFeature(sslCtx, ctxConfig);
+
+  try {
+    insert(sslCtx,
+           std::move(sessionCacheManager),
+           std::move(ticketManager),
+           ctxConfig.isDefault);
+  } catch (const std::exception& ex) {
+    string msg = folly::to<string>("Error adding certificate : ",
+                                   folly::exceptionStr(ex));
+    LOG(ERROR) << msg;
+    throw std::runtime_error(msg);
+  }
+
+}
+
+#ifdef PROXYGEN_HAVE_SERVERNAMECALLBACK
+SSLContext::ServerNameCallbackResult
+SSLContextManager::serverNameCallback(SSL* ssl) {
+  shared_ptr<SSLContext> ctx;
+
+  const char* sn = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
+  if (!sn) {
+    VLOG(6) << "Server Name (tlsext_hostname) is missing";
+    if (clientHelloTLSExtStats_) {
+      clientHelloTLSExtStats_->recordAbsentHostname();
+    }
+    return SSLContext::SERVER_NAME_NOT_FOUND;
+  }
+  size_t snLen = strlen(sn);
+  VLOG(6) << "Server Name (SNI TLS extension): '" << sn << "' ";
+
+  // FIXME: This code breaks the abstraction. Suggestion?
+  AsyncSSLSocket* sslSocket = AsyncSSLSocket::getFromSSL(ssl);
+  CHECK(sslSocket);
+
+  DNString dnstr(sn, snLen);
+
+  uint32_t count = 0;
+  do {
+    // Try exact match first
+    ctx = getSSLCtx(dnstr);
+    if (ctx) {
+      sslSocket->switchServerSSLContext(ctx);
+      if (clientHelloTLSExtStats_) {
+        clientHelloTLSExtStats_->recordMatch();
+      }
+      return SSLContext::SERVER_NAME_FOUND;
+    }
+
+    ctx = getSSLCtxBySuffix(dnstr);
+    if (ctx) {
+      sslSocket->switchServerSSLContext(ctx);
+      if (clientHelloTLSExtStats_) {
+        clientHelloTLSExtStats_->recordMatch();
+      }
+      return SSLContext::SERVER_NAME_FOUND;
+    }
+
+    // Give the noMatchFn one chance to add the correct cert
+  }
+  while (count++ == 0 && noMatchFn_ && noMatchFn_(sn));
+
+  VLOG(6) << folly::stringPrintf("Cannot find a SSL_CTX for \"%s\"", sn);
+
+  if (clientHelloTLSExtStats_) {
+    clientHelloTLSExtStats_->recordNotMatch();
+  }
+  return SSLContext::SERVER_NAME_NOT_FOUND;
+}
+#endif
+
+// Consolidate all SSL_CTX setup which depends on openssl version/feature
+void
+SSLContextManager::ctxSetupByOpensslFeature(
+  shared_ptr<folly::SSLContext> sslCtx,
+  const SSLContextConfig& ctxConfig) {
+  // Disable compression - profiling shows this to be very expensive in
+  // terms of CPU and memory consumption.
+  //
+#ifdef SSL_OP_NO_COMPRESSION
+  sslCtx->setOptions(SSL_OP_NO_COMPRESSION);
+#endif
+
+  // Enable early release of SSL buffers to reduce the memory footprint
+#ifdef SSL_MODE_RELEASE_BUFFERS
+ sslCtx->getSSLCtx()->mode |= SSL_MODE_RELEASE_BUFFERS;
+#endif
+#ifdef SSL_MODE_EARLY_RELEASE_BBIO
+  sslCtx->getSSLCtx()->mode |=  SSL_MODE_EARLY_RELEASE_BBIO;
+#endif
+
+  // This number should (probably) correspond to HTTPSession::kMaxReadSize
+  // For now, this number must also be large enough to accommodate our
+  // largest certificate, because some older clients (IE6/7) require the
+  // cert to be in a single fragment.
+#ifdef SSL_CTRL_SET_MAX_SEND_FRAGMENT
+  SSL_CTX_set_max_send_fragment(sslCtx->getSSLCtx(), 8000);
+#endif
+
+  // Specify cipher(s) to be used for TLS1.1 client
+  if (!ctxConfig.tls11Ciphers.empty()) {
+#ifdef PROXYGEN_HAVE_SERVERNAMECALLBACK
+    // Specified TLS1.1 ciphers are valid
+    sslCtx->addClientHelloCallback(
+      std::bind(
+        &SSLContext::switchCiphersIfTLS11,
+        sslCtx.get(),
+        std::placeholders::_1,
+        ctxConfig.tls11Ciphers
+      )
+    );
+#else
+    OPENSSL_MISSING_FEATURE(SNI);
+#endif
+  }
+
+  // NPN (Next Protocol Negotiation)
+  if (!ctxConfig.nextProtocols.empty()) {
+#ifdef OPENSSL_NPN_NEGOTIATED
+    sslCtx->setRandomizedAdvertisedNextProtocols(ctxConfig.nextProtocols);
+#else
+    OPENSSL_MISSING_FEATURE(NPN);
+#endif
+  }
+
+  // SNI
+#ifdef PROXYGEN_HAVE_SERVERNAMECALLBACK
+  noMatchFn_ = ctxConfig.sniNoMatchFn;
+  if (ctxConfig.isDefault) {
+    if (defaultCtx_) {
+      throw std::runtime_error(">1 X509 is set as default");
+    }
+
+    defaultCtx_ = sslCtx;
+    defaultCtx_->setServerNameCallback(
+      std::bind(&SSLContextManager::serverNameCallback, this,
+                std::placeholders::_1));
+  }
+#else
+  if (ctxs_.size() > 1) {
+    OPENSSL_MISSING_FEATURE(SNI);
+  }
+#endif
+}
+
+void
+SSLContextManager::insert(shared_ptr<SSLContext> sslCtx,
+                          std::unique_ptr<SSLSessionCacheManager> smanager,
+                          std::unique_ptr<TLSTicketKeyManager> tmanager,
+                          bool defaultFallback) {
+  X509* x509 = getX509(sslCtx->getSSLCtx());
+  auto guard = folly::makeGuard([x509] { X509_free(x509); });
+  auto cn = SSLUtil::getCommonName(x509);
+  if (!cn) {
+    throw std::runtime_error("Cannot get CN");
+  }
+
+  /**
+   * Some notes from RFC 2818. Only for future quick references in case of bugs
+   *
+   * RFC 2818 section 3.1:
+   * "......
+   * If a subjectAltName extension of type dNSName is present, that MUST
+   * be used as the identity. Otherwise, the (most specific) Common Name
+   * field in the Subject field of the certificate MUST be used. Although
+   * the use of the Common Name is existing practice, it is deprecated and
+   * Certification Authorities are encouraged to use the dNSName instead.
+   * ......
+   * In some cases, the URI is specified as an IP address rather than a
+   * hostname. In this case, the iPAddress subjectAltName must be present
+   * in the certificate and must exactly match the IP in the URI.
+   * ......"
+   */
+
+  // Not sure if we ever get this kind of X509...
+  // If we do, assume '*' is always in the CN and ignore all subject alternative
+  // names.
+  if (cn->length() == 1 && (*cn)[0] == '*') {
+    if (!defaultFallback) {
+      throw std::runtime_error("STAR X509 is not the default");
+    }
+    ctxs_.emplace_back(sslCtx);
+    sessionCacheManagers_.emplace_back(std::move(smanager));
+    ticketManagers_.emplace_back(std::move(tmanager));
+    return;
+  }
+
+  // Insert by CN
+  insertSSLCtxByDomainName(cn->c_str(), cn->length(), sslCtx);
+
+  // Insert by subject alternative name(s)
+  auto altNames = SSLUtil::getSubjectAltName(x509);
+  if (altNames) {
+    for (auto& name : *altNames) {
+      insertSSLCtxByDomainName(name.c_str(), name.length(), sslCtx);
+    }
+  }
+
+  ctxs_.emplace_back(sslCtx);
+  sessionCacheManagers_.emplace_back(std::move(smanager));
+  ticketManagers_.emplace_back(std::move(tmanager));
+}
+
+void
+SSLContextManager::insertSSLCtxByDomainName(const char* dn, size_t len,
+                                            shared_ptr<SSLContext> sslCtx) {
+  try {
+    insertSSLCtxByDomainNameImpl(dn, len, sslCtx);
+  } catch (const std::runtime_error& ex) {
+    if (strict_) {
+      throw ex;
+    } else {
+      LOG(ERROR) << ex.what() << " DN=" << dn;
+    }
+  }
+}
+void
+SSLContextManager::insertSSLCtxByDomainNameImpl(const char* dn, size_t len,
+                                                shared_ptr<SSLContext> sslCtx)
+{
+  VLOG(4) <<
+    folly::stringPrintf("Adding CN/Subject-alternative-name \"%s\" for "
+                        "SNI search", dn);
+
+  // Only support wildcard domains which are prefixed exactly by "*." .
+  // "*" appearing at other locations is not accepted.
+
+  if (len > 2 && dn[0] == '*') {
+    if (dn[1] == '.') {
+      // skip the first '*'
+      dn++;
+      len--;
+    } else {
+      throw std::runtime_error(
+        "Invalid wildcard CN/subject-alternative-name \"" + std::string(dn) + "\" "
+        "(only allow character \".\" after \"*\"");
+    }
+  }
+
+  if (len == 1 && *dn == '.') {
+    throw std::runtime_error("X509 has only '.' in the CN or subject alternative name "
+                    "(after removing any preceding '*')");
+  }
+
+  if (strchr(dn, '*')) {
+    throw std::runtime_error("X509 has '*' in the the CN or subject alternative name "
+                    "(after removing any preceding '*')");
+  }
+
+  DNString dnstr(dn, len);
+  const auto v = dnMap_.find(dnstr);
+  if (v == dnMap_.end()) {
+    dnMap_.emplace(dnstr, sslCtx);
+  } else if (v->second == sslCtx) {
+    VLOG(6)<< "Duplicate CN or subject alternative name found in the same X509."
+      "  Ignore the later name.";
+  } else {
+    throw std::runtime_error("Duplicate CN or subject alternative name found: \"" +
+                             std::string(dnstr.c_str()) + "\"");
+  }
+}
+
+shared_ptr<SSLContext>
+SSLContextManager::getSSLCtxBySuffix(const DNString& dnstr) const
+{
+  size_t dot;
+
+  if ((dot = dnstr.find_first_of(".")) != DNString::npos) {
+    DNString suffixDNStr(dnstr, dot);
+    const auto v = dnMap_.find(suffixDNStr);
+    if (v != dnMap_.end()) {
+      VLOG(6) << folly::stringPrintf("\"%s\" is a willcard match to \"%s\"",
+                                     dnstr.c_str(), suffixDNStr.c_str());
+      return v->second;
+    }
+  }
+
+  VLOG(6) << folly::stringPrintf("\"%s\" is not a wildcard match",
+                                 dnstr.c_str());
+  return shared_ptr<SSLContext>();
+}
+
+shared_ptr<SSLContext>
+SSLContextManager::getSSLCtx(const DNString& dnstr) const
+{
+  const auto v = dnMap_.find(dnstr);
+  if (v == dnMap_.end()) {
+    VLOG(6) << folly::stringPrintf("\"%s\" is not an exact match",
+                                   dnstr.c_str());
+    return shared_ptr<SSLContext>();
+  } else {
+    VLOG(6) << folly::stringPrintf("\"%s\" is an exact match", dnstr.c_str());
+    return v->second;
+  }
+}
+
+shared_ptr<SSLContext>
+SSLContextManager::getDefaultSSLCtx() const {
+  return defaultCtx_;
+}
+
+void
+SSLContextManager::reloadTLSTicketKeys(
+  const std::vector<std::string>& oldSeeds,
+  const std::vector<std::string>& currentSeeds,
+  const std::vector<std::string>& newSeeds) {
+#ifdef SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB
+  for (auto& tmgr: ticketManagers_) {
+    tmgr->setTLSTicketKeySeeds(oldSeeds, currentSeeds, newSeeds);
+  }
+#endif
+}
+
+} // namespace
diff --git a/folly/wangle/ssl/SSLSessionCacheManager.cpp b/folly/wangle/ssl/SSLSessionCacheManager.cpp
new file mode 100644
index 0000000..2b1f8a4
--- /dev/null
+++ b/folly/wangle/ssl/SSLSessionCacheManager.cpp
@@ -0,0 +1,354 @@
+/*
+ *  Copyright (c) 2015, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+#include <folly/wangle/ssl/SSLSessionCacheManager.h>
+
+#include <folly/wangle/ssl/SSLCacheProvider.h>
+#include <folly/wangle/ssl/SSLStats.h>
+#include <folly/wangle/ssl/SSLUtil.h>
+
+#include <folly/io/async/EventBase.h>
+
+#ifndef NO_LIB_GFLAGS
+#include <gflags/gflags.h>
+#endif
+
+using std::string;
+using std::shared_ptr;
+
+namespace {
+
+const uint32_t NUM_CACHE_BUCKETS = 16;
+
+// We use the default ID generator which fills the maximum ID length
+// for the protocol.  16 bytes for SSLv2 or 32 for SSLv3+
+const int MIN_SESSION_ID_LENGTH = 16;
+
+}
+
+#ifndef NO_LIB_GFLAGS
+DEFINE_bool(dcache_unit_test, false, "All VIPs share one session cache");
+#else
+const bool FLAGS_dcache_unit_test = false;
+#endif
+
+namespace folly {
+
+
+int SSLSessionCacheManager::sExDataIndex_ = -1;
+shared_ptr<ShardedLocalSSLSessionCache> SSLSessionCacheManager::sCache_;
+std::mutex SSLSessionCacheManager::sCacheLock_;
+
+LocalSSLSessionCache::LocalSSLSessionCache(uint32_t maxCacheSize,
+                                           uint32_t cacheCullSize)
+    : sessionCache(maxCacheSize, cacheCullSize) {
+  sessionCache.setPruneHook(std::bind(
+                              &LocalSSLSessionCache::pruneSessionCallback,
+                              this, std::placeholders::_1,
+                              std::placeholders::_2));
+}
+
+void LocalSSLSessionCache::pruneSessionCallback(const string& sessionId,
+                                                SSL_SESSION* session) {
+  VLOG(4) << "Free SSL session from local cache; id="
+          << SSLUtil::hexlify(sessionId);
+  SSL_SESSION_free(session);
+  ++removedSessions_;
+}
+
+
+// SSLSessionCacheManager implementation
+
+SSLSessionCacheManager::SSLSessionCacheManager(
+  uint32_t maxCacheSize,
+  uint32_t cacheCullSize,
+  SSLContext* ctx,
+  const folly::SocketAddress& sockaddr,
+  const string& context,
+  EventBase* eventBase,
+  SSLStats* stats,
+  const std::shared_ptr<SSLCacheProvider>& externalCache):
+    ctx_(ctx),
+    stats_(stats),
+    externalCache_(externalCache) {
+
+  SSL_CTX* sslCtx = ctx->getSSLCtx();
+
+  SSLUtil::getSSLCtxExIndex(&sExDataIndex_);
+
+  SSL_CTX_set_ex_data(sslCtx, sExDataIndex_, this);
+  SSL_CTX_sess_set_new_cb(sslCtx, SSLSessionCacheManager::newSessionCallback);
+  SSL_CTX_sess_set_get_cb(sslCtx, SSLSessionCacheManager::getSessionCallback);
+  SSL_CTX_sess_set_remove_cb(sslCtx,
+                             SSLSessionCacheManager::removeSessionCallback);
+  if (!FLAGS_dcache_unit_test && !context.empty()) {
+    // Use the passed in context
+    SSL_CTX_set_session_id_context(sslCtx, (const uint8_t *)context.data(),
+                                   std::min((int)context.length(),
+                                            SSL_MAX_SSL_SESSION_ID_LENGTH));
+  }
+
+  SSL_CTX_set_session_cache_mode(sslCtx, SSL_SESS_CACHE_NO_INTERNAL
+                                 | SSL_SESS_CACHE_SERVER);
+
+  localCache_ = SSLSessionCacheManager::getLocalCache(maxCacheSize,
+                                                      cacheCullSize);
+
+  VLOG(2) << "On VipID=" << sockaddr.describe() << " context=" << context;
+}
+
+SSLSessionCacheManager::~SSLSessionCacheManager() {
+}
+
+void SSLSessionCacheManager::shutdown() {
+  std::lock_guard<std::mutex> g(sCacheLock_);
+  sCache_.reset();
+}
+
+shared_ptr<ShardedLocalSSLSessionCache> SSLSessionCacheManager::getLocalCache(
+  uint32_t maxCacheSize,
+  uint32_t cacheCullSize) {
+
+  std::lock_guard<std::mutex> g(sCacheLock_);
+  if (!sCache_) {
+    sCache_.reset(new ShardedLocalSSLSessionCache(NUM_CACHE_BUCKETS,
+                                                  maxCacheSize,
+                                                  cacheCullSize));
+  }
+  return sCache_;
+}
+
+int SSLSessionCacheManager::newSessionCallback(SSL* ssl, SSL_SESSION* session) {
+  SSLSessionCacheManager* manager = nullptr;
+  SSL_CTX* ctx = SSL_get_SSL_CTX(ssl);
+  manager = (SSLSessionCacheManager *)SSL_CTX_get_ex_data(ctx, sExDataIndex_);
+
+  if (manager == nullptr) {
+    LOG(FATAL) << "Null SSLSessionCacheManager in callback";
+    return -1;
+  }
+  return manager->newSession(ssl, session);
+}
+
+
+int SSLSessionCacheManager::newSession(SSL* ssl, SSL_SESSION* session) {
+  string sessionId((char*)session->session_id, session->session_id_length);
+  VLOG(4) << "New SSL session; id=" << SSLUtil::hexlify(sessionId);
+
+  if (stats_) {
+    stats_->recordSSLSession(true /* new session */, false, false);
+  }
+
+  localCache_->storeSession(sessionId, session, stats_);
+
+  if (externalCache_) {
+    VLOG(4) << "New SSL session: send session to external cache; id=" <<
+      SSLUtil::hexlify(sessionId);
+    storeCacheRecord(sessionId, session);
+  }
+
+  return 1;
+}
+
+void SSLSessionCacheManager::removeSessionCallback(SSL_CTX* ctx,
+                                                   SSL_SESSION* session) {
+  SSLSessionCacheManager* manager = nullptr;
+  manager = (SSLSessionCacheManager *)SSL_CTX_get_ex_data(ctx, sExDataIndex_);
+
+  if (manager == nullptr) {
+    LOG(FATAL) << "Null SSLSessionCacheManager in callback";
+    return;
+  }
+  return manager->removeSession(ctx, session);
+}
+
+void SSLSessionCacheManager::removeSession(SSL_CTX* ctx,
+                                           SSL_SESSION* session) {
+  string sessionId((char*)session->session_id, session->session_id_length);
+
+  // This hook is only called from SSL when the internal session cache needs to
+  // flush sessions.  Since we run with the internal cache disabled, this should
+  // never be called
+  VLOG(3) << "Remove SSL session; id=" << SSLUtil::hexlify(sessionId);
+
+  localCache_->removeSession(sessionId);
+
+  if (stats_) {
+    stats_->recordSSLSessionRemove();
+  }
+}
+
+SSL_SESSION* SSLSessionCacheManager::getSessionCallback(SSL* ssl,
+                                                        unsigned char* sess_id,
+                                                        int id_len,
+                                                        int* copyflag) {
+  SSLSessionCacheManager* manager = nullptr;
+  SSL_CTX* ctx = SSL_get_SSL_CTX(ssl);
+  manager = (SSLSessionCacheManager *)SSL_CTX_get_ex_data(ctx, sExDataIndex_);
+
+  if (manager == nullptr) {
+    LOG(FATAL) << "Null SSLSessionCacheManager in callback";
+    return nullptr;
+  }
+  return manager->getSession(ssl, sess_id, id_len, copyflag);
+}
+
+SSL_SESSION* SSLSessionCacheManager::getSession(SSL* ssl,
+                                                unsigned char* session_id,
+                                                int id_len,
+                                                int* copyflag) {
+  VLOG(7) << "SSL get session callback";
+  SSL_SESSION* session = nullptr;
+  bool foreign = false;
+  char const* missReason = nullptr;
+
+  if (id_len < MIN_SESSION_ID_LENGTH) {
+    // We didn't generate this session so it's going to be a miss.
+    // This doesn't get logged or counted in the stats.
+    return nullptr;
+  }
+  string sessionId((char*)session_id, id_len);
+
+  AsyncSSLSocket* sslSocket = AsyncSSLSocket::getFromSSL(ssl);
+
+  assert(sslSocket != nullptr);
+
+  // look it up in the local cache first
+  session = localCache_->lookupSession(sessionId);
+#ifdef SSL_SESSION_CB_WOULD_BLOCK
+  if (session == nullptr && externalCache_) {
+    // external cache might have the session
+    foreign = true;
+    if (!SSL_want_sess_cache_lookup(ssl)) {
+      missReason = "reason: No async cache support;";
+    } else {
+      PendingLookupMap::iterator pit = pendingLookups_.find(sessionId);
+      if (pit == pendingLookups_.end()) {
+        auto result = pendingLookups_.emplace(sessionId, PendingLookup());
+        // initiate fetch
+        VLOG(4) << "Get SSL session [Pending]: Initiate Fetch; fd=" <<
+          sslSocket->getFd() << " id=" << SSLUtil::hexlify(sessionId);
+        if (lookupCacheRecord(sessionId, sslSocket)) {
+          // response is pending
+          *copyflag = SSL_SESSION_CB_WOULD_BLOCK;
+          return nullptr;
+        } else {
+          missReason = "reason: failed to send lookup request;";
+          pendingLookups_.erase(result.first);
+        }
+      } else {
+        // A lookup was already initiated from this thread
+        if (pit->second.request_in_progress) {
+          // Someone else initiated the request, attach
+          VLOG(4) << "Get SSL session [Pending]: Request in progess: attach; "
+            "fd=" << sslSocket->getFd() << " id=" <<
+            SSLUtil::hexlify(sessionId);
+          std::unique_ptr<DelayedDestruction::DestructorGuard> dg(
+            new DelayedDestruction::DestructorGuard(sslSocket));
+          pit->second.waiters.push_back(
+            std::make_pair(sslSocket, std::move(dg)));
+          *copyflag = SSL_SESSION_CB_WOULD_BLOCK;
+          return nullptr;
+        }
+        // request is complete
+        session = pit->second.session; // nullptr if our friend didn't have it
+        if (session != nullptr) {
+          CRYPTO_add(&session->references, 1, CRYPTO_LOCK_SSL_SESSION);
+        }
+      }
+    }
+  }
+#endif
+
+  bool hit = (session != nullptr);
+  if (stats_) {
+    stats_->recordSSLSession(false, hit, foreign);
+  }
+  if (hit) {
+    sslSocket->setSessionIDResumed(true);
+  }
+
+  VLOG(4) << "Get SSL session [" <<
+    ((hit) ? "Hit" : "Miss") << "]: " <<
+    ((foreign) ? "external" : "local") << " cache; " <<
+    ((missReason != nullptr) ? missReason : "") << "fd=" <<
+    sslSocket->getFd() << " id=" << SSLUtil::hexlify(sessionId);
+
+  // We already bumped the refcount
+  *copyflag = 0;
+
+  return session;
+}
+
+bool SSLSessionCacheManager::storeCacheRecord(const string& sessionId,
+                                              SSL_SESSION* session) {
+  std::string sessionString;
+  uint32_t sessionLen = i2d_SSL_SESSION(session, nullptr);
+  sessionString.resize(sessionLen);
+  uint8_t* cp = (uint8_t *)sessionString.data();
+  i2d_SSL_SESSION(session, &cp);
+  size_t expiration = SSL_CTX_get_timeout(ctx_->getSSLCtx());
+  return externalCache_->setAsync(sessionId, sessionString,
+                                  std::chrono::seconds(expiration));
+}
+
+bool SSLSessionCacheManager::lookupCacheRecord(const string& sessionId,
+                                               AsyncSSLSocket* sslSocket) {
+  auto cacheCtx = new SSLCacheProvider::CacheContext();
+  cacheCtx->sessionId = sessionId;
+  cacheCtx->session = nullptr;
+  cacheCtx->sslSocket = sslSocket;
+  cacheCtx->guard.reset(
+      new DelayedDestruction::DestructorGuard(cacheCtx->sslSocket));
+  cacheCtx->manager = this;
+  bool res = externalCache_->getAsync(sessionId, cacheCtx);
+  if (!res) {
+    delete cacheCtx;
+  }
+  return res;
+}
+
+void SSLSessionCacheManager::restartSSLAccept(
+    const SSLCacheProvider::CacheContext* cacheCtx) {
+  PendingLookupMap::iterator pit = pendingLookups_.find(cacheCtx->sessionId);
+  CHECK(pit != pendingLookups_.end());
+  pit->second.request_in_progress = false;
+  pit->second.session = cacheCtx->session;
+  VLOG(7) << "Restart SSL accept";
+  cacheCtx->sslSocket->restartSSLAccept();
+  for (const auto& attachedLookup: pit->second.waiters) {
+    // Wake up anyone else who was waiting for this session
+    VLOG(4) << "Restart SSL accept (waiters) for fd=" <<
+      attachedLookup.first->getFd();
+    attachedLookup.first->restartSSLAccept();
+  }
+  pendingLookups_.erase(pit);
+}
+
+void SSLSessionCacheManager::onGetSuccess(
+    SSLCacheProvider::CacheContext* cacheCtx,
+    const std::string& value) {
+  const uint8_t* cp = (uint8_t*)value.data();
+  cacheCtx->session = d2i_SSL_SESSION(nullptr, &cp, value.length());
+  restartSSLAccept(cacheCtx);
+
+  /* Insert in the LRU after restarting all clients.  The stats logic
+   * in getSession would treat this as a local hit otherwise.
+   */
+  localCache_->storeSession(cacheCtx->sessionId, cacheCtx->session, stats_);
+  delete cacheCtx;
+}
+
+void SSLSessionCacheManager::onGetFailure(
+    SSLCacheProvider::CacheContext* cacheCtx) {
+  restartSSLAccept(cacheCtx);
+  delete cacheCtx;
+}
+
+} // namespace
diff --git a/folly/wangle/ssl/SSLUtil.cpp b/folly/wangle/ssl/SSLUtil.cpp
new file mode 100644
index 0000000..f900003
--- /dev/null
+++ b/folly/wangle/ssl/SSLUtil.cpp
@@ -0,0 +1,76 @@
+/*
+ *  Copyright (c) 2015, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+#include <folly/wangle/ssl/SSLUtil.h>
+
+#include <folly/Memory.h>
+
+#if OPENSSL_VERSION_NUMBER >= 0x1000105fL
+#define OPENSSL_GE_101 1
+#include <openssl/asn1.h>
+#include <openssl/x509v3.h>
+#else
+#undef OPENSSL_GE_101
+#endif
+
+namespace folly {
+
+std::mutex SSLUtil::sIndexLock_;
+
+std::unique_ptr<std::string> SSLUtil::getCommonName(const X509* cert) {
+  X509_NAME* subject = X509_get_subject_name((X509*)cert);
+  if (!subject) {
+    return nullptr;
+  }
+  char cn[ub_common_name + 1];
+  int res = X509_NAME_get_text_by_NID(subject, NID_commonName,
+                                      cn, ub_common_name);
+  if (res <= 0) {
+    return nullptr;
+  } else {
+    cn[ub_common_name] = '\0';
+    return folly::make_unique<std::string>(cn);
+  }
+}
+
+std::unique_ptr<std::list<std::string>> SSLUtil::getSubjectAltName(
+    const X509* cert) {
+#ifdef OPENSSL_GE_101
+  auto nameList = folly::make_unique<std::list<std::string>>();
+  GENERAL_NAMES* names = (GENERAL_NAMES*)X509_get_ext_d2i(
+      (X509*)cert, NID_subject_alt_name, nullptr, nullptr);
+  if (names) {
+    auto guard = folly::makeGuard([names] { GENERAL_NAMES_free(names); });
+    size_t count = sk_GENERAL_NAME_num(names);
+    CHECK(count < std::numeric_limits<int>::max());
+    for (int i = 0; i < (int)count; ++i) {
+      GENERAL_NAME* generalName = sk_GENERAL_NAME_value(names, i);
+      if (generalName->type == GEN_DNS) {
+        ASN1_STRING* s = generalName->d.dNSName;
+        const char* name = (const char*)ASN1_STRING_data(s);
+        // I can't find any docs on what a negative return value here
+        // would mean, so I'm going to ignore it.
+        auto len = ASN1_STRING_length(s);
+        DCHECK(len >= 0);
+        if (size_t(len) != strlen(name)) {
+          // Null byte(s) in the name; return an error rather than depending on
+          // the caller to safely handle this case.
+          return nullptr;
+        }
+        nameList->emplace_back(name);
+      }
+    }
+  }
+  return nameList;
+#else
+  return nullptr;
+#endif
+}
+
+}
diff --git a/folly/wangle/ssl/TLSTicketKeyManager.cpp b/folly/wangle/ssl/TLSTicketKeyManager.cpp
new file mode 100644
index 0000000..45761c1
--- /dev/null
+++ b/folly/wangle/ssl/TLSTicketKeyManager.cpp
@@ -0,0 +1,305 @@
+/*
+ *  Copyright (c) 2015, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+#include <folly/wangle/ssl/TLSTicketKeyManager.h>
+
+#include <folly/wangle/ssl/SSLStats.h>
+#include <folly/wangle/ssl/SSLUtil.h>
+
+#include <folly/String.h>
+#include <openssl/aes.h>
+#include <openssl/rand.h>
+#include <openssl/ssl.h>
+#include <folly/io/async/AsyncTimeout.h>
+
+#ifdef SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB
+using std::string;
+
+namespace {
+
+const int kTLSTicketKeyNameLen = 4;
+const int kTLSTicketKeySaltLen = 12;
+
+}
+
+namespace folly {
+
+
+// TLSTicketKeyManager Implementation
+int32_t TLSTicketKeyManager::sExDataIndex_ = -1;
+
+TLSTicketKeyManager::TLSTicketKeyManager(SSLContext* ctx, SSLStats* stats)
+  : ctx_(ctx),
+    randState_(0),
+    stats_(stats) {
+  SSLUtil::getSSLCtxExIndex(&sExDataIndex_);
+  SSL_CTX_set_ex_data(ctx_->getSSLCtx(), sExDataIndex_, this);
+}
+
+TLSTicketKeyManager::~TLSTicketKeyManager() {
+}
+
+int
+TLSTicketKeyManager::callback(SSL* ssl, unsigned char* keyName,
+                              unsigned char* iv,
+                              EVP_CIPHER_CTX* cipherCtx,
+                              HMAC_CTX* hmacCtx, int encrypt) {
+  TLSTicketKeyManager* manager = nullptr;
+  SSL_CTX* ctx = SSL_get_SSL_CTX(ssl);
+  manager = (TLSTicketKeyManager *)SSL_CTX_get_ex_data(ctx, sExDataIndex_);
+
+  if (manager == nullptr) {
+    LOG(FATAL) << "Null TLSTicketKeyManager in callback" ;
+    return -1;
+  }
+  return manager->processTicket(ssl, keyName, iv, cipherCtx, hmacCtx, encrypt);
+}
+
+int
+TLSTicketKeyManager::processTicket(SSL* ssl, unsigned char* keyName,
+                                   unsigned char* iv,
+                                   EVP_CIPHER_CTX* cipherCtx,
+                                   HMAC_CTX* hmacCtx, int encrypt) {
+  uint8_t salt[kTLSTicketKeySaltLen];
+  uint8_t* saltptr = nullptr;
+  uint8_t output[SHA256_DIGEST_LENGTH];
+  uint8_t* hmacKey = nullptr;
+  uint8_t* aesKey = nullptr;
+  TLSTicketKeySource* key = nullptr;
+  int result = 0;
+
+  if (encrypt) {
+    key = findEncryptionKey();
+    if (key == nullptr) {
+      // no keys available to encrypt
+      VLOG(2) << "No TLS ticket key found";
+      return -1;
+    }
+    VLOG(4) << "Encrypting new ticket with key name=" <<
+      SSLUtil::hexlify(key->keyName_);
+
+    // Get a random salt and write out key name
+    RAND_pseudo_bytes(salt, (int)sizeof(salt));
+    memcpy(keyName, key->keyName_.data(), kTLSTicketKeyNameLen);
+    memcpy(keyName + kTLSTicketKeyNameLen, salt, kTLSTicketKeySaltLen);
+
+    // Create the unique keys by hashing with the salt
+    makeUniqueKeys(key->keySource_, sizeof(key->keySource_), salt, output);
+    // This relies on the fact that SHA256 has 32 bytes of output
+    // and that AES-128 keys are 16 bytes
+    hmacKey = output;
+    aesKey = output + SHA256_DIGEST_LENGTH / 2;
+
+    // Initialize iv and cipher/mac CTX
+    RAND_pseudo_bytes(iv, AES_BLOCK_SIZE);
+    HMAC_Init_ex(hmacCtx, hmacKey, SHA256_DIGEST_LENGTH / 2,
+                 EVP_sha256(), nullptr);
+    EVP_EncryptInit_ex(cipherCtx, EVP_aes_128_cbc(), nullptr, aesKey, iv);
+
+    result = 1;
+  } else {
+    key = findDecryptionKey(keyName);
+    if (key == nullptr) {
+      // no ticket found for decryption - will issue a new ticket
+      if (VLOG_IS_ON(4)) {
+        string skeyName((char *)keyName, kTLSTicketKeyNameLen);
+        VLOG(4) << "Can't find ticket key with name=" <<
+          SSLUtil::hexlify(skeyName)<< ", will generate new ticket";
+      }
+
+      result = 0;
+    } else {
+      VLOG(4) << "Decrypting ticket with key name=" <<
+        SSLUtil::hexlify(key->keyName_);
+
+      // Reconstruct the unique key via the salt
+      saltptr = keyName + kTLSTicketKeyNameLen;
+      makeUniqueKeys(key->keySource_, sizeof(key->keySource_), saltptr, output);
+      hmacKey = output;
+      aesKey = output + SHA256_DIGEST_LENGTH / 2;
+
+      // Initialize cipher/mac CTX
+      HMAC_Init_ex(hmacCtx, hmacKey, SHA256_DIGEST_LENGTH / 2,
+                   EVP_sha256(), nullptr);
+      EVP_DecryptInit_ex(cipherCtx, EVP_aes_128_cbc(), nullptr, aesKey, iv);
+
+      result = 1;
+    }
+  }
+  // result records whether a ticket key was found to decrypt this ticket,
+  // not wether the session was re-used.
+  if (stats_) {
+    stats_->recordTLSTicket(encrypt, result);
+  }
+
+  return result;
+}
+
+bool
+TLSTicketKeyManager::setTLSTicketKeySeeds(
+    const std::vector<std::string>& oldSeeds,
+    const std::vector<std::string>& currentSeeds,
+    const std::vector<std::string>& newSeeds) {
+
+  bool result = true;
+
+  activeKeys_.clear();
+  ticketKeys_.clear();
+  ticketSeeds_.clear();
+  const std::vector<string> *seedList = &oldSeeds;
+  for (uint32_t i = 0; i < 3; i++) {
+    TLSTicketSeedType type = (TLSTicketSeedType)i;
+    if (type == SEED_CURRENT) {
+      seedList = &currentSeeds;
+    } else if (type == SEED_NEW) {
+      seedList = &newSeeds;
+    }
+
+    for (const auto& seedInput: *seedList) {
+      TLSTicketSeed* seed = insertSeed(seedInput, type);
+      if (seed == nullptr) {
+        result = false;
+        continue;
+      }
+      insertNewKey(seed, 1, nullptr);
+    }
+  }
+  if (!result) {
+    VLOG(2) << "One or more seeds failed to decode";
+  }
+
+  if (ticketKeys_.size() == 0 || activeKeys_.size() == 0) {
+    LOG(WARNING) << "No keys configured, falling back to default";
+    SSL_CTX_set_tlsext_ticket_key_cb(ctx_->getSSLCtx(), nullptr);
+    return false;
+  }
+  SSL_CTX_set_tlsext_ticket_key_cb(ctx_->getSSLCtx(),
+                                   TLSTicketKeyManager::callback);
+
+  return true;
+}
+
+string
+TLSTicketKeyManager::makeKeyName(TLSTicketSeed* seed, uint32_t n,
+                                 unsigned char* nameBuf) {
+  SHA256_CTX ctx;
+
+  SHA256_Init(&ctx);
+  SHA256_Update(&ctx, seed->seedName_, sizeof(seed->seedName_));
+  SHA256_Update(&ctx, &n, sizeof(n));
+  SHA256_Final(nameBuf, &ctx);
+  return string((char *)nameBuf, kTLSTicketKeyNameLen);
+}
+
+TLSTicketKeyManager::TLSTicketKeySource*
+TLSTicketKeyManager::insertNewKey(TLSTicketSeed* seed, uint32_t hashCount,
+                                  TLSTicketKeySource* prevKey) {
+  unsigned char nameBuf[SHA256_DIGEST_LENGTH];
+  std::unique_ptr<TLSTicketKeySource> newKey(new TLSTicketKeySource);
+
+  // This function supports hash chaining but it is not currently used.
+
+  if (prevKey != nullptr) {
+    hashNth(prevKey->keySource_, sizeof(prevKey->keySource_),
+            newKey->keySource_, 1);
+  } else {
+    // can't go backwards or the current is missing, start from the beginning
+    hashNth((unsigned char *)seed->seed_.data(), seed->seed_.length(),
+            newKey->keySource_, hashCount);
+  }
+
+  newKey->hashCount_ = hashCount;
+  newKey->keyName_ = makeKeyName(seed, hashCount, nameBuf);
+  newKey->type_ = seed->type_;
+  auto it = ticketKeys_.insert(std::make_pair(newKey->keyName_,
+        std::move(newKey)));
+
+  auto key = it.first->second.get();
+  if (key->type_ == SEED_CURRENT) {
+    activeKeys_.push_back(key);
+  }
+  VLOG(4) << "Adding key for " << hashCount << " type=" <<
+    (uint32_t)key->type_ << " Name=" << SSLUtil::hexlify(key->keyName_);
+
+  return key;
+}
+
+void
+TLSTicketKeyManager::hashNth(const unsigned char* input, size_t input_len,
+                             unsigned char* output, uint32_t n) {
+  assert(n > 0);
+  for (uint32_t i = 0; i < n; i++) {
+    SHA256(input, input_len, output);
+    input = output;
+    input_len = SHA256_DIGEST_LENGTH;
+  }
+}
+
+TLSTicketKeyManager::TLSTicketSeed *
+TLSTicketKeyManager::insertSeed(const string& seedInput,
+                                TLSTicketSeedType type) {
+  TLSTicketSeed* seed = nullptr;
+  string seedOutput;
+
+  if (!folly::unhexlify<string, string>(seedInput, seedOutput)) {
+    LOG(WARNING) << "Failed to decode seed type=" << (uint32_t)type <<
+      " seed=" << seedInput;
+    return seed;
+  }
+
+  seed = new TLSTicketSeed();
+  seed->seed_ = seedOutput;
+  seed->type_ = type;
+  SHA256((unsigned char *)seedOutput.data(), seedOutput.length(),
+         seed->seedName_);
+  ticketSeeds_.push_back(std::unique_ptr<TLSTicketSeed>(seed));
+
+  return seed;
+}
+
+TLSTicketKeyManager::TLSTicketKeySource *
+TLSTicketKeyManager::findEncryptionKey() {
+  TLSTicketKeySource* result = nullptr;
+  // call to rand here is a bit hokey since it's not cryptographically
+  // random, and is predictably seeded with 0.  However, activeKeys_
+  // is probably not going to have very many keys in it, and most
+  // likely only 1.
+  size_t numKeys = activeKeys_.size();
+  if (numKeys > 0) {
+    result = activeKeys_[rand_r(&randState_) % numKeys];
+  }
+  return result;
+}
+
+TLSTicketKeyManager::TLSTicketKeySource *
+TLSTicketKeyManager::findDecryptionKey(unsigned char* keyName) {
+  string name((char *)keyName, kTLSTicketKeyNameLen);
+  TLSTicketKeySource* key = nullptr;
+  TLSTicketKeyMap::iterator mapit = ticketKeys_.find(name);
+  if (mapit != ticketKeys_.end()) {
+    key = mapit->second.get();
+  }
+  return key;
+}
+
+void
+TLSTicketKeyManager::makeUniqueKeys(unsigned char* parentKey,
+                                    size_t keyLen,
+                                    unsigned char* salt,
+                                    unsigned char* output) {
+  SHA256_CTX hash_ctx;
+
+  SHA256_Init(&hash_ctx);
+  SHA256_Update(&hash_ctx, parentKey, keyLen);
+  SHA256_Update(&hash_ctx, salt, kTLSTicketKeySaltLen);
+  SHA256_Final(output, &hash_ctx);
+}
+
+} // namespace
+#endif
diff --git a/folly/wangle/ssl/test/SSLCacheTest.cpp b/folly/wangle/ssl/test/SSLCacheTest.cpp
new file mode 100644
index 0000000..f3129e4
--- /dev/null
+++ b/folly/wangle/ssl/test/SSLCacheTest.cpp
@@ -0,0 +1,272 @@
+/*
+ *  Copyright (c) 2015, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+#include <folly/Portability.h>
+#include <folly/io/async/EventBase.h>
+#include <gflags/gflags.h>
+#include <iostream>
+#include <thread>
+#include <folly/io/async/AsyncSSLSocket.h>
+#include <folly/io/async/AsyncSocket.h>
+#include <vector>
+
+using namespace std;
+using namespace folly;
+
+DEFINE_int32(clients, 1, "Number of simulated SSL clients");
+DEFINE_int32(threads, 1, "Number of threads to spread clients across");
+DEFINE_int32(requests, 2, "Total number of requests per client");
+DEFINE_int32(port, 9423, "Server port");
+DEFINE_bool(sticky, false, "A given client sends all reqs to one "
+            "(random) server");
+DEFINE_bool(global, false, "All clients in a thread use the same SSL session");
+DEFINE_bool(handshakes, false, "Force 100% handshakes");
+
+string f_servers[10];
+int f_num_servers = 0;
+int tnum = 0;
+
+class ClientRunner {
+ public:
+
+  ClientRunner(): reqs(0), hits(0), miss(0), num(tnum++) {}
+  void run();
+
+  int reqs;
+  int hits;
+  int miss;
+  int num;
+};
+
+class SSLCacheClient : public AsyncSocket::ConnectCallback,
+                       public AsyncSSLSocket::HandshakeCB
+{
+private:
+  EventBase* eventBase_;
+  int currReq_;
+  int serverIdx_;
+  AsyncSocket* socket_;
+  AsyncSSLSocket* sslSocket_;
+  SSL_SESSION* session_;
+  SSL_SESSION **pSess_;
+  std::shared_ptr<SSLContext> ctx_;
+  ClientRunner* cr_;
+
+public:
+  SSLCacheClient(EventBase* eventBase, SSL_SESSION **pSess, ClientRunner* cr);
+  ~SSLCacheClient() {
+    if (session_ && !FLAGS_global)
+      SSL_SESSION_free(session_);
+    if (socket_ != nullptr) {
+      if (sslSocket_ != nullptr) {
+        sslSocket_->destroy();
+        sslSocket_ = nullptr;
+      }
+      socket_->destroy();
+      socket_ = nullptr;
+    }
+  };
+
+  void start();
+
+  virtual void connectSuccess() noexcept;
+
+  virtual void connectErr(const AsyncSocketException& ex)
+    noexcept ;
+
+  virtual void handshakeSuc(AsyncSSLSocket* sock) noexcept;
+
+  virtual void handshakeErr(
+    AsyncSSLSocket* sock,
+    const AsyncSocketException& ex) noexcept;
+
+};
+
+int
+main(int argc, char* argv[])
+{
+  gflags::SetUsageMessage(std::string("\n\n"
+"usage: sslcachetest [options] -c <clients> -t <threads> servers\n"
+));
+  gflags::ParseCommandLineFlags(&argc, &argv, true);
+  int reqs = 0;
+  int hits = 0;
+  int miss = 0;
+  struct timeval start;
+  struct timeval end;
+  struct timeval result;
+
+  srand((unsigned int)time(nullptr));
+
+  for (int i = 1; i < argc; i++) {
+    f_servers[f_num_servers++] = argv[i];
+  }
+  if (f_num_servers == 0) {
+    cout << "require at least one server\n";
+    return 1;
+  }
+
+  gettimeofday(&start, nullptr);
+  if (FLAGS_threads == 1) {
+    ClientRunner r;
+    r.run();
+    gettimeofday(&end, nullptr);
+    reqs = r.reqs;
+    hits = r.hits;
+    miss = r.miss;
+  }
+  else {
+    std::vector<ClientRunner> clients;
+    std::vector<std::thread> threads;
+    for (int t = 0; t < FLAGS_threads; t++) {
+      threads.emplace_back([&] {
+          clients[t].run();
+        });
+    }
+    for (auto& thr: threads) {
+      thr.join();
+    }
+    gettimeofday(&end, nullptr);
+
+    for (const auto& client: clients) {
+      reqs += client.reqs;
+      hits += client.hits;
+      miss += client.miss;
+    }
+  }
+
+  timersub(&end, &start, &result);
+
+  cout << "Requests: " << reqs << endl;
+  cout << "Handshakes: " << miss << endl;
+  cout << "Resumes: " << hits << endl;
+  cout << "Runtime(ms): " << result.tv_sec << "." << result.tv_usec / 1000 <<
+    endl;
+
+  cout << "ops/sec: " << (reqs * 1.0) /
+    ((double)result.tv_sec * 1.0 + (double)result.tv_usec / 1000000.0) << endl;
+
+  return 0;
+}
+
+void
+ClientRunner::run()
+{
+  EventBase eb;
+  std::list<SSLCacheClient *> clients;
+  SSL_SESSION* session = nullptr;
+
+  for (int i = 0; i < FLAGS_clients; i++) {
+    SSLCacheClient* c = new SSLCacheClient(&eb, &session, this);
+    c->start();
+    clients.push_back(c);
+  }
+
+  eb.loop();
+
+  for (auto it = clients.begin(); it != clients.end(); it++) {
+    delete* it;
+  }
+
+  reqs += hits + miss;
+}
+
+SSLCacheClient::SSLCacheClient(EventBase* eb,
+                               SSL_SESSION **pSess,
+                               ClientRunner* cr)
+    : eventBase_(eb),
+      currReq_(0),
+      serverIdx_(0),
+      socket_(nullptr),
+      sslSocket_(nullptr),
+      session_(nullptr),
+      pSess_(pSess),
+      cr_(cr)
+{
+  ctx_.reset(new SSLContext());
+  ctx_->setOptions(SSL_OP_NO_TICKET);
+}
+
+void
+SSLCacheClient::start()
+{
+  if (currReq_ >= FLAGS_requests) {
+    cout << "+";
+    return;
+  }
+
+  if (currReq_ == 0 || !FLAGS_sticky) {
+    serverIdx_ = rand() % f_num_servers;
+  }
+  if (socket_ != nullptr) {
+    if (sslSocket_ != nullptr) {
+      sslSocket_->destroy();
+      sslSocket_ = nullptr;
+    }
+    socket_->destroy();
+    socket_ = nullptr;
+  }
+  socket_ = new AsyncSocket(eventBase_);
+  socket_->connect(this, f_servers[serverIdx_], (uint16_t)FLAGS_port);
+}
+
+void
+SSLCacheClient::connectSuccess() noexcept
+{
+  sslSocket_ = new AsyncSSLSocket(ctx_, eventBase_, socket_->detachFd(),
+                                   false);
+
+  if (!FLAGS_handshakes) {
+    if (session_ != nullptr)
+      sslSocket_->setSSLSession(session_);
+    else if (FLAGS_global && pSess_ != nullptr)
+      sslSocket_->setSSLSession(*pSess_);
+  }
+  sslSocket_->sslConn(this);
+}
+
+void
+SSLCacheClient::connectErr(const AsyncSocketException& ex)
+  noexcept
+{
+  cout << "connectError: " << ex.what() << endl;
+}
+
+void
+SSLCacheClient::handshakeSuc(AsyncSSLSocket* socket) noexcept
+{
+  if (sslSocket_->getSSLSessionReused()) {
+    cr_->hits++;
+  } else {
+    cr_->miss++;
+    if (session_ != nullptr) {
+      SSL_SESSION_free(session_);
+    }
+    session_ = sslSocket_->getSSLSession();
+    if (FLAGS_global && pSess_ != nullptr && *pSess_ == nullptr) {
+      *pSess_ = session_;
+    }
+  }
+  if ( ((cr_->hits + cr_->miss) % 100) == ((100 / FLAGS_threads) * cr_->num)) {
+    cout << ".";
+    cout.flush();
+  }
+  sslSocket_->closeNow();
+  currReq_++;
+  this->start();
+}
+
+void
+SSLCacheClient::handshakeErr(
+  AsyncSSLSocket* sock,
+  const AsyncSocketException& ex)
+  noexcept
+{
+  cout << "handshakeError: " << ex.what() << endl;
+}
diff --git a/folly/wangle/ssl/test/SSLContextManagerTest.cpp b/folly/wangle/ssl/test/SSLContextManagerTest.cpp
new file mode 100644
index 0000000..ab48939
--- /dev/null
+++ b/folly/wangle/ssl/test/SSLContextManagerTest.cpp
@@ -0,0 +1,87 @@
+/*
+ *  Copyright (c) 2015, Facebook, Inc.
+ *  All rights reserved.
+ *
+ *  This source code is licensed under the BSD-style license found in the
+ *  LICENSE file in the root directory of this source tree. An additional grant
+ *  of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+#include <folly/io/async/EventBase.h>
+#include <folly/io/async/SSLContext.h>
+#include <glog/logging.h>
+#include <gtest/gtest.h>
+#include <folly/wangle/ssl/SSLContextManager.h>
+#include <folly/wangle/acceptor/DomainNameMisc.h>
+
+using std::shared_ptr;
+
+namespace folly {
+
+TEST(SSLContextManagerTest, Test1)
+{
+  EventBase eventBase;
+  SSLContextManager sslCtxMgr(&eventBase, "vip_ssl_context_manager_test_",
+                              true, nullptr);
+  auto www_facebook_com_ctx = std::make_shared<SSLContext>();
+  auto start_facebook_com_ctx = std::make_shared<SSLContext>();
+  auto start_abc_facebook_com_ctx = std::make_shared<SSLContext>();
+
+  sslCtxMgr.insertSSLCtxByDomainName(
+    "www.facebook.com",
+    strlen("www.facebook.com"),
+    www_facebook_com_ctx);
+  sslCtxMgr.insertSSLCtxByDomainName(
+    "www.facebook.com",
+    strlen("www.facebook.com"),
+    www_facebook_com_ctx);
+  try {
+    sslCtxMgr.insertSSLCtxByDomainName(
+      "www.facebook.com",
+      strlen("www.facebook.com"),
+      std::make_shared<SSLContext>());
+  } catch (const std::exception& ex) {
+  }
+  sslCtxMgr.insertSSLCtxByDomainName(
+    "*.facebook.com",
+    strlen("*.facebook.com"),
+    start_facebook_com_ctx);
+  sslCtxMgr.insertSSLCtxByDomainName(
+    "*.abc.facebook.com",
+    strlen("*.abc.facebook.com"),
+    start_abc_facebook_com_ctx);
+  try {
+    sslCtxMgr.insertSSLCtxByDomainName(
+      "*.abc.facebook.com",
+      strlen("*.abc.facebook.com"),
+      std::make_shared<SSLContext>());
+    FAIL();
+  } catch (const std::exception& ex) {
+  }
+
+  shared_ptr<SSLContext> retCtx;
+  retCtx = sslCtxMgr.getSSLCtx(DNString("www.facebook.com"));
+  EXPECT_EQ(retCtx, www_facebook_com_ctx);
+  retCtx = sslCtxMgr.getSSLCtx(DNString("WWW.facebook.com"));
+  EXPECT_EQ(retCtx, www_facebook_com_ctx);
+  EXPECT_FALSE(sslCtxMgr.getSSLCtx(DNString("xyz.facebook.com")));
+
+  retCtx = sslCtxMgr.getSSLCtxBySuffix(DNString("xyz.facebook.com"));
+  EXPECT_EQ(retCtx, start_facebook_com_ctx);
+  retCtx = sslCtxMgr.getSSLCtxBySuffix(DNString("XYZ.facebook.com"));
+  EXPECT_EQ(retCtx, start_facebook_com_ctx);
+
+  retCtx = sslCtxMgr.getSSLCtxBySuffix(DNString("www.abc.facebook.com"));
+  EXPECT_EQ(retCtx, start_abc_facebook_com_ctx);
+
+  // ensure "facebook.com" does not match "*.facebook.com"
+  EXPECT_FALSE(sslCtxMgr.getSSLCtxBySuffix(DNString("facebook.com")));
+  // ensure "Xfacebook.com" does not match "*.facebook.com"
+  EXPECT_FALSE(sslCtxMgr.getSSLCtxBySuffix(DNString("Xfacebook.com")));
+  // ensure wildcard name only matches one domain up
+  EXPECT_FALSE(sslCtxMgr.getSSLCtxBySuffix(DNString("abc.xyz.facebook.com")));
+
+  eventBase.loop(); // Clean up events before SSLContextManager is destructed
+}
+
+}