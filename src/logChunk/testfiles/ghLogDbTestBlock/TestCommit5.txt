commit 4e9cb43928abbddd5d683cb5d9d66c72b3bbf88e
Author: Lars Op den Kamp <lars@opdenkamp.eu>
Date:   2012-09-01

    [pvr] added PVR support to XBMC (taken from https://github.com/opdenkamp/xbmc/commit/c576c080532a0e4c4ffc7babd57782f80a6951ba)
    add-ons are not included, but can be found here: https://github.com/opdenkamp/xbmc-pvr-addons

diff --git a/addons/library.xbmc.addon/dlfcn-win32.cpp b/addons/library.xbmc.addon/dlfcn-win32.cpp
new file mode 100644
index 0000000..5839921
--- /dev/null
+++ b/addons/library.xbmc.addon/dlfcn-win32.cpp
@@ -0,0 +1,263 @@
+/*
+ * dlfcn-win32
+ * Copyright (c) 2007 Ramiro Polla
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <windows.h>
+#include <stdio.h>
+
+#include "dlfcn-win32.h"
+
+/* Note:
+ * MSDN says these functions are not thread-safe. We make no efforts to have
+ * any kind of thread safety.
+ */
+
+/* I have no special reason to have set MAX_GLOBAL_OBJECTS to this value. Any
+ * comments are welcome.
+ */
+#define MAX_OBJECTS 255
+
+static HMODULE global_objects[MAX_OBJECTS];
+
+/* This function adds an object to the list of global objects.
+ * The implementation is very simple and slow.
+ * TODO: should failing this function be enough to fail the call to dlopen( )?
+ */
+static void global_object_add( HMODULE hModule )
+{
+    int i;
+
+    for( i = 0 ; i < MAX_OBJECTS ; i++ )
+    {
+        if( !global_objects[i] )
+        {
+            global_objects[i] = hModule;
+            break;
+        }
+    }
+}
+
+static void global_object_rem( HMODULE hModule )
+{
+    int i;
+
+    for( i = 0 ; i < MAX_OBJECTS ; i++ )
+    {
+        if( global_objects[i] == hModule )
+        {
+            global_objects[i] = 0;
+            break;
+        }
+    }
+}
+
+/* Argument to last function. Used in dlerror( ) */
+static char last_name[MAX_PATH];
+
+static int copy_string( char *dest, int dest_size, const char *src )
+{
+    int i = 0;
+
+    if( src && dest )
+    {
+        for( i = 0 ; i < dest_size-1 ; i++ )
+        {
+            if( !src[i] )
+                break;
+            else
+                dest[i] = src[i];
+        }
+    }
+    dest[i] = '\0';
+
+    return i;
+}
+
+void *dlopen( const char *file, int mode )
+{
+    HMODULE hModule;
+    UINT uMode;
+
+    /* Do not let Windows display the critical-error-handler message box */
+    uMode = SetErrorMode( SEM_FAILCRITICALERRORS );
+
+    if( file == 0 )
+    {
+        /* Save NULL pointer for error message */
+        _snprintf_s( last_name, MAX_PATH, MAX_PATH, "0x%p", file );
+
+        /* POSIX says that if the value of file is 0, a handle on a global
+         * symbol object must be provided. That object must be able to access
+         * all symbols from the original program file, and any objects loaded
+         * with the RTLD_GLOBAL flag.
+         * The return value from GetModuleHandle( ) allows us to retrieve
+         * symbols only from the original program file. For objects loaded with
+         * the RTLD_GLOBAL flag, we create our own list later on.
+         */
+        hModule = GetModuleHandle( NULL );
+    }
+    else
+    {
+        char lpFileName[MAX_PATH];
+        int i;
+
+        /* MSDN says backslashes *must* be used instead of forward slashes. */
+        for( i = 0 ; i < sizeof(lpFileName)-1 ; i++ )
+        {
+            if( !file[i] )
+                break;
+            else if( file[i] == '/' )
+                lpFileName[i] = '\\';
+            else
+                lpFileName[i] = file[i];
+        }
+        lpFileName[i] = '\0';
+
+        /* Save file name for error message */
+        copy_string( last_name, sizeof(last_name), lpFileName );
+
+        /* POSIX says the search path is implementation-defined.
+         * LOAD_WITH_ALTERED_SEARCH_PATH is used to make it behave more closely
+         * to UNIX's search paths (start with system folders instead of current
+         * folder).
+         */
+        hModule = LoadLibraryEx( (LPSTR) lpFileName, NULL,
+                                 LOAD_WITH_ALTERED_SEARCH_PATH );
+        /* If the object was loaded with RTLD_GLOBAL, add it to list of global
+         * objects, so that its symbols may be retrieved even if the handle for
+         * the original program file is passed. POSIX says that if the same
+         * file is specified in multiple invocations, and any of them are
+         * RTLD_GLOBAL, even if any further invocations use RTLD_LOCAL, the
+         * symbols will remain global.
+         */
+
+        if( hModule && (mode & RTLD_GLOBAL) )
+            global_object_add( hModule );
+    }
+
+    /* Return to previous state of the error-mode bit flags. */
+    SetErrorMode( uMode );
+
+    return (void *) hModule;
+}
+
+int dlclose( void *handle )
+{
+    HMODULE hModule = (HMODULE) handle;
+    BOOL ret;
+
+    /* Save handle for error message */
+    _snprintf_s( last_name, MAX_PATH, MAX_PATH, "0x%p", handle );
+
+    ret = FreeLibrary( hModule );
+
+    /* If the object was loaded with RTLD_GLOBAL, remove it from list of global
+     * objects.
+     */
+    if( ret )
+        global_object_rem( hModule );
+
+    /* dlclose's return value in inverted in relation to FreeLibrary's. */
+    ret = !ret;
+
+    return (int) ret;
+}
+
+void *dlsym( void *handle, const char *name )
+{
+    FARPROC symbol;
+    HMODULE myhandle = (HMODULE) handle;
+
+    /* Save symbol name for error message */
+    copy_string( last_name, sizeof(last_name), name );
+
+    symbol = GetProcAddress( myhandle, name );
+#if 0
+    if( symbol == NULL )
+    {
+        HMODULE hModule;
+
+        /* If the handle for the original program file is passed, also search
+         * in all globally loaded objects.
+         */
+
+        hModule = GetModuleHandle( NULL );
+
+        if( hModule == handle )
+        {
+            int i;
+           
+            for( i = 0 ; i < MAX_OBJECTS ; i++ )
+            {
+                if( global_objects[i] != 0 )
+                {
+                    symbol = GetProcAddress( global_objects[i], name );
+                    if( symbol != NULL )
+                        break;
+                }
+            }
+        }
+
+
+        CloseHandle( hModule );
+    }
+#endif
+    return (void*) symbol;
+}
+
+char *dlerror( void )
+{
+    DWORD dwMessageId;
+    /* POSIX says this function doesn't have to be thread-safe, so we use one
+     * static buffer.
+     * MSDN says the buffer cannot be larger than 64K bytes, so we set it to
+     * the limit.
+     */
+    static char lpBuffer[65535];
+    DWORD ret;
+
+    dwMessageId = GetLastError( );
+   
+    if( dwMessageId == 0 )
+        return NULL;
+
+    /* Format error message to:
+     * "<argument to function that failed>": <Windows localized error message>
+     */
+    ret  = copy_string( lpBuffer, sizeof(lpBuffer), "\"" );
+    ret += copy_string( lpBuffer+ret, sizeof(lpBuffer)-ret, last_name );
+    ret += copy_string( lpBuffer+ret, sizeof(lpBuffer)-ret, "\": " );
+    ret += FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwMessageId,
+                          MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
+                          lpBuffer+ret, sizeof(lpBuffer)-ret, NULL );
+
+    if( ret > 1 )
+    {
+        /* POSIX says the string must not have trailing <newline> */
+        if( lpBuffer[ret-2] == '\r' && lpBuffer[ret-1] == '\n' )
+            lpBuffer[ret-2] = '\0';
+    }
+
+    /* POSIX says that invoking dlerror( ) a second time, immediately following
+     * a prior invocation, shall result in NULL being returned.
+     */
+    SetLastError(0);
+
+    return lpBuffer;
+}
+
diff --git a/addons/library.xbmc.addon/dlfcn-win32.h b/addons/library.xbmc.addon/dlfcn-win32.h
new file mode 100644
index 0000000..b93a029
--- /dev/null
+++ b/addons/library.xbmc.addon/dlfcn-win32.h
@@ -0,0 +1,46 @@
+#pragma once
+/*
+ * dlfcn-win32
+ * Copyright (c) 2007 Ramiro Polla
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef DLFCN_H
+#define DLFCN_H
+
+/* POSIX says these are implementation-defined.
+ * To simplify use with Windows API, we treat them the same way.
+ */
+
+#define RTLD_LAZY   0
+#define RTLD_NOW    0
+
+#define RTLD_GLOBAL (1 << 1)
+#define RTLD_LOCAL  (1 << 2)
+
+/* These two were added in The Open Group Base Specifications Issue 6.
+ * Note: All other RTLD_* flags in any dlfcn.h are not standard compliant.
+ */
+
+#define RTLD_DEFAULT    0
+#define RTLD_NEXT       0
+
+void *dlopen ( const char *file, int mode );
+int   dlclose( void *handle );
+void *dlsym  ( void *handle, const char *name );
+char *dlerror( void );
+
+#endif /* DLFCN-WIN32_H */
diff --git a/addons/library.xbmc.addon/libXBMC_addon.h b/addons/library.xbmc.addon/libXBMC_addon.h
new file mode 100644
index 0000000..75012e9
--- /dev/null
+++ b/addons/library.xbmc.addon/libXBMC_addon.h
@@ -0,0 +1,182 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2010 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include <string>
+#include <vector>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+#ifdef _WIN32                   // windows
+#include "dlfcn-win32.h"
+#define ADDON_DLL               "\\library.xbmc.addon\\libXBMC_addon" ADDON_HELPER_EXT
+#define ADDON_HELPER_PLATFORM   "win32"
+#define ADDON_HELPER_EXT        ".dll"
+#else
+#if defined(__APPLE__)          // osx
+#define ADDON_HELPER_PLATFORM   "osx"
+#if defined(__POWERPC__)
+#define ADDON_HELPER_ARCH       "powerpc"
+#elif defined(__arm__)
+#define ADDON_HELPER_ARCH       "arm"
+#else
+#define ADDON_HELPER_ARCH       "x86"
+#endif
+#else                           // linux
+#define ADDON_HELPER_PLATFORM   "linux"
+#if defined(__x86_64__)
+#define ADDON_HELPER_ARCH       "x86_64"
+#elif defined(_POWERPC)
+#define ADDON_HELPER_ARCH       "powerpc"
+#elif defined(_POWERPC64)
+#define ADDON_HELPER_ARCH       "powerpc64"
+#elif defined(__ARMEL__)
+#define ADDON_HELPER_ARCH       "arm"
+#elif defined(_MIPSEL)
+#define ADDON_HELPER_ARCH       "mipsel"
+#else
+#define ADDON_HELPER_ARCH       "i486"
+#endif
+#endif
+#include <dlfcn.h>              // linux+osx
+#define ADDON_HELPER_EXT        ".so"
+#define ADDON_DLL "/library.xbmc.addon/libXBMC_addon-" ADDON_HELPER_ARCH "-" ADDON_HELPER_PLATFORM ADDON_HELPER_EXT
+#endif
+
+#ifdef LOG_DEBUG
+#undef LOG_DEBUG
+#endif
+#ifdef LOG_INFO
+#undef LOG_INFO
+#endif
+#ifdef LOG_NOTICE
+#undef LOG_NOTICE
+#endif
+#ifdef LOG_ERROR
+#undef LOG_ERROR
+#endif
+
+namespace ADDON
+{
+  typedef enum addon_log
+  {
+    LOG_DEBUG,
+    LOG_INFO,
+    LOG_NOTICE,
+    LOG_ERROR
+  } addon_log_t;
+
+  typedef enum queue_msg
+  {
+    QUEUE_INFO,
+    QUEUE_WARNING,
+    QUEUE_ERROR
+  } queue_msg_t;
+
+  class CHelper_libXBMC_addon
+  {
+  public:
+    CHelper_libXBMC_addon()
+    {
+      m_libXBMC_addon = NULL;
+      m_Handle        = NULL;
+    }
+
+    ~CHelper_libXBMC_addon()
+    {
+      if (m_libXBMC_addon)
+      {
+        XBMC_unregister_me();
+        dlclose(m_libXBMC_addon);
+      }
+    }
+
+    bool RegisterMe(void *Handle)
+    {
+      m_Handle = Handle;
+
+      std::string libBasePath;
+      libBasePath  = ((cb_array*)m_Handle)->libPath;
+      libBasePath += ADDON_DLL;
+
+      m_libXBMC_addon = dlopen(libBasePath.c_str(), RTLD_LAZY);
+      if (m_libXBMC_addon == NULL)
+      {
+        fprintf(stderr, "Unable to load %s\n", dlerror());
+        return false;
+      }
+
+      XBMC_register_me   = (int (*)(void *HANDLE))
+        dlsym(m_libXBMC_addon, "XBMC_register_me");
+      if (XBMC_register_me == NULL)   { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+      XBMC_unregister_me = (void (*)())
+        dlsym(m_libXBMC_addon, "XBMC_unregister_me");
+      if (XBMC_unregister_me == NULL) { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+      Log                = (void (*)(const addon_log_t loglevel, const char *format, ... ))
+        dlsym(m_libXBMC_addon, "XBMC_log");
+      if (Log == NULL)                { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+      GetSetting         = (bool (*)(const char* settingName, void *settingValue))
+        dlsym(m_libXBMC_addon, "XBMC_get_setting");
+      if (GetSetting == NULL)         { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+      QueueNotification  = (void (*)(const queue_msg_t loglevel, const char *format, ... ))
+        dlsym(m_libXBMC_addon, "XBMC_queue_notification");
+      if (QueueNotification == NULL)  { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+      UnknownToUTF8      = (void (*)(std::string &str))
+        dlsym(m_libXBMC_addon, "XBMC_unknown_to_utf8");
+      if (UnknownToUTF8 == NULL)      { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+      GetLocalizedString = (const char* (*)(int dwCode))
+        dlsym(m_libXBMC_addon, "XBMC_get_localized_string");
+      if (GetLocalizedString == NULL) { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+      GetDVDMenuLanguage = (const char* (*)())
+        dlsym(m_libXBMC_addon, "XBMC_get_dvd_menu_language");
+      if (GetDVDMenuLanguage == NULL) { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+      return XBMC_register_me(m_Handle) > 0;
+    }
+
+    void (*Log)(const addon_log_t loglevel, const char *format, ... );
+    bool (*GetSetting)(const char* settingName, void *settingValue);
+    void (*QueueNotification)(const queue_msg_t type, const char *format, ... );
+    void (*UnknownToUTF8)(std::string &str);
+    const char* (*GetLocalizedString)(int dwCode);
+    const char* (*GetDVDMenuLanguage)();
+
+  protected:
+    int (*XBMC_register_me)(void *HANDLE);
+    void (*XBMC_unregister_me)();
+
+  private:
+    void *m_libXBMC_addon;
+    void *m_Handle;
+    struct cb_array
+    {
+      const char* libPath;
+    };
+  };
+};
diff --git a/addons/library.xbmc.gui/libXBMC_gui.h b/addons/library.xbmc.gui/libXBMC_gui.h
new file mode 100644
index 0000000..afde378
--- /dev/null
+++ b/addons/library.xbmc.gui/libXBMC_gui.h
@@ -0,0 +1,310 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2010 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include <string>
+#include <vector>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include "../library.xbmc.addon/libXBMC_addon.h"
+
+typedef void* GUIHANDLE;
+
+#ifdef _WIN32
+#define GUI_HELPER_DLL "\\library.xbmc.gui\\libXBMC_gui" ADDON_HELPER_EXT
+#else
+#define GUI_HELPER_DLL "/library.xbmc.gui/libXBMC_gui-" ADDON_HELPER_ARCH "-" ADDON_HELPER_PLATFORM ADDON_HELPER_EXT
+#endif
+
+#define ADDON_ACTION_PREVIOUS_MENU          10
+#define ADDON_ACTION_CLOSE_DIALOG           51
+
+class CAddonGUIWindow;
+class CAddonGUISpinControl;
+class CAddonGUIRadioButton;
+class CAddonGUIProgressControl;
+class CAddonListItem;
+
+class CHelper_libXBMC_gui
+{
+public:
+  CHelper_libXBMC_gui()
+  {
+    m_libXBMC_gui = NULL;
+    m_Handle      = NULL;
+  }
+
+  ~CHelper_libXBMC_gui()
+  {
+    if (m_libXBMC_gui)
+    {
+      GUI_unregister_me();
+      dlclose(m_libXBMC_gui);
+    }
+  }
+
+  bool RegisterMe(void *Handle)
+  {
+    m_Handle = Handle;
+
+    std::string libBasePath;
+    libBasePath  = ((cb_array*)m_Handle)->libPath;
+    libBasePath += GUI_HELPER_DLL;
+
+    m_libXBMC_gui = dlopen(libBasePath.c_str(), RTLD_LAZY);
+    if (m_libXBMC_gui == NULL)
+    {
+      fprintf(stderr, "Unable to load %s\n", dlerror());
+      return false;
+    }
+
+    GUI_register_me         = (int (*)(void *HANDLE))
+      dlsym(m_libXBMC_gui, "GUI_register_me");
+    if (GUI_register_me == NULL)      { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    GUI_unregister_me       = (void (*)())
+      dlsym(m_libXBMC_gui, "GUI_unregister_me");
+    if (GUI_unregister_me == NULL)    { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    Lock                    = (void (*)())
+      dlsym(m_libXBMC_gui, "GUI_lock");
+    if (Lock == NULL)                 { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    Unlock                  = (void (*)())
+      dlsym(m_libXBMC_gui, "GUI_unlock");
+    if (Unlock == NULL)               { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    GetScreenHeight         = (int (*)())
+      dlsym(m_libXBMC_gui, "GUI_get_screen_height");
+    if (GetScreenHeight == NULL)      { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    GetScreenWidth          = (int (*)())
+      dlsym(m_libXBMC_gui, "GUI_get_screen_width");
+    if (GetScreenWidth == NULL)       { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    GetVideoResolution      = (int (*)())
+      dlsym(m_libXBMC_gui, "GUI_get_video_resolution");
+    if (GetVideoResolution == NULL)   { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    Window_create           = (CAddonGUIWindow* (*)(const char *xmlFilename, const char *defaultSkin, bool forceFallback, bool asDialog))
+      dlsym(m_libXBMC_gui, "GUI_Window_create");
+    if (Window_create == NULL)        { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    Window_destroy          = (void (*)(CAddonGUIWindow* p))
+      dlsym(m_libXBMC_gui, "GUI_Window_destroy");
+    if (Window_destroy == NULL)       { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    Control_getSpin         = (CAddonGUISpinControl* (*)(CAddonGUIWindow *window, int controlId))
+      dlsym(m_libXBMC_gui, "GUI_control_get_spin");
+    if (Control_getSpin == NULL)      { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    Control_releaseSpin     = (void (*)(CAddonGUISpinControl* p))
+      dlsym(m_libXBMC_gui, "GUI_control_release_spin");
+    if (Control_releaseSpin == NULL)  { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    Control_getRadioButton  = (CAddonGUIRadioButton* (*)(CAddonGUIWindow *window, int controlId))
+      dlsym(m_libXBMC_gui, "GUI_control_get_radiobutton");
+    if (Control_getRadioButton == NULL)      { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    Control_releaseRadioButton = (void (*)(CAddonGUIRadioButton* p))
+      dlsym(m_libXBMC_gui, "GUI_control_release_radiobutton");
+    if (Control_releaseRadioButton == NULL)  { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    Control_getProgress     = (CAddonGUIProgressControl* (*)(CAddonGUIWindow *window, int controlId))
+      dlsym(m_libXBMC_gui, "GUI_control_get_progress");
+    if (Control_getProgress == NULL)  { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    Control_releaseProgress = (void (*)(CAddonGUIProgressControl* p))
+      dlsym(m_libXBMC_gui, "GUI_control_release_progress");
+    if (Control_releaseProgress == NULL) { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    ListItem_create         = (CAddonListItem* (*)(const char *label, const char *label2, const char *iconImage, const char *thumbnailImage, const char *path))
+      dlsym(m_libXBMC_gui, "GUI_ListItem_create");
+    if (ListItem_create == NULL)      { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    ListItem_destroy        = (void (*)(CAddonListItem* p))
+      dlsym(m_libXBMC_gui, "GUI_ListItem_destroy");
+    if (ListItem_destroy == NULL)     { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+
+    return GUI_register_me(m_Handle) > 0;
+  }
+
+  void (*Lock)();
+  void (*Unlock)();
+  int (*GetScreenHeight)();
+  int (*GetScreenWidth)();
+  int (*GetVideoResolution)();
+  CAddonGUIWindow* (*Window_create)(const char *xmlFilename, const char *defaultSkin, bool forceFallback, bool asDialog);
+  void (*Window_destroy)(CAddonGUIWindow* p);
+  CAddonGUISpinControl* (*Control_getSpin)(CAddonGUIWindow *window, int controlId);
+  void (*Control_releaseSpin)(CAddonGUISpinControl* p);
+  CAddonGUIRadioButton* (*Control_getRadioButton)(CAddonGUIWindow *window, int controlId);
+  void (*Control_releaseRadioButton)(CAddonGUIRadioButton* p);
+  CAddonGUIProgressControl* (*Control_getProgress)(CAddonGUIWindow *window, int controlId);
+  void (*Control_releaseProgress)(CAddonGUIProgressControl* p);
+  CAddonListItem* (*ListItem_create)(const char *label, const char *label2, const char *iconImage, const char *thumbnailImage, const char *path);
+  void (*ListItem_destroy)(CAddonListItem* p);
+
+protected:
+  int (*GUI_register_me)(void *HANDLE);
+  void (*GUI_unregister_me)();
+
+private:
+  void *m_libXBMC_gui;
+  void *m_Handle;
+  struct cb_array
+  {
+    const char* libPath;
+  };
+};
+
+class CAddonGUISpinControl
+{
+public:
+  CAddonGUISpinControl(CAddonGUIWindow *window, int controlId);
+  virtual ~CAddonGUISpinControl(void) {}
+
+  virtual void SetVisible(bool yesNo);
+  virtual void SetText(const char *label);
+  virtual void Clear();
+  virtual void AddLabel(const char *label, int iValue);
+  virtual int GetValue();
+  virtual void SetValue(int iValue);
+
+private:
+  CAddonGUIWindow *m_Window;
+  int         m_ControlId;
+  GUIHANDLE   m_SpinHandle;
+};
+
+class CAddonGUIRadioButton
+{
+public:
+  CAddonGUIRadioButton(CAddonGUIWindow *window, int controlId);
+  ~CAddonGUIRadioButton() {}
+
+  virtual void SetVisible(bool yesNo);
+  virtual void SetText(const char *label);
+  virtual void SetSelected(bool yesNo);
+  virtual bool IsSelected();
+
+private:
+  CAddonGUIWindow *m_Window;
+  int         m_ControlId;
+  GUIHANDLE   m_ButtonHandle;
+};
+
+class CAddonGUIProgressControl
+{
+public:
+  CAddonGUIProgressControl(CAddonGUIWindow *window, int controlId);
+  virtual ~CAddonGUIProgressControl(void) {}
+
+  virtual void SetPercentage(float fPercent);
+  virtual float GetPercentage() const;
+  virtual void SetInfo(int iInfo);
+  virtual int GetInfo() const;
+  virtual std::string GetDescription() const;
+
+private:
+  CAddonGUIWindow *m_Window;
+  int         m_ControlId;
+  GUIHANDLE   m_ProgressHandle;
+};
+
+class CAddonListItem
+{
+friend class CAddonGUIWindow;
+
+public:
+  CAddonListItem(const char *label, const char *label2, const char *iconImage, const char *thumbnailImage, const char *path);
+  virtual ~CAddonListItem(void) {}
+
+  virtual const char  *GetLabel();
+  virtual void         SetLabel(const char *label);
+  virtual const char  *GetLabel2();
+  virtual void         SetLabel2(const char *label);
+  virtual void         SetIconImage(const char *image);
+  virtual void         SetThumbnailImage(const char *image);
+  virtual void         SetInfo(const char *Info);
+  virtual void         SetProperty(const char *key, const char *value);
+  virtual const char  *GetProperty(const char *key) const;
+  virtual void         SetPath(const char *Path);
+
+//    {(char*)"select();
+//    {(char*)"isSelected();
+protected:
+  GUIHANDLE   m_ListItemHandle;
+};
+
+class CAddonGUIWindow
+{
+friend class CAddonGUISpinControl;
+friend class CAddonGUIRadioButton;
+friend class CAddonGUIProgressControl;
+
+public:
+  CAddonGUIWindow(const char *xmlFilename, const char *defaultSkin, bool forceFallback, bool asDialog);
+  ~CAddonGUIWindow();
+
+  virtual bool         Show();
+  virtual void         Close();
+  virtual void         DoModal();
+  virtual bool         SetFocusId(int iControlId);
+  virtual int          GetFocusId();
+  virtual bool         SetCoordinateResolution(int res);
+  virtual void         SetProperty(const char *key, const char *value);
+  virtual void         SetPropertyInt(const char *key, int value);
+  virtual void         SetPropertyBool(const char *key, bool value);
+  virtual void         SetPropertyDouble(const char *key, double value);
+  virtual const char  *GetProperty(const char *key) const;
+  virtual int          GetPropertyInt(const char *key) const;
+  virtual bool         GetPropertyBool(const char *key) const;
+  virtual double       GetPropertyDouble(const char *key) const;
+  virtual void         ClearProperties();
+  virtual int          GetListSize();
+  virtual void         ClearList();
+  virtual GUIHANDLE    AddStringItem(const char *name, int itemPosition = -1);
+  virtual void         AddItem(GUIHANDLE item, int itemPosition = -1);
+  virtual void         AddItem(CAddonListItem *item, int itemPosition = -1);
+  virtual void         RemoveItem(int itemPosition);
+  virtual GUIHANDLE    GetListItem(int listPos);
+  virtual void         SetCurrentListPosition(int listPos);
+  virtual int          GetCurrentListPosition();
+  virtual void         SetControlLabel(int controlId, const char *label);
+
+  virtual bool         OnClick(int controlId);
+  virtual bool         OnFocus(int controlId);
+  virtual bool         OnInit();
+  virtual bool         OnAction(int actionId);
+
+  GUIHANDLE m_cbhdl;
+  bool (*CBOnInit)(GUIHANDLE cbhdl);
+  bool (*CBOnFocus)(GUIHANDLE cbhdl, int controlId);
+  bool (*CBOnClick)(GUIHANDLE cbhdl, int controlId);
+  bool (*CBOnAction)(GUIHANDLE cbhdl, int actionId);
+
+protected:
+  GUIHANDLE m_WindowHandle;
+};
+
diff --git a/addons/library.xbmc.pvr/libXBMC_pvr.h b/addons/library.xbmc.pvr/libXBMC_pvr.h
new file mode 100644
index 0000000..a485de3
--- /dev/null
+++ b/addons/library.xbmc.pvr/libXBMC_pvr.h
@@ -0,0 +1,170 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2010 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include <string>
+#include <vector>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include "xbmc_pvr_types.h"
+#include "../library.xbmc.addon/libXBMC_addon.h"
+
+#ifdef _WIN32
+#define PVR_HELPER_DLL "\\library.xbmc.pvr\\libXBMC_pvr" ADDON_HELPER_EXT
+#else
+#define PVR_HELPER_DLL "/library.xbmc.pvr/libXBMC_pvr-" ADDON_HELPER_ARCH "-" ADDON_HELPER_PLATFORM ADDON_HELPER_EXT
+#endif
+
+#define DVD_TIME_BASE 1000000
+#define DVD_NOPTS_VALUE    (-1LL<<52) // should be possible to represent in both double and __int64
+
+class CHelper_libXBMC_pvr
+{
+public:
+  CHelper_libXBMC_pvr()
+  {
+    m_libXBMC_pvr = NULL;
+    m_Handle      = NULL;
+  }
+
+  ~CHelper_libXBMC_pvr()
+  {
+    if (m_libXBMC_pvr)
+    {
+      PVR_unregister_me();
+      dlclose(m_libXBMC_pvr);
+    }
+  }
+
+  bool RegisterMe(void *Handle)
+  {
+    m_Handle = Handle;
+
+    std::string libBasePath;
+    libBasePath  = ((cb_array*)m_Handle)->libPath;
+    libBasePath += PVR_HELPER_DLL;
+
+    m_libXBMC_pvr = dlopen(libBasePath.c_str(), RTLD_LAZY);
+    if (m_libXBMC_pvr == NULL)
+    {
+      fprintf(stderr, "Unable to load %s\n", dlerror());
+      return false;
+    }
+
+    PVR_register_me         = (int (*)(void *HANDLE))
+      dlsym(m_libXBMC_pvr, "PVR_register_me");
+    if (PVR_register_me == NULL)      { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    PVR_unregister_me       = (void (*)())
+      dlsym(m_libXBMC_pvr, "PVR_unregister_me");
+    if (PVR_unregister_me == NULL)    { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    TransferEpgEntry        = (void (*)(const ADDON_HANDLE handle, const EPG_TAG *epgentry))
+      dlsym(m_libXBMC_pvr, "PVR_transfer_epg_entry");
+    if (TransferEpgEntry == NULL)       { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    TransferChannelEntry    = (void (*)(const ADDON_HANDLE handle, const PVR_CHANNEL *chan))
+      dlsym(m_libXBMC_pvr, "PVR_transfer_channel_entry");
+    if (TransferChannelEntry == NULL)   { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    TransferTimerEntry      = (void (*)(const ADDON_HANDLE handle, const PVR_TIMER *timer))
+      dlsym(m_libXBMC_pvr, "PVR_transfer_timer_entry");
+    if (TransferTimerEntry == NULL)     { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    TransferRecordingEntry  = (void (*)(const ADDON_HANDLE handle, const PVR_RECORDING *recording))
+      dlsym(m_libXBMC_pvr, "PVR_transfer_recording_entry");
+    if (TransferRecordingEntry == NULL) { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    AddMenuHook             = (void (*)(PVR_MENUHOOK *hook))
+      dlsym(m_libXBMC_pvr, "PVR_add_menu_hook");
+    if (AddMenuHook == NULL)            { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    Recording               = (void (*)(const char *Name, const char *FileName, bool On))
+      dlsym(m_libXBMC_pvr, "PVR_recording");
+    if (Recording == NULL)              { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    TriggerTimerUpdate      = (void (*)())
+      dlsym(m_libXBMC_pvr, "PVR_trigger_timer_update");
+    if (TriggerTimerUpdate == NULL)     { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    TriggerRecordingUpdate  = (void (*)())
+      dlsym(m_libXBMC_pvr, "PVR_trigger_recording_update");
+    if (TriggerRecordingUpdate == NULL) { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    TriggerChannelUpdate  = (void (*)())
+      dlsym(m_libXBMC_pvr, "PVR_trigger_channel_update");
+    if (TriggerChannelUpdate == NULL) { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    TriggerChannelGroupsUpdate  = (void (*)())
+      dlsym(m_libXBMC_pvr, "PVR_trigger_channel_groups_update");
+    if (TriggerChannelGroupsUpdate == NULL) { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    TransferChannelGroup  = (void (*)(const ADDON_HANDLE handle, const PVR_CHANNEL_GROUP *group))
+      dlsym(m_libXBMC_pvr, "PVR_transfer_channel_group");
+    if (TransferChannelGroup == NULL) { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    TransferChannelGroupMember  = (void (*)(const ADDON_HANDLE handle, const PVR_CHANNEL_GROUP_MEMBER *member))
+      dlsym(m_libXBMC_pvr, "PVR_transfer_channel_group_member");
+    if (TransferChannelGroupMember == NULL) { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+#ifdef USE_DEMUX
+    FreeDemuxPacket         = (void (*)(DemuxPacket* pPacket))
+      dlsym(m_libXBMC_pvr, "PVR_free_demux_packet");
+    if (FreeDemuxPacket == NULL)        { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+
+    AllocateDemuxPacket     = (DemuxPacket* (*)(int iDataSize))
+      dlsym(m_libXBMC_pvr, "PVR_allocate_demux_packet");
+    if (AllocateDemuxPacket == NULL)    { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
+#endif
+
+    return PVR_register_me(m_Handle) > 0;
+  }
+
+  void (*TransferEpgEntry)(const ADDON_HANDLE handle, const EPG_TAG *epgentry);
+  void (*TransferChannelEntry)(const ADDON_HANDLE handle, const PVR_CHANNEL *chan);
+  void (*TransferTimerEntry)(const ADDON_HANDLE handle, const PVR_TIMER *timer);
+  void (*TransferRecordingEntry)(const ADDON_HANDLE handle, const PVR_RECORDING *recording);
+  void (*AddMenuHook)(PVR_MENUHOOK *hook);
+  void (*Recording)(const char *Name, const char *FileName, bool On);
+  void (*TriggerTimerUpdate)();
+  void (*TriggerRecordingUpdate)();
+  void (*TriggerChannelUpdate)();
+  void (*TriggerChannelGroupsUpdate)();
+  void (*TransferChannelGroup)(const ADDON_HANDLE handle, const PVR_CHANNEL_GROUP *group);
+  void (*TransferChannelGroupMember)(const ADDON_HANDLE handle, const PVR_CHANNEL_GROUP_MEMBER *member);
+#ifdef USE_DEMUX
+  void (*FreeDemuxPacket)(DemuxPacket* pPacket);
+  DemuxPacket* (*AllocateDemuxPacket)(int iDataSize);
+#endif
+
+protected:
+  int (*PVR_register_me)(void *HANDLE);
+  void (*PVR_unregister_me)();
+
+private:
+  void *m_libXBMC_pvr;
+  void *m_Handle;
+  struct cb_array
+  {
+    const char* libPath;
+  };
+};
diff --git a/lib/addons/library.xbmc.addon/libXBMC_addon.cpp b/lib/addons/library.xbmc.addon/libXBMC_addon.cpp
new file mode 100644
index 0000000..8d8f026
--- /dev/null
+++ b/lib/addons/library.xbmc.addon/libXBMC_addon.cpp
@@ -0,0 +1,128 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string>
+#include "../../../addons/library.xbmc.addon/libXBMC_addon.h"
+#include "../../../xbmc/addons/AddonCallbacks.h"
+
+#ifdef _WIN32
+#include <windows.h>
+#define DLLEXPORT __declspec(dllexport)
+#else
+#define DLLEXPORT
+#endif
+
+
+using namespace std;
+using namespace ADDON;
+
+AddonCB *m_Handle = NULL;
+CB_AddOnLib *m_cb = NULL;
+
+extern "C"
+{
+
+DLLEXPORT int XBMC_register_me(void *hdl)
+{
+  if (!hdl)
+    fprintf(stderr, "libXBMC_addon-ERROR: XBMC_register_me is called with NULL handle !!!\n");
+  else
+  {
+    m_Handle = (AddonCB*) hdl;
+    m_cb     = m_Handle->AddOnLib_RegisterMe(m_Handle->addonData);
+    if (!m_cb)
+      fprintf(stderr, "libXBMC_addon-ERROR: XBMC_register_me can't get callback table from XBMC !!!\n");
+    else
+      return 1;
+  }
+  return 0;
+}
+
+DLLEXPORT void XBMC_unregister_me()
+{
+  if (m_Handle && m_cb)
+    m_Handle->AddOnLib_UnRegisterMe(m_Handle->addonData, m_cb);
+}
+
+DLLEXPORT void XBMC_log(const addon_log_t loglevel, const char *format, ... )
+{
+  if (m_cb == NULL)
+    return;
+
+  char buffer[16384];
+  va_list args;
+  va_start (args, format);
+  vsprintf (buffer, format, args);
+  va_end (args);
+  m_cb->Log(m_Handle->addonData, loglevel, buffer);
+}
+
+DLLEXPORT bool XBMC_get_setting(const char* settingName, void *settingValue)
+{
+  if (m_cb == NULL)
+    return false;
+
+  return m_cb->GetSetting(m_Handle->addonData, settingName, settingValue);
+}
+
+DLLEXPORT void XBMC_queue_notification(const queue_msg_t type, const char *format, ... )
+{
+  if (m_cb == NULL)
+    return;
+
+  char buffer[16384];
+  va_list args;
+  va_start (args, format);
+  vsprintf (buffer, format, args);
+  va_end (args);
+  m_cb->QueueNotification(m_Handle->addonData, type, buffer);
+}
+
+DLLEXPORT void XBMC_unknown_to_utf8(string &str)
+{
+  if (m_cb == NULL)
+    return;
+
+  string buffer = m_cb->UnknownToUTF8(str.c_str());
+  str = buffer;
+}
+
+DLLEXPORT const char* XBMC_get_localized_string(int dwCode)
+{
+  if (m_cb == NULL)
+    return "";
+
+  return m_cb->GetLocalizedString(m_Handle->addonData, dwCode);
+}
+
+DLLEXPORT const char* XBMC_get_dvd_menu_language()
+{
+  if (m_cb == NULL)
+    return "";
+
+  string buffer = m_cb->GetDVDMenuLanguage(m_Handle->addonData);
+  return buffer.c_str();
+}
+
+};
diff --git a/lib/addons/library.xbmc.gui/libXBMC_gui.cpp b/lib/addons/library.xbmc.gui/libXBMC_gui.cpp
new file mode 100644
index 0000000..752c248
--- /dev/null
+++ b/lib/addons/library.xbmc.gui/libXBMC_gui.cpp
@@ -0,0 +1,555 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string>
+#include "../../../addons/library.xbmc.gui/libXBMC_gui.h"
+#include "addons/AddonCallbacks.h"
+
+#ifdef _WIN32
+#include <windows.h>
+#define DLLEXPORT __declspec(dllexport)
+#else
+#define DLLEXPORT
+#endif
+
+using namespace std;
+
+AddonCB *m_Handle = NULL;
+CB_GUILib *m_cb   = NULL;
+
+extern "C"
+{
+
+DLLEXPORT int GUI_register_me(void *hdl)
+{
+  if (!hdl)
+    fprintf(stderr, "libXBMC_gui-ERROR: GUILib_register_me is called with NULL handle !!!\n");
+  else
+  {
+    m_Handle = (AddonCB*) hdl;
+    m_cb     = m_Handle->GUILib_RegisterMe(m_Handle->addonData);
+    if (!m_cb)
+      fprintf(stderr, "libXBMC_gui-ERROR: GUILib_register_me can't get callback table from XBMC !!!\n");
+    else
+      return 1;
+  }
+  return 0;
+}
+
+DLLEXPORT void GUI_unregister_me()
+{
+  if (m_Handle && m_cb)
+    m_Handle->GUILib_UnRegisterMe(m_Handle->addonData, m_cb);
+}
+
+DLLEXPORT void GUI_lock()
+{
+  m_cb->Lock();
+}
+
+DLLEXPORT void GUI_unlock()
+{
+  m_cb->Unlock();
+}
+
+DLLEXPORT int GUI_get_screen_height()
+{
+  return m_cb->GetScreenHeight();
+}
+
+DLLEXPORT int GUI_get_screen_width()
+{
+  return m_cb->GetScreenWidth();
+}
+
+DLLEXPORT int GUI_get_video_resolution()
+{
+  return m_cb->GetVideoResolution();
+}
+
+DLLEXPORT CAddonGUIWindow* GUI_Window_create(const char *xmlFilename, const char *defaultSkin, bool forceFallback, bool asDialog)
+{
+  return new CAddonGUIWindow(xmlFilename, defaultSkin, forceFallback, asDialog);
+}
+
+DLLEXPORT void GUI_Window_destroy(CAddonGUIWindow* p)
+{
+  delete p;
+}
+
+DLLEXPORT bool GUI_Window_OnClick(GUIHANDLE handle, int controlId)
+{
+  CAddonGUIWindow *window = (CAddonGUIWindow*) handle;
+  return window->OnClick(controlId);
+}
+
+DLLEXPORT bool GUI_Window_OnFocus(GUIHANDLE handle, int controlId)
+{
+  CAddonGUIWindow *window = (CAddonGUIWindow*) handle;
+  return window->OnFocus(controlId);
+}
+
+DLLEXPORT bool GUI_Window_OnInit(GUIHANDLE handle)
+{
+  CAddonGUIWindow *window = (CAddonGUIWindow*) handle;
+  return window->OnInit();
+}
+
+DLLEXPORT bool GUI_Window_OnAction(GUIHANDLE handle, int actionId)
+{
+  CAddonGUIWindow *window = (CAddonGUIWindow*) handle;
+  return window->OnAction(actionId);
+}
+
+
+CAddonGUIWindow::CAddonGUIWindow(const char *xmlFilename, const char *defaultSkin, bool forceFallback, bool asDialog)
+{
+  CBOnInit = NULL;
+  CBOnClick = NULL;
+  CBOnFocus = NULL;
+  if (m_Handle && m_cb)
+  {
+    m_WindowHandle = m_cb->Window_New(m_Handle->addonData, xmlFilename, defaultSkin, forceFallback, asDialog);
+    if (!m_WindowHandle)
+      fprintf(stderr, "libXBMC_gui-ERROR: cGUIWindow can't create window class from XBMC !!!\n");
+
+    m_cb->Window_SetCallbacks(m_Handle->addonData, m_WindowHandle, this, GUI_Window_OnInit, GUI_Window_OnClick, GUI_Window_OnFocus, GUI_Window_OnAction);
+  }
+}
+
+CAddonGUIWindow::~CAddonGUIWindow()
+{
+  if (m_Handle && m_cb && m_WindowHandle)
+  {
+    m_cb->Window_Delete(m_Handle->addonData, m_WindowHandle);
+    m_WindowHandle = NULL;
+  }
+}
+
+bool CAddonGUIWindow::Show()
+{
+  return m_cb->Window_Show(m_Handle->addonData, m_WindowHandle);
+}
+
+void CAddonGUIWindow::Close()
+{
+  m_cb->Window_Close(m_Handle->addonData, m_WindowHandle);
+}
+
+void CAddonGUIWindow::DoModal()
+{
+  m_cb->Window_DoModal(m_Handle->addonData, m_WindowHandle);
+}
+
+bool CAddonGUIWindow::OnInit()
+{
+  if (!CBOnInit)
+    return false;
+
+  return CBOnInit(m_cbhdl);
+}
+
+bool CAddonGUIWindow::OnClick(int controlId)
+{
+  if (!CBOnClick)
+    return false;
+
+  return CBOnClick(m_cbhdl, controlId);
+}
+
+bool CAddonGUIWindow::OnFocus(int controlId)
+{
+  if (!CBOnFocus)
+    return false;
+
+  return CBOnFocus(m_cbhdl, controlId);
+}
+
+bool CAddonGUIWindow::OnAction(int actionId)
+{
+  if (!CBOnAction)
+    return false;
+
+  return CBOnAction(m_cbhdl, actionId);
+}
+
+bool CAddonGUIWindow::SetFocusId(int iControlId)
+{
+  return m_cb->Window_SetFocusId(m_Handle->addonData, m_WindowHandle, iControlId);
+}
+
+int CAddonGUIWindow::GetFocusId()
+{
+  return m_cb->Window_GetFocusId(m_Handle->addonData, m_WindowHandle);
+}
+
+bool CAddonGUIWindow::SetCoordinateResolution(int res)
+{
+  return m_cb->Window_SetCoordinateResolution(m_Handle->addonData, m_WindowHandle, res);
+}
+
+void CAddonGUIWindow::SetProperty(const char *key, const char *value)
+{
+  m_cb->Window_SetProperty(m_Handle->addonData, m_WindowHandle, key, value);
+}
+
+void CAddonGUIWindow::SetPropertyInt(const char *key, int value)
+{
+  m_cb->Window_SetPropertyInt(m_Handle->addonData, m_WindowHandle, key, value);
+}
+
+void CAddonGUIWindow::SetPropertyBool(const char *key, bool value)
+{
+  m_cb->Window_SetPropertyBool(m_Handle->addonData, m_WindowHandle, key, value);
+}
+
+void CAddonGUIWindow::SetPropertyDouble(const char *key, double value)
+{
+  m_cb->Window_SetPropertyDouble(m_Handle->addonData, m_WindowHandle, key, value);
+}
+
+const char *CAddonGUIWindow::GetProperty(const char *key) const
+{
+  return m_cb->Window_GetProperty(m_Handle->addonData, m_WindowHandle, key);
+}
+
+int CAddonGUIWindow::GetPropertyInt(const char *key) const
+{
+  return m_cb->Window_GetPropertyInt(m_Handle->addonData, m_WindowHandle, key);
+}
+
+bool CAddonGUIWindow::GetPropertyBool(const char *key) const
+{
+  return m_cb->Window_GetPropertyBool(m_Handle->addonData, m_WindowHandle, key);
+}
+
+double CAddonGUIWindow::GetPropertyDouble(const char *key) const
+{
+  return m_cb->Window_GetPropertyDouble(m_Handle->addonData, m_WindowHandle, key);
+}
+
+void CAddonGUIWindow::ClearProperties()
+{
+  m_cb->Window_ClearProperties(m_Handle->addonData, m_WindowHandle);
+}
+
+int CAddonGUIWindow::GetListSize()
+{
+  return m_cb->Window_GetListSize(m_Handle->addonData, m_WindowHandle);
+}
+
+void CAddonGUIWindow::ClearList()
+{
+  m_cb->Window_ClearList(m_Handle->addonData, m_WindowHandle);
+}
+
+GUIHANDLE CAddonGUIWindow::AddStringItem(const char *name, int itemPosition)
+{
+  return m_cb->Window_AddStringItem(m_Handle->addonData, m_WindowHandle, name, itemPosition);
+}
+
+void CAddonGUIWindow::AddItem(GUIHANDLE item, int itemPosition)
+{
+  m_cb->Window_AddItem(m_Handle->addonData, m_WindowHandle, item, itemPosition);
+}
+
+void CAddonGUIWindow::AddItem(CAddonListItem *item, int itemPosition)
+{
+  m_cb->Window_AddItem(m_Handle->addonData, m_WindowHandle, item->m_ListItemHandle, itemPosition);
+}
+
+void CAddonGUIWindow::RemoveItem(int itemPosition)
+{
+  m_cb->Window_RemoveItem(m_Handle->addonData, m_WindowHandle, itemPosition);
+}
+
+GUIHANDLE CAddonGUIWindow::GetListItem(int listPos)
+{
+  return m_cb->Window_GetListItem(m_Handle->addonData, m_WindowHandle, listPos);
+}
+
+void CAddonGUIWindow::SetCurrentListPosition(int listPos)
+{
+  m_cb->Window_SetCurrentListPosition(m_Handle->addonData, m_WindowHandle, listPos);
+}
+
+int CAddonGUIWindow::GetCurrentListPosition()
+{
+  return m_cb->Window_GetCurrentListPosition(m_Handle->addonData, m_WindowHandle);
+}
+
+void CAddonGUIWindow::SetControlLabel(int controlId, const char *label)
+{
+  m_cb->Window_SetControlLabel(m_Handle->addonData, m_WindowHandle, controlId, label);
+}
+
+///-------------------------------------
+/// cGUISpinControl
+
+DLLEXPORT CAddonGUISpinControl* GUI_control_get_spin(CAddonGUIWindow *window, int controlId)
+{
+  return new CAddonGUISpinControl(window, controlId);
+}
+
+DLLEXPORT void GUI_control_release_spin(CAddonGUISpinControl* p)
+{
+  delete p;
+}
+
+CAddonGUISpinControl::CAddonGUISpinControl(CAddonGUIWindow *window, int controlId)
+ : m_Window(window)
+ , m_ControlId(controlId)
+{
+  m_SpinHandle = m_cb->Window_GetControl_Spin(m_Handle->addonData, m_Window->m_WindowHandle, controlId);
+}
+
+void CAddonGUISpinControl::SetVisible(bool yesNo)
+{
+  if (m_SpinHandle)
+    m_cb->Control_Spin_SetVisible(m_Handle->addonData, m_SpinHandle, yesNo);
+}
+
+void CAddonGUISpinControl::SetText(const char *label)
+{
+  if (m_SpinHandle)
+    m_cb->Control_Spin_SetText(m_Handle->addonData, m_SpinHandle, label);
+}
+
+void CAddonGUISpinControl::Clear()
+{
+  if (m_SpinHandle)
+    m_cb->Control_Spin_Clear(m_Handle->addonData, m_SpinHandle);
+}
+
+void CAddonGUISpinControl::AddLabel(const char *label, int iValue)
+{
+  if (m_SpinHandle)
+    m_cb->Control_Spin_AddLabel(m_Handle->addonData, m_SpinHandle, label, iValue);
+}
+
+int CAddonGUISpinControl::GetValue()
+{
+  if (!m_SpinHandle)
+    return -1;
+
+  return m_cb->Control_Spin_GetValue(m_Handle->addonData, m_SpinHandle);
+}
+
+void CAddonGUISpinControl::SetValue(int iValue)
+{
+  if (m_SpinHandle)
+    m_cb->Control_Spin_SetValue(m_Handle->addonData, m_SpinHandle, iValue);
+}
+
+///-------------------------------------
+/// cGUIRadioButton
+
+DLLEXPORT CAddonGUIRadioButton* GUI_control_get_radiobutton(CAddonGUIWindow *window, int controlId)
+{
+  return new CAddonGUIRadioButton(window, controlId);
+}
+
+DLLEXPORT void GUI_control_release_radiobutton(CAddonGUIRadioButton* p)
+{
+  delete p;
+}
+
+CAddonGUIRadioButton::CAddonGUIRadioButton(CAddonGUIWindow *window, int controlId)
+ : m_Window(window)
+ , m_ControlId(controlId)
+{
+  m_ButtonHandle = m_cb->Window_GetControl_RadioButton(m_Handle->addonData, m_Window->m_WindowHandle, controlId);
+}
+
+void CAddonGUIRadioButton::SetVisible(bool yesNo)
+{
+  if (m_ButtonHandle)
+    m_cb->Control_RadioButton_SetVisible(m_Handle->addonData, m_ButtonHandle, yesNo);
+}
+
+void CAddonGUIRadioButton::SetText(const char *label)
+{
+  if (m_ButtonHandle)
+    m_cb->Control_RadioButton_SetText(m_Handle->addonData, m_ButtonHandle, label);
+}
+
+void CAddonGUIRadioButton::SetSelected(bool yesNo)
+{
+  if (m_ButtonHandle)
+    m_cb->Control_RadioButton_SetSelected(m_Handle->addonData, m_ButtonHandle, yesNo);
+}
+
+bool CAddonGUIRadioButton::IsSelected()
+{
+  if (!m_ButtonHandle)
+    return false;
+
+  return m_cb->Control_RadioButton_IsSelected(m_Handle->addonData, m_ButtonHandle);
+}
+
+
+///-------------------------------------
+/// cGUIProgressControl
+
+DLLEXPORT CAddonGUIProgressControl* GUI_control_get_progress(CAddonGUIWindow *window, int controlId)
+{
+  return new CAddonGUIProgressControl(window, controlId);
+}
+
+DLLEXPORT void GUI_control_release_progress(CAddonGUIProgressControl* p)
+{
+  delete p;
+}
+
+CAddonGUIProgressControl::CAddonGUIProgressControl(CAddonGUIWindow *window, int controlId)
+ : m_Window(window)
+ , m_ControlId(controlId)
+{
+  m_ProgressHandle = m_cb->Window_GetControl_Progress(m_Handle->addonData, m_Window->m_WindowHandle, controlId);
+}
+
+void CAddonGUIProgressControl::SetPercentage(float fPercent)
+{
+  if (m_ProgressHandle)
+    m_cb->Control_Progress_SetPercentage(m_Handle->addonData, m_ProgressHandle, fPercent);
+}
+
+float CAddonGUIProgressControl::GetPercentage() const
+{
+  if (!m_ProgressHandle)
+    return 0.0;
+
+  return m_cb->Control_Progress_GetPercentage(m_Handle->addonData, m_ProgressHandle);
+}
+
+void CAddonGUIProgressControl::SetInfo(int iInfo)
+{
+  if (m_ProgressHandle)
+    m_cb->Control_Progress_SetInfo(m_Handle->addonData, m_ProgressHandle, iInfo);
+}
+
+int CAddonGUIProgressControl::GetInfo() const
+{
+  if (!m_ProgressHandle)
+    return -1;
+
+  return m_cb->Control_Progress_GetInfo(m_Handle->addonData, m_ProgressHandle);
+}
+
+string CAddonGUIProgressControl::GetDescription() const
+{
+  if (!m_ProgressHandle)
+    return "";
+
+  return m_cb->Control_Progress_GetDescription(m_Handle->addonData, m_ProgressHandle);
+}
+
+
+///-------------------------------------
+/// cListItem
+
+DLLEXPORT CAddonListItem* GUI_ListItem_create(const char *label, const char *label2, const char *iconImage, const char *thumbnailImage, const char *path)
+{
+  return new CAddonListItem(label, label2, iconImage, thumbnailImage, path);
+}
+
+DLLEXPORT void GUI_ListItem_destroy(CAddonListItem* p)
+{
+  delete p;
+}
+
+
+CAddonListItem::CAddonListItem(const char *label, const char *label2, const char *iconImage, const char *thumbnailImage, const char *path)
+{
+  m_ListItemHandle = m_cb->ListItem_Create(m_Handle->addonData, label, label2, iconImage, thumbnailImage, path);
+}
+
+const char *CAddonListItem::GetLabel()
+{
+  if (!m_ListItemHandle)
+    return "";
+
+  return m_cb->ListItem_GetLabel(m_Handle->addonData, m_ListItemHandle);
+}
+
+void CAddonListItem::SetLabel(const char *label)
+{
+  if (m_ListItemHandle)
+    m_cb->ListItem_SetLabel(m_Handle->addonData, m_ListItemHandle, label);
+}
+
+const char *CAddonListItem::GetLabel2()
+{
+  if (!m_ListItemHandle)
+    return "";
+
+  return m_cb->ListItem_GetLabel2(m_Handle->addonData, m_ListItemHandle);
+}
+
+void CAddonListItem::SetLabel2(const char *label)
+{
+  if (m_ListItemHandle)
+    m_cb->ListItem_SetLabel2(m_Handle->addonData, m_ListItemHandle, label);
+}
+
+void CAddonListItem::SetIconImage(const char *image)
+{
+  if (m_ListItemHandle)
+    m_cb->ListItem_SetIconImage(m_Handle->addonData, m_ListItemHandle, image);
+}
+
+void CAddonListItem::SetThumbnailImage(const char *image)
+{
+  if (m_ListItemHandle)
+    m_cb->ListItem_SetThumbnailImage(m_Handle->addonData, m_ListItemHandle, image);
+}
+
+void CAddonListItem::SetInfo(const char *Info)
+{
+  if (m_ListItemHandle)
+    m_cb->ListItem_SetInfo(m_Handle->addonData, m_ListItemHandle, Info);
+}
+
+void CAddonListItem::SetProperty(const char *key, const char *value)
+{
+  if (m_ListItemHandle)
+    m_cb->ListItem_SetProperty(m_Handle->addonData, m_ListItemHandle, key, value);
+}
+
+const char *CAddonListItem::GetProperty(const char *key) const
+{
+  if (!m_ListItemHandle)
+    return "";
+
+  return m_cb->ListItem_GetProperty(m_Handle->addonData, m_ListItemHandle, key);
+}
+
+void CAddonListItem::SetPath(const char *Path)
+{
+  if (m_ListItemHandle)
+    m_cb->ListItem_SetPath(m_Handle->addonData, m_ListItemHandle, Path);
+}
+
+
+};
diff --git a/lib/addons/library.xbmc.pvr/libXBMC_pvr.cpp b/lib/addons/library.xbmc.pvr/libXBMC_pvr.cpp
new file mode 100644
index 0000000..8ef4b59
--- /dev/null
+++ b/lib/addons/library.xbmc.pvr/libXBMC_pvr.cpp
@@ -0,0 +1,181 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#define USE_DEMUX // enable including of the demuxer packet structure
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string>
+#include "../../../addons/library.xbmc.pvr/libXBMC_pvr.h"
+#include "addons/AddonCallbacks.h"
+#include "cores/dvdplayer/DVDDemuxers/DVDDemuxPacket.h"
+
+#ifdef _WIN32
+#include <windows.h>
+#define DLLEXPORT __declspec(dllexport)
+#else
+#define DLLEXPORT
+#endif
+
+using namespace std;
+
+AddonCB *m_Handle = NULL;
+CB_PVRLib *m_cb   = NULL;
+
+extern "C"
+{
+
+DLLEXPORT int PVR_register_me(void *hdl)
+{
+  if (!hdl)
+    fprintf(stderr, "libXBMC_pvr-ERROR: PVRLib_register_me is called with NULL handle !!!\n");
+  else
+  {
+    m_Handle = (AddonCB*) hdl;
+    m_cb     = m_Handle->PVRLib_RegisterMe(m_Handle->addonData);
+    if (!m_cb)
+      fprintf(stderr, "libXBMC_pvr-ERROR: PVRLib_register_me can't get callback table from XBMC !!!\n");
+    else
+      return 1;
+  }
+  return 0;
+}
+
+DLLEXPORT void PVR_unregister_me()
+{
+  if (m_Handle && m_cb)
+    m_Handle->PVRLib_UnRegisterMe(m_Handle->addonData, m_cb);
+}
+
+DLLEXPORT void PVR_transfer_epg_entry(const ADDON_HANDLE handle, const EPG_TAG *epgentry)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TransferEpgEntry(m_Handle->addonData, handle, epgentry);
+}
+
+DLLEXPORT void PVR_transfer_channel_entry(const ADDON_HANDLE handle, const PVR_CHANNEL *chan)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TransferChannelEntry(m_Handle->addonData, handle, chan);
+}
+
+DLLEXPORT void PVR_transfer_timer_entry(const ADDON_HANDLE handle, const PVR_TIMER *timer)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TransferTimerEntry(m_Handle->addonData, handle, timer);
+}
+
+DLLEXPORT void PVR_transfer_recording_entry(const ADDON_HANDLE handle, const PVR_RECORDING *recording)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TransferRecordingEntry(m_Handle->addonData, handle, recording);
+}
+
+DLLEXPORT void PVR_add_menu_hook(PVR_MENUHOOK *hook)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->AddMenuHook(m_Handle->addonData, hook);
+}
+
+DLLEXPORT void PVR_recording(const char *Name, const char *FileName, bool On)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->Recording(m_Handle->addonData, Name, FileName, On);
+}
+
+DLLEXPORT void PVR_trigger_channel_update()
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TriggerChannelUpdate(m_Handle->addonData);
+}
+
+DLLEXPORT void PVR_trigger_channel_groups_update()
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TriggerChannelGroupsUpdate(m_Handle->addonData);
+}
+
+DLLEXPORT void PVR_trigger_timer_update()
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TriggerTimerUpdate(m_Handle->addonData);
+}
+
+DLLEXPORT void PVR_trigger_recording_update()
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TriggerRecordingUpdate(m_Handle->addonData);
+}
+
+DLLEXPORT void PVR_free_demux_packet(DemuxPacket* pPacket)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->FreeDemuxPacket(m_Handle->addonData, pPacket);
+}
+
+DLLEXPORT DemuxPacket* PVR_allocate_demux_packet(int iDataSize)
+{
+  if (m_cb == NULL)
+    return NULL;
+
+  return m_cb->AllocateDemuxPacket(m_Handle->addonData, iDataSize);
+}
+
+DLLEXPORT void PVR_transfer_channel_group(const ADDON_HANDLE handle, const PVR_CHANNEL_GROUP *group)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TransferChannelGroup(m_Handle->addonData, handle, group);
+}
+
+DLLEXPORT void PVR_transfer_channel_group_member(const ADDON_HANDLE handle, const PVR_CHANNEL_GROUP_MEMBER *member)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TransferChannelGroupMember(m_Handle->addonData, handle, member);
+}
+
+};
diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 861d0d1..93f76a1 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -1,326 +1,345 @@
 /*
  *      Copyright (C) 2005-2008 Team XBMC
  *      http://xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2, or (at your option)
  *  any later version.
  *
  *  This Program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with XBMC; see the file COPYING.  If not, write to
  *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
  *  http://www.gnu.org/copyleft/gpl.html
  *
  */
 
 #include "threads/SystemClock.h"
 #include "system.h"
 #include "Application.h"
 #include "interfaces/Builtins.h"
 #include "utils/Variant.h"
 #include "utils/Splash.h"
 #include "LangInfo.h"
 #include "Util.h"
 #include "URL.h"
 #include "guilib/TextureManager.h"
 #include "cores/dvdplayer/DVDFileInfo.h"
 #include "cores/AudioEngine/AEFactory.h"
 #include "cores/AudioEngine/Utils/AEUtil.h"
 #include "PlayListPlayer.h"
 #include "Autorun.h"
 #include "video/Bookmark.h"
 #ifdef HAS_WEB_SERVER
 #include "network/WebServer.h"
 #include "network/httprequesthandler/HTTPImageHandler.h"
 #include "network/httprequesthandler/HTTPVfsHandler.h"
 #ifdef HAS_HTTPAPI
 #include "network/httprequesthandler/HTTPApiHandler.h"
 #endif
 #ifdef HAS_JSONRPC
 #include "network/httprequesthandler/HTTPJsonRpcHandler.h"
 #endif
 #ifdef HAS_WEB_INTERFACE
 #include "network/httprequesthandler/HTTPWebinterfaceHandler.h"
 #include "network/httprequesthandler/HTTPWebinterfaceAddonsHandler.h"
 #endif
 #endif
 #ifdef HAS_LCD
 #include "utils/LCDFactory.h"
 #endif
 #include "guilib/GUIControlProfiler.h"
 #include "utils/LangCodeExpander.h"
 #include "GUIInfoManager.h"
 #include "playlists/PlayListFactory.h"
 #include "guilib/GUIFontManager.h"
 #include "guilib/GUIColorManager.h"
 #include "guilib/GUITextLayout.h"
 #include "addons/Skin.h"
 #ifdef HAS_PYTHON
 #include "interfaces/python/XBPython.h"
 #endif
 #include "input/ButtonTranslator.h"
 #include "guilib/GUIAudioManager.h"
 #include "network/libscrobbler/lastfmscrobbler.h"
 #include "network/libscrobbler/librefmscrobbler.h"
 #include "GUIPassword.h"
 #include "input/InertialScrollingHandler.h"
 #include "ApplicationMessenger.h"
 #include "SectionLoader.h"
 #include "cores/DllLoader/DllLoaderContainer.h"
 #include "GUIUserMessages.h"
 #include "filesystem/DirectoryCache.h"
 #include "filesystem/StackDirectory.h"
 #include "filesystem/SpecialProtocol.h"
 #include "filesystem/DllLibCurl.h"
 #include "filesystem/MythSession.h"
 #include "filesystem/PluginDirectory.h"
 #ifdef HAS_FILESYSTEM_SAP
 #include "filesystem/SAPDirectory.h"
 #endif
 #ifdef HAS_FILESYSTEM_HTSP
 #include "filesystem/HTSPDirectory.h"
 #endif
 #include "utils/TuxBoxUtil.h"
 #include "utils/SystemInfo.h"
 #include "utils/TimeUtils.h"
 #include "GUILargeTextureManager.h"
 #include "TextureCache.h"
 #include "music/LastFmManager.h"
 #include "playlists/SmartPlayList.h"
 #ifdef HAS_FILESYSTEM_RAR
 #include "filesystem/RarManager.h"
 #endif
 #include "playlists/PlayList.h"
 #include "windowing/WindowingFactory.h"
 #include "powermanagement/PowerManager.h"
 #include "powermanagement/DPMSSupport.h"
 #include "settings/Settings.h"
 #include "settings/AdvancedSettings.h"
 #include "guilib/LocalizeStrings.h"
 #include "utils/CPUInfo.h"
 #include "utils/SeekHandler.h"
 
 #include "input/KeyboardStat.h"
 #include "input/XBMC_vkeys.h"
 #include "input/MouseStat.h"
 
 #ifdef HAS_SDL
 #include <SDL/SDL.h>
 #endif
 
 #if defined(FILESYSTEM) && !defined(_LINUX)
 #include "filesystem/FileDAAP.h"
 #endif
 #ifdef HAS_UPNP
 #include "network/UPnP.h"
 #include "filesystem/UPnPDirectory.h"
 #endif
 #if defined(_LINUX) && defined(HAS_FILESYSTEM_SMB)
 #include "filesystem/SMBDirectory.h"
 #endif
 #ifdef HAS_FILESYSTEM_NFS
 #include "filesystem/NFSFile.h"
 #endif
 #ifdef HAS_FILESYSTEM_AFP
 #include "filesystem/AFPFile.h"
 #endif
 #ifdef HAS_FILESYSTEM_SFTP
 #include "filesystem/SFTPFile.h"
 #endif
 #include "PartyModeManager.h"
 #ifdef HAS_VIDEO_PLAYBACK
 #include "cores/VideoRenderers/RenderManager.h"
 #endif
 #ifdef HAS_KARAOKE
 #include "music/karaoke/karaokelyricsmanager.h"
 #include "music/karaoke/GUIDialogKaraokeSongSelector.h"
 #include "music/karaoke/GUIWindowKaraokeLyrics.h"
 #endif
 #include "network/Network.h"
 #include "network/Zeroconf.h"
 #include "network/ZeroconfBrowser.h"
 #ifndef _LINUX
 #include "threads/platform/win/Win32Exception.h"
 #endif
 #ifdef HAS_EVENT_SERVER
 #include "network/EventServer.h"
 #endif
 #ifdef HAS_JSONRPC
 #include "interfaces/json-rpc/InputOperations.h"
 #endif
 #ifdef HAS_DBUS
 #include <dbus/dbus.h>
 #endif
 #ifdef HAS_HTTPAPI
 #include "interfaces/http-api/XBMChttp.h"
 #endif
 #ifdef HAS_JSONRPC
 #include "interfaces/json-rpc/JSONRPC.h"
 #include "network/TCPServer.h"
 #endif
 #ifdef HAS_AIRPLAY
 #include "network/AirPlayServer.h"
 #endif
 #ifdef HAS_AIRTUNES
 #include "network/AirTunesServer.h"
 #endif
 #if defined(HAVE_LIBCRYSTALHD)
 #include "cores/dvdplayer/DVDCodecs/Video/CrystalHD.h"
 #endif
 #include "interfaces/AnnouncementManager.h"
 #include "peripherals/Peripherals.h"
 #include "peripherals/dialogs/GUIDialogPeripheralManager.h"
 #include "peripherals/dialogs/GUIDialogPeripheralSettings.h"
 
 // Windows includes
 #include "guilib/GUIWindowManager.h"
 #include "windows/GUIWindowHome.h"
 #include "guilib/GUIStandardWindow.h"
 #include "settings/GUIWindowSettings.h"
 #include "windows/GUIWindowFileManager.h"
 #include "settings/GUIWindowSettingsCategory.h"
 #include "music/windows/GUIWindowMusicPlaylist.h"
 #include "music/windows/GUIWindowMusicSongs.h"
 #include "music/windows/GUIWindowMusicNav.h"
 #include "music/windows/GUIWindowMusicPlaylistEditor.h"
 #include "video/windows/GUIWindowVideoPlaylist.h"
 #include "music/dialogs/GUIDialogMusicInfo.h"
 #include "video/dialogs/GUIDialogVideoInfo.h"
 #include "video/windows/GUIWindowVideoNav.h"
 #include "settings/GUIWindowSettingsProfile.h"
 #ifdef HAS_GL
 #include "rendering/gl/GUIWindowTestPatternGL.h"
 #endif
 #ifdef HAS_DX
 #include "rendering/dx/GUIWindowTestPatternDX.h"
 #endif
 #include "settings/GUIWindowSettingsScreenCalibration.h"
 #include "programs/GUIWindowPrograms.h"
 #include "pictures/GUIWindowPictures.h"
 #include "windows/GUIWindowWeather.h"
 #include "windows/GUIWindowLoginScreen.h"
 #include "addons/GUIWindowAddonBrowser.h"
 #include "music/windows/GUIWindowVisualisation.h"
 #include "windows/GUIWindowDebugInfo.h"
 #include "windows/GUIWindowPointer.h"
 #include "windows/GUIWindowSystemInfo.h"
 #include "windows/GUIWindowScreensaver.h"
 #include "windows/GUIWindowScreensaverDim.h"
 #include "pictures/GUIWindowSlideShow.h"
 #include "windows/GUIWindowStartup.h"
 #include "video/windows/GUIWindowFullScreen.h"
 #include "video/dialogs/GUIDialogVideoOSD.h"
 #include "music/dialogs/GUIDialogMusicOverlay.h"
 #include "video/dialogs/GUIDialogVideoOverlay.h"
 
 // Dialog includes
 #include "music/dialogs/GUIDialogMusicOSD.h"
 #include "music/dialogs/GUIDialogVisualisationPresetList.h"
 #include "dialogs/GUIDialogTextViewer.h"
 #include "network/GUIDialogNetworkSetup.h"
 #include "dialogs/GUIDialogMediaSource.h"
 #include "video/dialogs/GUIDialogVideoSettings.h"
 #include "video/dialogs/GUIDialogAudioSubtitleSettings.h"
 #include "video/dialogs/GUIDialogVideoBookmarks.h"
 #include "settings/GUIDialogProfileSettings.h"
 #include "settings/GUIDialogLockSettings.h"
 #include "settings/GUIDialogContentSettings.h"
 #include "video/dialogs/GUIDialogVideoScan.h"
 #include "dialogs/GUIDialogBusy.h"
 #include "dialogs/GUIDialogKeyboardGeneric.h"
 #include "dialogs/GUIDialogYesNo.h"
 #include "dialogs/GUIDialogOK.h"
 #include "dialogs/GUIDialogProgress.h"
+#include "dialogs/GUIDialogExtendedProgressBar.h"
 #include "dialogs/GUIDialogSelect.h"
 #include "dialogs/GUIDialogSeekBar.h"
 #include "dialogs/GUIDialogKaiToast.h"
 #include "dialogs/GUIDialogVolumeBar.h"
 #include "dialogs/GUIDialogMuteBug.h"
 #include "video/dialogs/GUIDialogFileStacking.h"
 #include "dialogs/GUIDialogNumeric.h"
 #include "dialogs/GUIDialogGamepad.h"
 #include "dialogs/GUIDialogSubMenu.h"
 #include "dialogs/GUIDialogFavourites.h"
 #include "dialogs/GUIDialogButtonMenu.h"
 #include "dialogs/GUIDialogContextMenu.h"
 #include "music/dialogs/GUIDialogMusicScan.h"
 #include "dialogs/GUIDialogPlayerControls.h"
 #include "music/dialogs/GUIDialogSongInfo.h"
 #include "dialogs/GUIDialogSmartPlaylistEditor.h"
 #include "dialogs/GUIDialogSmartPlaylistRule.h"
 #include "pictures/GUIDialogPictureInfo.h"
 #include "addons/GUIDialogAddonSettings.h"
 #include "addons/GUIDialogAddonInfo.h"
 #ifdef HAS_LINUX_NETWORK
 #include "network/GUIDialogAccessPoints.h"
 #endif
+
+/* PVR related include Files */
+#include "pvr/PVRManager.h"
+#include "pvr/timers/PVRTimers.h"
+#include "pvr/windows/GUIWindowPVR.h"
+#include "pvr/dialogs/GUIDialogPVRChannelManager.h"
+#include "pvr/dialogs/GUIDialogPVRChannelsOSD.h"
+#include "pvr/dialogs/GUIDialogPVRCutterOSD.h"
+#include "pvr/dialogs/GUIDialogPVRDirectorOSD.h"
+#include "pvr/dialogs/GUIDialogPVRGroupManager.h"
+#include "pvr/dialogs/GUIDialogPVRGuideInfo.h"
+#include "pvr/dialogs/GUIDialogPVRGuideOSD.h"
+#include "pvr/dialogs/GUIDialogPVRGuideSearch.h"
+#include "pvr/dialogs/GUIDialogPVRRecordingInfo.h"
+#include "pvr/dialogs/GUIDialogPVRTimerSettings.h"
+
+#include "epg/EpgContainer.h"
+
 #include "video/dialogs/GUIDialogFullScreenInfo.h"
 #include "video/dialogs/GUIDialogTeletext.h"
 #include "dialogs/GUIDialogSlider.h"
 #include "guilib/GUIControlFactory.h"
 #include "dialogs/GUIDialogCache.h"
 #include "dialogs/GUIDialogPlayEject.h"
 #include "utils/XMLUtils.h"
 #include "addons/AddonInstaller.h"
 
 #ifdef HAS_PERFORMANCE_SAMPLE
 #include "utils/PerformanceSample.h"
 #else
 #define MEASURE_FUNCTION
 #endif
 
 #ifdef TARGET_WINDOWS
 #include <shlobj.h>
 #include "win32util.h"
 #endif
 #ifdef HAS_XRANDR
 #include "windowing/X11/XRandR.h"
 #endif
 
 #ifdef TARGET_DARWIN_OSX
 #include "CocoaInterface.h"
 #include "XBMCHelper.h"
 #endif
 #ifdef TARGET_DARWIN
 #include "DarwinUtils.h"
 #endif
 
 
 #ifdef HAS_DVD_DRIVE
 #include <cdio/logging.h>
 #endif
 
 #ifdef HAS_HAL
 #include "linux/HALManager.h"
 #endif
 
 #include "storage/MediaManager.h"
 #include "utils/JobManager.h"
 #include "utils/SaveFileStateJob.h"
 #include "utils/AlarmClock.h"
 #include "utils/StringUtils.h"
 #include "DatabaseManager.h"
 
 #ifdef _LINUX
 #include "XHandle.h"
 #endif
 
 #ifdef HAS_LIRC
 #include "input/linux/LIRC.h"
 #endif
 #ifdef HAS_IRSERVERSUITE
   #include "input/windows/IRServerSuite.h"
 #endif
 
 #if defined(TARGET_WINDOWS)
 #include "input/windows/WINJoystick.h"
 #elif defined(HAS_SDL_JOYSTICK) || defined(HAS_EVENT_SERVER)
 #include "input/SDLJoystick.h"
 #endif
 
@@ -342,2 +361,4 @@ using namespace JSONRPC;
 using namespace ANNOUNCEMENT;
+using namespace PVR;
+using namespace EPG;
 using namespace PERIPHERALS;
@@ -354,75 +375,76 @@ using namespace XbmcThreads;
 CApplication::CApplication(void)
   : m_pPlayer(NULL)
 #ifdef HAS_WEB_SERVER
   , m_WebServer(*new CWebServer)
   , m_httpImageHandler(*new CHTTPImageHandler)
   , m_httpVfsHandler(*new CHTTPVfsHandler)
 #ifdef HAS_JSONRPC
   , m_httpJsonRpcHandler(*new CHTTPJsonRpcHandler)
 #endif
 #ifdef HAS_HTTPAPI
   , m_httpApiHandler(*new CHTTPApiHandler)
 #endif
 #ifdef HAS_WEB_INTERFACE
   , m_httpWebinterfaceHandler(*new CHTTPWebinterfaceHandler)
   , m_httpWebinterfaceAddonsHandler(*new CHTTPWebinterfaceAddonsHandler)
 #endif
 #endif
   , m_itemCurrentFile(new CFileItem)
   , m_stackFileItemToUpdate(new CFileItem)
   , m_progressTrackingVideoResumeBookmark(*new CBookmark)
   , m_progressTrackingItem(new CFileItem)
   , m_videoInfoScanner(new CVideoInfoScanner)
   , m_musicInfoScanner(new CMusicInfoScanner)
   , m_seekHandler(new CSeekHandler)
 {
   TiXmlBase::SetCondenseWhiteSpace(false);
   m_iPlaySpeed = 1;
+  m_bInhibitIdleShutdown = false;
   m_bScreenSave = false;
   m_dpms = NULL;
   m_dpmsIsActive = false;
   m_dpmsIsManual = false;
   m_iScreenSaveLock = 0;
   m_bInitializing = true;
   m_eForcedNextPlayer = EPC_NONE;
   m_strPlayListFile = "";
   m_nextPlaylistItem = -1;
   m_bPlaybackStarting = false;
   m_skinReloading = false;
 
 #ifdef HAS_GLX
   XInitThreads();
 #endif
 
   //true while we in IsPaused mode! Workaround for OnPaused, which must be add. after v2.0
   m_bIsPaused = false;
 
   /* for now always keep this around */
 #ifdef HAS_KARAOKE
   m_pKaraokeMgr = new CKaraokeLyricsManager();
 #endif
   m_currentStack = new CFileItemList;
 
   m_frameCount = 0;
 
   m_bPresentFrame = false;
   m_bPlatformDirectories = true;
 
   m_bStandalone = false;
   m_bEnableLegacyRes = false;
   m_bSystemScreenSaverEnable = false;
   m_pInertialScrollingHandler = new CInertialScrollingHandler();
 #ifdef HAS_DVD_DRIVE
   m_Autorun = new CAutorun();
 #endif
 
   m_splash = NULL;
   m_threadID = 0;
   m_eCurrentPlayer = EPC_NONE;
   m_progressTrackingPlayCountUpdate = false;
   m_currentStackPosition = 0;
   m_lastFrameTime = 0;
   m_lastRenderTime = 0;
   m_bTestMode = false;
 }
 
@@ -1150,237 +1172,255 @@ void CApplication::CreateUserDirs()
 bool CApplication::Initialize()
 {
 #if defined(HAS_DVD_DRIVE) && !defined(_WIN32) // somehow this throws an "unresolved external symbol" on win32
   // turn off cdio logging
   cdio_loglevel_default = CDIO_LOG_ERROR;
 #endif
 
 #ifdef _LINUX // TODO: Win32 has no special://home/ mapping by default, so we
               //       must create these here. Ideally this should be using special://home/ and
               //       be platform agnostic (i.e. unify the InitDirectories*() functions)
   if (!m_bPlatformDirectories)
 #endif
   {
     CDirectory::Create("special://xbmc/language");
     CDirectory::Create("special://xbmc/addons");
     CDirectory::Create("special://xbmc/sounds");
   }
 
   // Load curl so curl_global_init gets called before any service threads
   // are started. Unloading will have no effect as curl is never fully unloaded.
   // To quote man curl_global_init:
   //  "This function is not thread safe. You must not call it when any other
   //  thread in the program (i.e. a thread sharing the same memory) is running.
   //  This doesn't just mean no other thread that is using libcurl. Because
   //  curl_global_init() calls functions of other libraries that are similarly
   //  thread unsafe, it could conflict with any other thread that
   //  uses these other libraries."
   g_curlInterface.Load();
   g_curlInterface.Unload();
 
   // initialize (and update as needed) our databases
   CDatabaseManager::Get().Initialize();
 
 #ifdef HAS_WEB_SERVER
   CWebServer::RegisterRequestHandler(&m_httpImageHandler);
   CWebServer::RegisterRequestHandler(&m_httpVfsHandler);
 #ifdef HAS_JSONRPC
   CWebServer::RegisterRequestHandler(&m_httpJsonRpcHandler);
 #endif
 #ifdef HAS_HTTPAPI
   CWebServer::RegisterRequestHandler(&m_httpApiHandler);
 #endif
 #ifdef HAS_WEB_INTERFACE
   CWebServer::RegisterRequestHandler(&m_httpWebinterfaceAddonsHandler);
   CWebServer::RegisterRequestHandler(&m_httpWebinterfaceHandler);
 #endif
 #endif
 
   StartServices();
 
   // Init DPMS, before creating the corresponding setting control.
   m_dpms = new DPMSSupport();
   if (g_windowManager.Initialized())
   {
     g_guiSettings.GetSetting("powermanagement.displaysoff")->SetVisible(m_dpms->IsSupported());
 
     g_windowManager.Add(new CGUIWindowHome);                     // window id = 0
     g_windowManager.Add(new CGUIWindowPrograms);                 // window id = 1
     g_windowManager.Add(new CGUIWindowPictures);                 // window id = 2
     g_windowManager.Add(new CGUIWindowFileManager);      // window id = 3
     g_windowManager.Add(new CGUIWindowSettings);                 // window id = 4
     g_windowManager.Add(new CGUIWindowSystemInfo);               // window id = 7
 #ifdef HAS_GL
     g_windowManager.Add(new CGUIWindowTestPatternGL);      // window id = 8
 #endif
 #ifdef HAS_DX
     g_windowManager.Add(new CGUIWindowTestPatternDX);      // window id = 8
 #endif
     g_windowManager.Add(new CGUIDialogTeletext);               // window id =
     g_windowManager.Add(new CGUIWindowSettingsScreenCalibration); // window id = 11
     g_windowManager.Add(new CGUIWindowSettingsCategory);         // window id = 12 slideshow:window id 2007
     g_windowManager.Add(new CGUIWindowVideoNav);                 // window id = 36
     g_windowManager.Add(new CGUIWindowVideoPlaylist);            // window id = 28
     g_windowManager.Add(new CGUIWindowLoginScreen);            // window id = 29
     g_windowManager.Add(new CGUIWindowSettingsProfile);          // window id = 34
     g_windowManager.Add(new CGUIWindowAddonBrowser);          // window id = 40
     g_windowManager.Add(new CGUIWindowScreensaverDim);            // window id = 97
     g_windowManager.Add(new CGUIWindowDebugInfo);            // window id = 98
     g_windowManager.Add(new CGUIWindowPointer);            // window id = 99
     g_windowManager.Add(new CGUIDialogYesNo);              // window id = 100
     g_windowManager.Add(new CGUIDialogProgress);           // window id = 101
+    g_windowManager.Add(new CGUIDialogExtendedProgressBar);     // window id = 148
     g_windowManager.Add(new CGUIDialogKeyboardGeneric);    // window id = 103
     g_windowManager.Add(new CGUIDialogVolumeBar);          // window id = 104
     g_windowManager.Add(new CGUIDialogSeekBar);            // window id = 115
     g_windowManager.Add(new CGUIDialogSubMenu);            // window id = 105
     g_windowManager.Add(new CGUIDialogContextMenu);        // window id = 106
     g_windowManager.Add(new CGUIDialogKaiToast);           // window id = 107
     g_windowManager.Add(new CGUIDialogNumeric);            // window id = 109
     g_windowManager.Add(new CGUIDialogGamepad);            // window id = 110
     g_windowManager.Add(new CGUIDialogButtonMenu);         // window id = 111
     g_windowManager.Add(new CGUIDialogMusicScan);          // window id = 112
     g_windowManager.Add(new CGUIDialogMuteBug);            // window id = 113
     g_windowManager.Add(new CGUIDialogPlayerControls);     // window id = 114
 #ifdef HAS_KARAOKE
     g_windowManager.Add(new CGUIDialogKaraokeSongSelectorSmall); // window id 143
     g_windowManager.Add(new CGUIDialogKaraokeSongSelectorLarge); // window id 144
 #endif
     g_windowManager.Add(new CGUIDialogSlider);             // window id = 145
     g_windowManager.Add(new CGUIDialogMusicOSD);           // window id = 120
     g_windowManager.Add(new CGUIDialogVisualisationPresetList);   // window id = 122
     g_windowManager.Add(new CGUIDialogVideoSettings);             // window id = 123
     g_windowManager.Add(new CGUIDialogAudioSubtitleSettings);     // window id = 124
     g_windowManager.Add(new CGUIDialogVideoBookmarks);      // window id = 125
     // Don't add the filebrowser dialog - it's created and added when it's needed
     g_windowManager.Add(new CGUIDialogNetworkSetup);  // window id = 128
     g_windowManager.Add(new CGUIDialogMediaSource);   // window id = 129
     g_windowManager.Add(new CGUIDialogProfileSettings); // window id = 130
     g_windowManager.Add(new CGUIDialogVideoScan);      // window id = 133
     g_windowManager.Add(new CGUIDialogFavourites);     // window id = 134
     g_windowManager.Add(new CGUIDialogSongInfo);       // window id = 135
     g_windowManager.Add(new CGUIDialogSmartPlaylistEditor);       // window id = 136
     g_windowManager.Add(new CGUIDialogSmartPlaylistRule);       // window id = 137
     g_windowManager.Add(new CGUIDialogBusy);      // window id = 138
     g_windowManager.Add(new CGUIDialogPictureInfo);      // window id = 139
     g_windowManager.Add(new CGUIDialogAddonInfo);
     g_windowManager.Add(new CGUIDialogAddonSettings);      // window id = 140
 #ifdef HAS_LINUX_NETWORK
     g_windowManager.Add(new CGUIDialogAccessPoints);      // window id = 141
 #endif
 
     g_windowManager.Add(new CGUIDialogLockSettings); // window id = 131
 
     g_windowManager.Add(new CGUIDialogContentSettings);        // window id = 132
 
     g_windowManager.Add(new CGUIDialogPlayEject);
 
     g_windowManager.Add(new CGUIDialogPeripheralManager);
     g_windowManager.Add(new CGUIDialogPeripheralSettings);
 
     g_windowManager.Add(new CGUIWindowMusicPlayList);          // window id = 500
     g_windowManager.Add(new CGUIWindowMusicSongs);             // window id = 501
     g_windowManager.Add(new CGUIWindowMusicNav);               // window id = 502
     g_windowManager.Add(new CGUIWindowMusicPlaylistEditor);    // window id = 503
 
+    /* Load PVR related Windows and Dialogs */
+    g_windowManager.Add(new CGUIWindowPVR);                    // window id = 600
+    g_windowManager.Add(new CGUIDialogPVRGuideInfo);           // window id = 601
+    g_windowManager.Add(new CGUIDialogPVRRecordingInfo);       // window id = 602
+    g_windowManager.Add(new CGUIDialogPVRTimerSettings);       // window id = 603
+    g_windowManager.Add(new CGUIDialogPVRGroupManager);        // window id = 604
+    g_windowManager.Add(new CGUIDialogPVRChannelManager);      // window id = 605
+    g_windowManager.Add(new CGUIDialogPVRGuideSearch);         // window id = 606
+    g_windowManager.Add(new CGUIDialogPVRChannelsOSD);         // window id = 609
+    g_windowManager.Add(new CGUIDialogPVRGuideOSD);            // window id = 610
+    g_windowManager.Add(new CGUIDialogPVRDirectorOSD);         // window id = 611
+    g_windowManager.Add(new CGUIDialogPVRCutterOSD);           // window id = 612
+    g_windowManager.Add(new CGUIDialogTeletext);               // window id = 613
+
     g_windowManager.Add(new CGUIDialogSelect);             // window id = 2000
     g_windowManager.Add(new CGUIDialogMusicInfo);          // window id = 2001
     g_windowManager.Add(new CGUIDialogOK);                 // window id = 2002
     g_windowManager.Add(new CGUIDialogVideoInfo);          // window id = 2003
     g_windowManager.Add(new CGUIDialogTextViewer);
     g_windowManager.Add(new CGUIWindowFullScreen);         // window id = 2005
     g_windowManager.Add(new CGUIWindowVisualisation);      // window id = 2006
     g_windowManager.Add(new CGUIWindowSlideShow);          // window id = 2007
     g_windowManager.Add(new CGUIDialogFileStacking);       // window id = 2008
 #ifdef HAS_KARAOKE
     g_windowManager.Add(new CGUIWindowKaraokeLyrics);      // window id = 2009
 #endif
 
     g_windowManager.Add(new CGUIDialogVideoOSD);           // window id = 2901
     g_windowManager.Add(new CGUIDialogMusicOverlay);       // window id = 2903
     g_windowManager.Add(new CGUIDialogVideoOverlay);       // window id = 2904
     g_windowManager.Add(new CGUIWindowScreensaver);        // window id = 2900 Screensaver
     g_windowManager.Add(new CGUIWindowWeather);            // window id = 2600 WEATHER
     g_windowManager.Add(new CGUIWindowStartup);            // startup window (id 2999)
 
     /* window id's 3000 - 3100 are reserved for python */
 
     // Make sure we have at least the default skin
     if (!LoadSkin(g_guiSettings.GetString("lookandfeel.skin")) && !LoadSkin(DEFAULT_SKIN))
     {
         CLog::Log(LOGERROR, "Default skin '%s' not found! Terminating..", DEFAULT_SKIN);
         return false;
     }
 
+    StartEPGManager();
+    StartPVRManager();
+
     if (g_advancedSettings.m_splashImage)
       SAFE_DELETE(m_splash);
 
     if (g_guiSettings.GetBool("masterlock.startuplock") &&
         g_settings.GetMasterProfile().getLockMode() != LOCK_MODE_EVERYONE &&
        !g_settings.GetMasterProfile().getLockCode().IsEmpty())
     {
        g_passwordManager.CheckStartUpLock();
     }
 
     // check if we should use the login screen
     if (g_settings.UsingLoginScreen())
       g_windowManager.ActivateWindow(WINDOW_LOGIN_SCREEN);
     else
     {
 #ifdef HAS_JSONRPC
       CJSONRPC::Initialize();
 #endif
       ADDON::CAddonMgr::Get().StartServices(false);
       g_windowManager.ActivateWindow(g_SkinInfo->GetFirstWindow());
     }
 
   }
   else //No GUI Created
   {
 #ifdef HAS_JSONRPC
     CJSONRPC::Initialize();
 #endif
     ADDON::CAddonMgr::Get().StartServices(false);
   }
 
   g_sysinfo.Refresh();
 
   CLog::Log(LOGINFO, "removing tempfiles");
   CUtil::RemoveTempFiles();
 
   // if the user shutoff the system during music scan
   // restore the settings
   if (g_settings.m_bMyMusicIsScanning)
   {
     CLog::Log(LOGWARNING,"System rebooted during music scan! ... restoring UseTags and FindRemoteThumbs");
     RestoreMusicScanSettings();
   }
 
   if (!g_settings.UsingLoginScreen())
   {
     UpdateLibraries();
 #ifdef HAS_PYTHON
     g_pythonParser.m_bLogin = true;
 #endif
   }
 
   m_slowTimer.StartZero();
 
 #if defined(HAVE_LIBCRYSTALHD)
   CCrystalHD::GetInstance();
 #endif
 
   CAddonMgr::Get().StartServices(true);
 
   CLog::Log(LOGNOTICE, "initialize done");
 
   m_bInitializing = false;
 
   // reset our screensaver (starts timers etc.)
   ResetScreenSaver();
 
 #ifdef HAS_SDL_JOYSTICK
   g_Joystick.SetEnabled(g_guiSettings.GetBool("input.enablejoystick"));
 #endif
 
   return true;
 }
 
@@ -1784,2 +1824,26 @@ void CApplication::StopZeroconf()
 
+void CApplication::StartPVRManager()
+{
+  if (g_guiSettings.GetBool("pvrmanager.enabled"))
+    g_PVRManager.Start();
+}
+
+void CApplication::StartEPGManager(void)
+{
+  g_EpgContainer.Start();
+}
+
+void CApplication::StopPVRManager()
+{
+  CLog::Log(LOGINFO, "stopping PVRManager");
+  if (g_PVRManager.IsPlaying())
+    StopPlaying();
+  g_PVRManager.Stop();
+}
+
+void CApplication::StopEPGManager(void)
+{
+  g_EpgContainer.Stop();
+}
+
 void CApplication::DimLCDOnPlayback(bool dim)
@@ -2562,319 +2626,319 @@ bool CApplication::OnAppCommand(const CAction &action)
 bool CApplication::OnAction(const CAction &action)
 {
 #ifdef HAS_HTTPAPI
   // Let's tell the outside world about this action, ignoring mouse moves
   if (g_settings.m_HttpApiBroadcastLevel>=2 && action.GetID() != ACTION_MOUSE_MOVE)
   {
     CStdString tmp;
     tmp.Format("%i",action.GetID());
     CApplicationMessenger::Get().HttpApi("broadcastlevel; OnAction:"+tmp+";2");
   }
 #endif
 
   // special case for switching between GUI & fullscreen mode.
   if (action.GetID() == ACTION_SHOW_GUI)
   { // Switch to fullscreen mode if we can
     if (SwitchToFullScreen())
     {
       m_navigationTimer.StartZero();
       return true;
     }
   }
 
   if (action.GetID() == ACTION_TOGGLE_FULLSCREEN)
   {
     g_graphicsContext.ToggleFullScreenRoot();
     return true;
   }
 
   if (action.IsMouse())
     g_Mouse.SetActive(true);
 
   // The action PLAYPAUSE behaves as ACTION_PAUSE if we are currently
   // playing or ACTION_PLAYER_PLAY if we are not playing.
   if (action.GetID() == ACTION_PLAYER_PLAYPAUSE)
   {
     if (IsPlaying())
       return OnAction(CAction(ACTION_PAUSE));
     else
       return OnAction(CAction(ACTION_PLAYER_PLAY));
   }
 
   //if the action would start or stop inertial scrolling
   //by gesture - bypass the normal OnAction handler of current window
   if( !m_pInertialScrollingHandler->CheckForInertialScrolling(&action) )
   {
     // in normal case
     // just pass the action to the current window and let it handle it
     if (g_windowManager.OnAction(action))
     {
       m_navigationTimer.StartZero();
       return true;
     }
   }
 
   // handle extra global presses
 
   // screenshot : take a screenshot :)
   if (action.GetID() == ACTION_TAKE_SCREENSHOT)
   {
     CUtil::TakeScreenshot();
     return true;
   }
   // built in functions : execute the built-in
   if (action.GetID() == ACTION_BUILT_IN_FUNCTION)
   {
     CBuiltins::Execute(action.GetName());
     m_navigationTimer.StartZero();
     return true;
   }
 
   // reload keymaps
   if (action.GetID() == ACTION_RELOAD_KEYMAPS)
   {
     CButtonTranslator::GetInstance().Clear();
     CButtonTranslator::GetInstance().Load();
   }
 
   // show info : Shows the current video or song information
   if (action.GetID() == ACTION_SHOW_INFO)
   {
     g_infoManager.ToggleShowInfo();
     return true;
   }
 
   // codec info : Shows the current song, video or picture codec information
   if (action.GetID() == ACTION_SHOW_CODEC)
   {
     g_infoManager.ToggleShowCodec();
     return true;
   }
 
   if ((action.GetID() == ACTION_INCREASE_RATING || action.GetID() == ACTION_DECREASE_RATING) && IsPlayingAudio())
   {
     const CMusicInfoTag *tag = g_infoManager.GetCurrentSongTag();
     if (tag)
     {
       *m_itemCurrentFile->GetMusicInfoTag() = *tag;
       char rating = tag->GetRating();
       bool needsUpdate(false);
       if (rating > '0' && action.GetID() == ACTION_DECREASE_RATING)
       {
         m_itemCurrentFile->GetMusicInfoTag()->SetRating(rating - 1);
         needsUpdate = true;
       }
       else if (rating < '5' && action.GetID() == ACTION_INCREASE_RATING)
       {
         m_itemCurrentFile->GetMusicInfoTag()->SetRating(rating + 1);
         needsUpdate = true;
       }
       if (needsUpdate)
       {
         CMusicDatabase db;
         if (db.Open())      // OpenForWrite() ?
         {
           db.SetSongRating(m_itemCurrentFile->GetPath(), m_itemCurrentFile->GetMusicInfoTag()->GetRating());
           db.Close();
         }
         // send a message to all windows to tell them to update the fileitem (eg playlistplayer, media windows)
         CGUIMessage msg(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_UPDATE_ITEM, 0, m_itemCurrentFile);
         g_windowManager.SendMessage(msg);
       }
     }
     return true;
   }
 
   // stop : stops playing current audio song
   if (action.GetID() == ACTION_STOP)
   {
     StopPlaying();
     return true;
   }
 
   // previous : play previous song from playlist
   if (action.GetID() == ACTION_PREV_ITEM)
   {
     // first check whether we're within 3 seconds of the start of the track
     // if not, we just revert to the start of the track
     if (m_pPlayer && m_pPlayer->CanSeek() && GetTime() > 3)
     {
       SeekTime(0);
       SetPlaySpeed(1);
     }
     else
     {
       g_playlistPlayer.PlayPrevious();
     }
     return true;
   }
 
   // next : play next song from playlist
   if (action.GetID() == ACTION_NEXT_ITEM)
   {
     if (IsPlaying() && m_pPlayer->SkipNext())
       return true;
 
     if (IsPaused())
       m_pPlayer->Pause();
 
     g_playlistPlayer.PlayNext();
 
     return true;
   }
 
-  if ( IsPlaying())
+  if (IsPlaying() && !CurrentFileItem().IsLiveTV())
   {
     // pause : pauses current audio song
     if (action.GetID() == ACTION_PAUSE && m_iPlaySpeed == 1)
     {
       m_pPlayer->Pause();
 #ifdef HAS_KARAOKE
       m_pKaraokeMgr->SetPaused( m_pPlayer->IsPaused() );
 #endif
       if (!m_pPlayer->IsPaused())
       { // unpaused - set the playspeed back to normal
         SetPlaySpeed(1);
       }
       g_audioManager.Enable(m_pPlayer->IsPaused());
       return true;
     }
     if (!m_pPlayer->IsPaused())
     {
       // if we do a FF/RW in my music then map PLAY action togo back to normal speed
       // if we are playing at normal speed, then allow play to pause
       if (action.GetID() == ACTION_PLAYER_PLAY || action.GetID() == ACTION_PAUSE)
       {
         if (m_iPlaySpeed != 1)
         {
           SetPlaySpeed(1);
         }
         else
         {
           m_pPlayer->Pause();
         }
         return true;
       }
       if (action.GetID() == ACTION_PLAYER_FORWARD || action.GetID() == ACTION_PLAYER_REWIND)
       {
         int iPlaySpeed = m_iPlaySpeed;
         if (action.GetID() == ACTION_PLAYER_REWIND && iPlaySpeed == 1) // Enables Rewinding
           iPlaySpeed *= -2;
         else if (action.GetID() == ACTION_PLAYER_REWIND && iPlaySpeed > 1) //goes down a notch if you're FFing
           iPlaySpeed /= 2;
         else if (action.GetID() == ACTION_PLAYER_FORWARD && iPlaySpeed < 1) //goes up a notch if you're RWing
           iPlaySpeed /= 2;
         else
           iPlaySpeed *= 2;
 
         if (action.GetID() == ACTION_PLAYER_FORWARD && iPlaySpeed == -1) //sets iSpeed back to 1 if -1 (didn't plan for a -1)
           iPlaySpeed = 1;
         if (iPlaySpeed > 32 || iPlaySpeed < -32)
           iPlaySpeed = 1;
 
         SetPlaySpeed(iPlaySpeed);
         return true;
       }
       else if ((action.GetAmount() || GetPlaySpeed() != 1) && (action.GetID() == ACTION_ANALOG_REWIND || action.GetID() == ACTION_ANALOG_FORWARD))
       {
         // calculate the speed based on the amount the button is held down
         int iPower = (int)(action.GetAmount() * MAX_FFWD_SPEED + 0.5f);
         // returns 0 -> MAX_FFWD_SPEED
         int iSpeed = 1 << iPower;
         if (iSpeed != 1 && action.GetID() == ACTION_ANALOG_REWIND)
           iSpeed = -iSpeed;
         g_application.SetPlaySpeed(iSpeed);
         if (iSpeed == 1)
           CLog::Log(LOGDEBUG,"Resetting playspeed");
         return true;
       }
     }
     // allow play to unpause
     else
     {
       if (action.GetID() == ACTION_PLAYER_PLAY)
       {
         // unpause, and set the playspeed back to normal
         m_pPlayer->Pause();
         g_audioManager.Enable(m_pPlayer->IsPaused());
 
         g_application.SetPlaySpeed(1);
         return true;
       }
     }
   }
 
   if (g_peripherals.OnAction(action))
     return true;
 
   if (action.GetID() == ACTION_MUTE)
   {
     ToggleMute();
     return true;
   }
 
   if (action.GetID() == ACTION_TOGGLE_DIGITAL_ANALOG)
   {
     switch(g_guiSettings.GetInt("audiooutput.mode"))
     {
       case AUDIO_ANALOG: g_guiSettings.SetInt("audiooutput.mode", AUDIO_IEC958); break;
       case AUDIO_IEC958: g_guiSettings.SetInt("audiooutput.mode", AUDIO_HDMI  ); break;
       case AUDIO_HDMI  : g_guiSettings.SetInt("audiooutput.mode", AUDIO_ANALOG); break;
     }
 
     g_application.Restart();
     if (g_windowManager.GetActiveWindow() == WINDOW_SETTINGS_SYSTEM)
     {
       CGUIMessage msg(GUI_MSG_WINDOW_INIT, 0,0,WINDOW_INVALID,g_windowManager.GetActiveWindow());
       g_windowManager.SendMessage(msg);
     }
     return true;
   }
 
   // Check for global volume control
   if (action.GetAmount() && (action.GetID() == ACTION_VOLUME_UP || action.GetID() == ACTION_VOLUME_DOWN))
   {
     if (!m_pPlayer || !m_pPlayer->IsPassthrough())
     {
       if (g_settings.m_bMute)
         UnMute();
       float volume = g_settings.m_fVolumeLevel;
       float step   = (VOLUME_MAXIMUM - VOLUME_MINIMUM) / VOLUME_CONTROL_STEPS;
       if (action.GetRepeat())
         step *= action.GetRepeat() * 50; // 50 fps
 
       if (action.GetID() == ACTION_VOLUME_UP)
         volume += (float)fabs(action.GetAmount()) * action.GetAmount() * step;
       else
         volume -= (float)fabs(action.GetAmount()) * action.GetAmount() * step;
 
       SetVolume(volume, false);
     }
     // show visual feedback of volume change...
     ShowVolumeBar(&action);
     return true;
   }
   // Check for global seek control
   if (IsPlaying() && action.GetAmount() && (action.GetID() == ACTION_ANALOG_SEEK_FORWARD || action.GetID() == ACTION_ANALOG_SEEK_BACK))
   {
     if (!m_pPlayer->CanSeek()) return false;
     m_seekHandler->Seek(action.GetID() == ACTION_ANALOG_SEEK_FORWARD, action.GetAmount(), action.GetRepeat());
     return true;
   }
   if (action.GetID() == ACTION_GUIPROFILE_BEGIN)
   {
     CGUIControlProfiler::Instance().SetOutputFile(CSpecialProtocol::TranslatePath("special://home/guiprofiler.xml"));
     CGUIControlProfiler::Instance().Start();
     return true;
   }
   if (action.GetID() == ACTION_SHOW_PLAYLIST)
   {
     int iPlaylist = g_playlistPlayer.GetCurrentPlaylist();
     if (iPlaylist == PLAYLIST_VIDEO)
       g_windowManager.ActivateWindow(WINDOW_VIDEO_PLAYLIST);
     else if (iPlaylist == PLAYLIST_MUSIC)
       g_windowManager.ActivateWindow(WINDOW_MUSIC_PLAYLIST);
     return true;
   }
   return false;
 }
 
@@ -3395,308 +3459,325 @@ int CApplication::GetActiveWindowID(void)
 bool CApplication::Cleanup()
 {
   try
   {
     g_windowManager.Delete(WINDOW_MUSIC_PLAYLIST);
     g_windowManager.Delete(WINDOW_MUSIC_PLAYLIST_EDITOR);
     g_windowManager.Delete(WINDOW_MUSIC_FILES);
     g_windowManager.Delete(WINDOW_MUSIC_NAV);
     g_windowManager.Delete(WINDOW_DIALOG_MUSIC_INFO);
     g_windowManager.Delete(WINDOW_DIALOG_VIDEO_INFO);
     g_windowManager.Delete(WINDOW_VIDEO_FILES);
     g_windowManager.Delete(WINDOW_VIDEO_PLAYLIST);
     g_windowManager.Delete(WINDOW_VIDEO_NAV);
     g_windowManager.Delete(WINDOW_FILES);
     g_windowManager.Delete(WINDOW_DIALOG_YES_NO);
     g_windowManager.Delete(WINDOW_DIALOG_PROGRESS);
     g_windowManager.Delete(WINDOW_DIALOG_NUMERIC);
     g_windowManager.Delete(WINDOW_DIALOG_GAMEPAD);
     g_windowManager.Delete(WINDOW_DIALOG_SUB_MENU);
     g_windowManager.Delete(WINDOW_DIALOG_BUTTON_MENU);
     g_windowManager.Delete(WINDOW_DIALOG_CONTEXT_MENU);
     g_windowManager.Delete(WINDOW_DIALOG_MUSIC_SCAN);
     g_windowManager.Delete(WINDOW_DIALOG_PLAYER_CONTROLS);
     g_windowManager.Delete(WINDOW_DIALOG_KARAOKE_SONGSELECT);
     g_windowManager.Delete(WINDOW_DIALOG_KARAOKE_SELECTOR);
     g_windowManager.Delete(WINDOW_DIALOG_MUSIC_OSD);
     g_windowManager.Delete(WINDOW_DIALOG_VIS_PRESET_LIST);
     g_windowManager.Delete(WINDOW_DIALOG_SELECT);
     g_windowManager.Delete(WINDOW_DIALOG_OK);
     g_windowManager.Delete(WINDOW_DIALOG_FILESTACKING);
     g_windowManager.Delete(WINDOW_DIALOG_KEYBOARD);
     g_windowManager.Delete(WINDOW_FULLSCREEN_VIDEO);
     g_windowManager.Delete(WINDOW_DIALOG_PROFILE_SETTINGS);
     g_windowManager.Delete(WINDOW_DIALOG_LOCK_SETTINGS);
     g_windowManager.Delete(WINDOW_DIALOG_NETWORK_SETUP);
     g_windowManager.Delete(WINDOW_DIALOG_MEDIA_SOURCE);
     g_windowManager.Delete(WINDOW_DIALOG_VIDEO_OSD_SETTINGS);
     g_windowManager.Delete(WINDOW_DIALOG_AUDIO_OSD_SETTINGS);
     g_windowManager.Delete(WINDOW_DIALOG_VIDEO_BOOKMARKS);
     g_windowManager.Delete(WINDOW_DIALOG_VIDEO_SCAN);
     g_windowManager.Delete(WINDOW_DIALOG_CONTENT_SETTINGS);
     g_windowManager.Delete(WINDOW_DIALOG_FAVOURITES);
     g_windowManager.Delete(WINDOW_DIALOG_SONG_INFO);
     g_windowManager.Delete(WINDOW_DIALOG_SMART_PLAYLIST_EDITOR);
     g_windowManager.Delete(WINDOW_DIALOG_SMART_PLAYLIST_RULE);
     g_windowManager.Delete(WINDOW_DIALOG_BUSY);
     g_windowManager.Delete(WINDOW_DIALOG_PICTURE_INFO);
     g_windowManager.Delete(WINDOW_DIALOG_ADDON_INFO);
     g_windowManager.Delete(WINDOW_DIALOG_ADDON_SETTINGS);
     g_windowManager.Delete(WINDOW_DIALOG_ACCESS_POINTS);
     g_windowManager.Delete(WINDOW_DIALOG_SLIDER);
 
+    /* Delete PVR related windows and dialogs */
+    g_windowManager.Delete(WINDOW_PVR);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_GUIDE_INFO);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_RECORDING_INFO);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_TIMER_SETTING);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_GROUP_MANAGER);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_CHANNEL_MANAGER);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_GUIDE_SEARCH);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_CHANNEL_SCAN);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_UPDATE_PROGRESS);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_OSD_CHANNELS);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_OSD_GUIDE);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_OSD_DIRECTOR);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_OSD_CUTTER);
     g_windowManager.Delete(WINDOW_DIALOG_OSD_TELETEXT);
-    g_windowManager.Delete(WINDOW_DIALOG_TEXT_VIEWER);
 
+    g_windowManager.Delete(WINDOW_DIALOG_TEXT_VIEWER);
     g_windowManager.Delete(WINDOW_DIALOG_PLAY_EJECT);
-
     g_windowManager.Delete(WINDOW_STARTUP_ANIM);
     g_windowManager.Delete(WINDOW_LOGIN_SCREEN);
     g_windowManager.Delete(WINDOW_VISUALISATION);
     g_windowManager.Delete(WINDOW_KARAOKELYRICS);
     g_windowManager.Delete(WINDOW_SETTINGS_MENU);
     g_windowManager.Delete(WINDOW_SETTINGS_PROFILES);
     g_windowManager.Delete(WINDOW_SETTINGS_MYPICTURES);  // all the settings categories
     g_windowManager.Delete(WINDOW_TEST_PATTERN);
     g_windowManager.Delete(WINDOW_SCREEN_CALIBRATION);
     g_windowManager.Delete(WINDOW_SYSTEM_INFORMATION);
     g_windowManager.Delete(WINDOW_SCREENSAVER);
     g_windowManager.Delete(WINDOW_DIALOG_VIDEO_OSD);
     g_windowManager.Delete(WINDOW_DIALOG_MUSIC_OVERLAY);
     g_windowManager.Delete(WINDOW_DIALOG_VIDEO_OVERLAY);
     g_windowManager.Delete(WINDOW_SLIDESHOW);
+    g_windowManager.Delete(WINDOW_ADDON_BROWSER);
 
     g_windowManager.Delete(WINDOW_HOME);
     g_windowManager.Delete(WINDOW_PROGRAMS);
     g_windowManager.Delete(WINDOW_PICTURES);
     g_windowManager.Delete(WINDOW_WEATHER);
 
     g_windowManager.Delete(WINDOW_SETTINGS_MYPICTURES);
     g_windowManager.Remove(WINDOW_SETTINGS_MYPROGRAMS);
     g_windowManager.Remove(WINDOW_SETTINGS_MYWEATHER);
     g_windowManager.Remove(WINDOW_SETTINGS_MYMUSIC);
     g_windowManager.Remove(WINDOW_SETTINGS_SYSTEM);
     g_windowManager.Remove(WINDOW_SETTINGS_MYVIDEOS);
     g_windowManager.Remove(WINDOW_SETTINGS_SERVICE);
     g_windowManager.Remove(WINDOW_SETTINGS_APPEARANCE);
+    g_windowManager.Remove(WINDOW_SETTINGS_MYPVR);
     g_windowManager.Remove(WINDOW_DIALOG_KAI_TOAST);
 
     g_windowManager.Remove(WINDOW_DIALOG_SEEK_BAR);
     g_windowManager.Remove(WINDOW_DIALOG_VOLUME_BAR);
 
     CAddonMgr::Get().DeInit();
 
 #if defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
     CLog::Log(LOGNOTICE, "closing down remote control service");
     g_RemoteControl.Disconnect();
 #endif
 
     CLog::Log(LOGNOTICE, "unload sections");
 
 #ifdef HAS_PERFORMANCE_SAMPLE
     CLog::Log(LOGNOTICE, "performance statistics");
     m_perfStats.DumpStats();
 #endif
 
     //  Shutdown as much as possible of the
     //  application, to reduce the leaks dumped
     //  to the vc output window before calling
     //  _CrtDumpMemoryLeaks(). Most of the leaks
     //  shown are no real leaks, as parts of the app
     //  are still allocated.
 
     g_localizeStrings.Clear();
     g_LangCodeExpander.Clear();
     g_charsetConverter.clear();
     g_directoryCache.Clear();
     CButtonTranslator::GetInstance().Clear();
     CLastfmScrobbler::RemoveInstance();
     CLibrefmScrobbler::RemoveInstance();
     CLastFmManager::RemoveInstance();
 #ifdef HAS_EVENT_SERVER
     CEventServer::RemoveInstance();
 #endif
     DllLoaderContainer::Clear();
     g_playlistPlayer.Clear();
     g_settings.Clear();
     g_guiSettings.Clear();
     g_advancedSettings.Clear();
 
 #ifdef _LINUX
     CXHandle::DumpObjectTracker();
 #endif
 #if defined(TARGET_ANDROID)
     // enable for all platforms once it's safe
     g_sectionLoader.UnloadAll();
 #endif
 #ifdef _CRTDBG_MAP_ALLOC
     _CrtDumpMemoryLeaks();
     while(1); // execution ends
 #endif
     return true;
   }
   catch (...)
   {
     CLog::Log(LOGERROR, "Exception in CApplication::Cleanup()");
     return false;
   }
 }
 
 void CApplication::Stop(int exitCode)
 {
   try
   {
     CVariant vExitCode(exitCode);
     CAnnouncementManager::Announce(System, "xbmc", "OnQuit", vExitCode);
 
     SaveFileState(true);
 
     // cancel any jobs from the jobmanager
     CJobManager::GetInstance().CancelJobs();
 
     g_alarmClock.StopThread();
 
 #ifdef HAS_HTTPAPI
     if (m_pXbmcHttp)
     {
       if (g_settings.m_HttpApiBroadcastLevel >= 1)
         CApplicationMessenger::Get().HttpApi("broadcastlevel; ShutDown;1");
 
       m_pXbmcHttp->shuttingDown = true;
     }
 #endif
 
     if( m_bSystemScreenSaverEnable )
       g_Windowing.EnableSystemScreenSaver(true);
 
     CLog::Log(LOGNOTICE, "Storing total System Uptime");
     g_settings.m_iSystemTimeTotalUp = g_settings.m_iSystemTimeTotalUp + (int)(CTimeUtils::GetFrameTime() / 60000);
 
     // Update the settings information (volume, uptime etc. need saving)
     if (CFile::Exists(g_settings.GetSettingsFile()))
     {
       CLog::Log(LOGNOTICE, "Saving settings");
       g_settings.Save();
     }
     else
       CLog::Log(LOGNOTICE, "Not saving settings (settings.xml is not present)");
 
     m_bStop = true;
     m_AppActive = false;
     m_AppFocused = false;
     m_ExitCode = exitCode;
     CLog::Log(LOGNOTICE, "stop all");
 
     // stop scanning before we kill the network and so on
     if (m_musicInfoScanner->IsScanning())
       m_musicInfoScanner->Stop();
 
     if (m_videoInfoScanner->IsScanning())
       m_videoInfoScanner->Stop();
 
     CApplicationMessenger::Get().Cleanup();
 
+    StopPVRManager();
+    StopEPGManager();
     StopServices();
     //Sleep(5000);
 
 #ifdef HAS_WEB_SERVER
   CWebServer::UnregisterRequestHandler(&m_httpImageHandler);
   CWebServer::UnregisterRequestHandler(&m_httpVfsHandler);
 #ifdef HAS_JSONRPC
   CWebServer::UnregisterRequestHandler(&m_httpJsonRpcHandler);
 #endif
 #ifdef HAS_HTTPAPI
   CWebServer::UnregisterRequestHandler(&m_httpApiHandler);
 #endif
 #ifdef HAS_WEB_INTERFACE
   CWebServer::UnregisterRequestHandler(&m_httpWebinterfaceAddonsHandler);
   CWebServer::UnregisterRequestHandler(&m_httpWebinterfaceHandler);
 #endif
 #endif
 
     if (m_pPlayer)
     {
       CLog::Log(LOGNOTICE, "stop player");
       delete m_pPlayer;
       m_pPlayer = NULL;
     }
 
 #if HAS_FILESYTEM_DAAP
     CLog::Log(LOGNOTICE, "stop daap clients");
     g_DaapClient.Release();
 #endif
 #ifdef HAS_FILESYSTEM_SAP
     CLog::Log(LOGNOTICE, "stop sap announcement listener");
     g_sapsessions.StopThread();
 #endif
 #ifdef HAS_ZEROCONF
     if(CZeroconfBrowser::IsInstantiated())
     {
       CLog::Log(LOGNOTICE, "stop zeroconf browser");
       CZeroconfBrowser::GetInstance()->Stop();
       CZeroconfBrowser::ReleaseInstance();
     }
 #endif
 
     CLog::Log(LOGNOTICE, "clean cached files!");
 #ifdef HAS_FILESYSTEM_RAR
     g_RarManager.ClearCache(true);
 #endif
 
 #ifdef HAS_FILESYSTEM_SFTP
     CSFTPSessionManager::DisconnectAllSessions();
 #endif
 
     CLog::Log(LOGNOTICE, "unload skin");
     UnloadSkin();
 
 #if defined(TARGET_DARWIN_OSX)
     if (XBMCHelper::GetInstance().IsAlwaysOn() == false)
       XBMCHelper::GetInstance().Stop();
 #endif
 
 #if defined(HAVE_LIBCRYSTALHD)
     CCrystalHD::RemoveInstance();
 #endif
 
   g_mediaManager.Stop();
 
   // Stop services before unloading Python
   CAddonMgr::Get().StopServices(false);
 
 /* Python resource freeing must be done after skin has been unloaded, not before
    some windows still need it when deinitializing during skin unloading. */
 #ifdef HAS_PYTHON
   CLog::Log(LOGNOTICE, "stop python");
   g_pythonParser.FreeResources();
 #endif
 #ifdef HAS_LCD
     if (g_lcd)
     {
       g_lcd->Stop();
       delete g_lcd;
       g_lcd=NULL;
     }
 #endif
 
     g_Windowing.DestroyRenderSystem();
     g_Windowing.DestroyWindow();
     g_Windowing.DestroyWindowSystem();
 
     // shutdown the AudioEngine
     CAEFactory::Shutdown();
 
     CLog::Log(LOGNOTICE, "stopped");
   }
   catch (...)
   {
     CLog::Log(LOGERROR, "Exception in CApplication::Stop()");
   }
 
   // we may not get to finish the run cycle but exit immediately after a call to g_application.Stop()
   // so we may never get to Destroy() in CXBApplicationEx::Run(), we call it here.
   Destroy();
 
   //
   Sleep(200);
 }
 
@@ -3909,307 +3990,310 @@ bool CApplication::PlayStack(const CFileItem& item, bool bRestart)
 bool CApplication::PlayFile(const CFileItem& item, bool bRestart)
 {
   if (!bRestart)
   {
     SaveCurrentFileSettings();
 
     OutputDebugString("new file set audiostream:0\n");
     // Switch to default options
     g_settings.m_currentVideoSettings = g_settings.m_defaultVideoSettings;
     // see if we have saved options in the database
 
     m_iPlaySpeed = 1;
     *m_itemCurrentFile = item;
     m_nextPlaylistItem = -1;
     m_currentStackPosition = 0;
     m_currentStack->Clear();
 
     if (item.IsVideo())
       CUtil::ClearSubtitles();
   }
 
   if (item.IsDiscStub())
   {
 #ifdef HAS_DVD_DRIVE
     // Display the Play Eject dialog
     if (CGUIDialogPlayEject::ShowAndGetInput(item))
       // PlayDiscAskResume takes path to disc. No parameter means default DVD drive.
       // Can't do better as CGUIDialogPlayEject calls CMediaManager::IsDiscInDrive, which assumes default DVD drive anyway
       return MEDIA_DETECT::CAutorun::PlayDiscAskResume();
 #endif
     return true;
   }
 
   if (item.IsPlayList())
     return false;
 
   if (item.IsPlugin())
   { // we modify the item so that it becomes a real URL
     CFileItem item_new(item);
     if (XFILE::CPluginDirectory::GetPluginResult(item.GetPath(), item_new))
       return PlayFile(item_new, false);
     return false;
   }
 
   if (URIUtils::IsUPnP(item.GetPath()))
   {
     CFileItem item_new(item);
     if (XFILE::CUPnPDirectory::GetResource(item.GetPath(), item_new))
       return PlayFile(item_new, false);
     return false;
   }
 
   // if we have a stacked set of files, we need to setup our stack routines for
   // "seamless" seeking and total time of the movie etc.
   // will recall with restart set to true
   if (item.IsStack())
     return PlayStack(item, bRestart);
 
   //Is TuxBox, this should probably be moved to CTuxBoxFile
   if(item.IsTuxBox())
   {
     CLog::Log(LOGDEBUG, "%s - TuxBox URL Detected %s",__FUNCTION__, item.GetPath().c_str());
 
     if(g_tuxboxService.IsRunning())
       g_tuxboxService.Stop();
 
     CFileItem item_new;
     if(g_tuxbox.CreateNewItem(item, item_new))
     {
 
       // Make sure it doesn't have a player
       // so we actually select one normally
       m_eCurrentPlayer = EPC_NONE;
 
       // keep the tuxbox:// url as playing url
       // and give the new url to the player
       if(PlayFile(item_new, true))
       {
         if(!g_tuxboxService.IsRunning())
           g_tuxboxService.Start();
         return true;
       }
     }
     return false;
   }
 
   CPlayerOptions options;
 
   if( item.HasProperty("StartPercent") )
   {
     double fallback = 0.0f;
     if(item.GetProperty("StartPercent").isString())
       fallback = (double)atof(item.GetProperty("StartPercent").asString().c_str());
     options.startpercent = item.GetProperty("StartPercent").asDouble(fallback);
   }
 
   PLAYERCOREID eNewCore = EPC_NONE;
   if( bRestart )
   {
     // have to be set here due to playstack using this for starting the file
     options.starttime = item.m_lStartOffset / 75.0;
     if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0 && m_itemCurrentFile->m_lStartOffset != 0)
       m_itemCurrentFile->m_lStartOffset = STARTOFFSET_RESUME; // to force fullscreen switching
 
     if( m_eForcedNextPlayer != EPC_NONE )
       eNewCore = m_eForcedNextPlayer;
     else if( m_eCurrentPlayer == EPC_NONE )
       eNewCore = CPlayerCoreFactory::GetDefaultPlayer(item);
     else
       eNewCore = m_eCurrentPlayer;
   }
   else
   {
     options.starttime = item.m_lStartOffset / 75.0;
 
     if (item.IsVideo())
     {
       // open the d/b and retrieve the bookmarks for the current movie
       CVideoDatabase dbs;
       dbs.Open();
       dbs.GetVideoSettings(item.GetPath(), g_settings.m_currentVideoSettings);
 
       if( item.m_lStartOffset == STARTOFFSET_RESUME )
       {
         options.starttime = 0.0f;
         CBookmark bookmark;
         CStdString path = item.GetPath();
         if (item.HasVideoInfoTag() && item.GetVideoInfoTag()->m_strFileNameAndPath.Find("removable://") == 0)
           path = item.GetVideoInfoTag()->m_strFileNameAndPath;
         else if (item.HasProperty("original_listitem_url") && URIUtils::IsPlugin(item.GetProperty("original_listitem_url").asString()))
           path = item.GetProperty("original_listitem_url").asString();
         if(dbs.GetResumeBookMark(path, bookmark))
         {
           options.starttime = bookmark.timeInSeconds;
           options.state = bookmark.playerState;
         }
         /*
          override with information from the actual item if available.  We do this as the VFS (eg plugins)
          may set the resume point to override whatever XBMC has stored, yet we ignore it until now so that,
          should the playerState be required, it is fetched from the database.
          See the note in CGUIWindowVideoBase::ShowResumeMenu.
          */
         if (item.HasVideoInfoTag() && item.GetVideoInfoTag()->m_resumePoint.IsSet())
           options.starttime = item.GetVideoInfoTag()->m_resumePoint.timeInSeconds;
       }
       else if (item.HasVideoInfoTag())
       {
         const CVideoInfoTag *tag = item.GetVideoInfoTag();
 
         if (tag->m_iBookmarkId != -1 && tag->m_iBookmarkId != 0)
         {
           CBookmark bookmark;
           dbs.GetBookMarkForEpisode(*tag, bookmark);
           options.starttime = bookmark.timeInSeconds;
           options.state = bookmark.playerState;
         }
       }
 
       dbs.Close();
     }
 
     if (m_eForcedNextPlayer != EPC_NONE)
       eNewCore = m_eForcedNextPlayer;
     else
       eNewCore = CPlayerCoreFactory::GetDefaultPlayer(item);
   }
 
   // this really aught to be inside !bRestart, but since PlayStack
   // uses that to init playback, we have to keep it outside
   int playlist = g_playlistPlayer.GetCurrentPlaylist();
   if (item.IsVideo() && g_playlistPlayer.GetPlaylist(playlist).size() > 1)
   { // playing from a playlist by the looks
     // don't switch to fullscreen if we are not playing the first item...
     options.fullscreen = !g_playlistPlayer.HasPlayedFirstFile() && g_advancedSettings.m_fullScreenOnMovieStart && !g_settings.m_bStartVideoWindowed;
   }
   else if(m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
   {
     // TODO - this will fail if user seeks back to first file in stack
     if(m_currentStackPosition == 0 || m_itemCurrentFile->m_lStartOffset == STARTOFFSET_RESUME)
       options.fullscreen = g_advancedSettings.m_fullScreenOnMovieStart && !g_settings.m_bStartVideoWindowed;
     else
       options.fullscreen = false;
     // reset this so we don't think we are resuming on seek
     m_itemCurrentFile->m_lStartOffset = 0;
   }
   else
     options.fullscreen = g_advancedSettings.m_fullScreenOnMovieStart && !g_settings.m_bStartVideoWindowed;
 
   // reset m_bStartVideoWindowed as it's a temp setting
   g_settings.m_bStartVideoWindowed = false;
   // reset any forced player
   m_eForcedNextPlayer = EPC_NONE;
 
 #ifdef HAS_KARAOKE
   //We have to stop parsing a cdg before mplayer is deallocated
   // WHY do we have to do this????
   if (m_pKaraokeMgr)
     m_pKaraokeMgr->Stop();
 #endif
 
   // tell system we are starting a file
   m_bPlaybackStarting = true;
 
   // We should restart the player, unless the previous and next tracks are using
   // one of the players that allows gapless playback (paplayer, dvdplayer)
   if (m_pPlayer)
   {
     if ( !(m_eCurrentPlayer == eNewCore && (m_eCurrentPlayer == EPC_DVDPLAYER || m_eCurrentPlayer  == EPC_PAPLAYER)) )
     {
       delete m_pPlayer;
       m_pPlayer = NULL;
     }
   }
 
   if (!m_pPlayer)
   {
     m_eCurrentPlayer = eNewCore;
     m_pPlayer = CPlayerCoreFactory::CreatePlayer(eNewCore, *this);
   }
 
   bool bResult;
   if (m_pPlayer)
   {
     // don't hold graphicscontext here since player
     // may wait on another thread, that requires gfx
     CSingleExit ex(g_graphicsContext);
     bResult = m_pPlayer->OpenFile(item, options);
   }
   else
   {
     CLog::Log(LOGERROR, "Error creating player for item %s (File doesn't exist?)", item.GetPath().c_str());
     bResult = false;
   }
 
   if(bResult)
   {
     if (m_iPlaySpeed != 1)
     {
       int iSpeed = m_iPlaySpeed;
       m_iPlaySpeed = 1;
       SetPlaySpeed(iSpeed);
     }
 
     if( IsPlayingAudio() )
     {
       if (g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
         g_windowManager.ActivateWindow(WINDOW_VISUALISATION);
     }
 
 #ifdef HAS_VIDEO_PLAYBACK
     if( IsPlayingVideo() )
     {
       if (g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION)
         g_windowManager.ActivateWindow(WINDOW_FULLSCREEN_VIDEO);
 
       // if player didn't manange to switch to fullscreen by itself do it here
       if( options.fullscreen && g_renderManager.IsStarted()
        && g_windowManager.GetActiveWindow() != WINDOW_FULLSCREEN_VIDEO )
        SwitchToFullScreen();
 
       if (!item.IsDVDImage() && !item.IsDVDFile())
       {
         CVideoInfoTag *details = m_itemCurrentFile->GetVideoInfoTag();
         // Save information about the stream if we currently have no data
         if (!details->HasStreamDetails() ||
              details->m_streamDetails.GetVideoDuration() <= 0)
         {
           if (m_pPlayer->GetStreamDetails(details->m_streamDetails) && details->HasStreamDetails())
           {
             CVideoDatabase dbs;
             dbs.Open();
             dbs.SetStreamDetailsForFileId(details->m_streamDetails, details->m_iFileId);
             dbs.Close();
             CUtil::DeleteVideoDatabaseDirectoryCache();
           }
         }
       }
     }
 #endif
 
 #if !defined(TARGET_DARWIN) && !defined(_LINUX)
     g_audioManager.Enable(false);
 #endif
+
+    if (item.HasPVRChannelInfoTag())
+      g_playlistPlayer.SetCurrentPlaylist(PLAYLIST_NONE);
   }
   m_bPlaybackStarting = false;
 
   if (bResult)
   {
     // we must have started, otherwise player might send this later
     if(IsPlaying())
       OnPlayBackStarted();
     else
       OnPlayBackEnded();
   }
   else
   {
     // we send this if it isn't playlistplayer that is doing this
     int next = g_playlistPlayer.GetNextSong();
     int size = g_playlistPlayer.GetPlaylist(g_playlistPlayer.GetCurrentPlaylist()).size();
     if(next < 0
     || next >= size)
       OnPlayBackStopped();
   }
 
   return bResult;
 }
 
@@ -4484,25 +4568,25 @@ bool CApplication::IsFullScreen()
 void CApplication::SaveFileState(bool bForeground /* = false */)
 {
-  if (!g_settings.GetCurrentProfile().canWriteDatabases())
+  if (m_progressTrackingItem->IsPVRChannel() || !g_settings.GetCurrentProfile().canWriteDatabases())
     return;
 
   if (bForeground)
   {
     CSaveFileStateJob job(*m_progressTrackingItem,
     *m_stackFileItemToUpdate,
     m_progressTrackingVideoResumeBookmark,
     m_progressTrackingPlayCountUpdate);
 
     // Run job in the foreground to make sure it finishes
     job.DoWork();
   }
   else
   {
     CJob* job = new CSaveFileStateJob(*m_progressTrackingItem,
         *m_stackFileItemToUpdate,
         m_progressTrackingVideoResumeBookmark,
         m_progressTrackingPlayCountUpdate);
     CJobManager::GetInstance().AddJob(job, NULL);
   }
 }
 
@@ -4573,22 +4657,25 @@ void CApplication::UpdateFileState()
 void CApplication::StopPlaying()
 {
   int iWin = g_windowManager.GetActiveWindow();
   if ( IsPlaying() )
   {
 #ifdef HAS_KARAOKE
     if( m_pKaraokeMgr )
       m_pKaraokeMgr->Stop();
 #endif
 
+    if (g_PVRManager.IsPlayingTV() || g_PVRManager.IsPlayingRadio())
+      g_PVRManager.SaveCurrentChannelSettings();
+
     if (m_pPlayer)
       m_pPlayer->CloseFile();
 
     // turn off visualisation window when stopping
     if (iWin == WINDOW_VISUALISATION
     ||  iWin == WINDOW_FULLSCREEN_VIDEO)
       g_windowManager.PreviousWindow();
 
     g_partyModeManager.Disable();
   }
 }
 
@@ -4782,91 +4869,105 @@ void CApplication::CheckScreenSaverAndDPMS()
 void CApplication::ActivateScreenSaver(bool forceType /*= false */)
 {
   m_bScreenSave = true;
 
   // Get Screensaver Mode
   m_screenSaver.reset();
   if (!CAddonMgr::Get().GetAddon(g_guiSettings.GetString("screensaver.mode"), m_screenSaver))
     m_screenSaver.reset(new CScreenSaver(""));
 
 #ifdef HAS_LCD
   // turn off lcd backlight if requested
   if (g_lcd && g_advancedSettings.m_lcdDimOnScreenSave)
     g_lcd->SetBackLight(0);
 #endif
 
   CAnnouncementManager::Announce(GUI, "xbmc", "OnScreensaverActivated");
 
   // disable screensaver lock from the login screen
   m_iScreenSaveLock = g_windowManager.GetActiveWindow() == WINDOW_LOGIN_SCREEN ? 1 : 0;
   if (!forceType)
   {
     // set to Dim in the case of a dialog on screen or playing video
-    if (g_windowManager.HasModalDialog() || (IsPlayingVideo() && g_guiSettings.GetBool("screensaver.usedimonpause")))
+    if (g_windowManager.HasModalDialog() || (IsPlayingVideo() && g_guiSettings.GetBool("screensaver.usedimonpause")) || g_PVRManager.IsRunningChannelScan())
     {
       if (!CAddonMgr::Get().GetAddon("screensaver.xbmc.builtin.dim", m_screenSaver))
         m_screenSaver.reset(new CScreenSaver(""));
     }
     // Check if we are Playing Audio and Vis instead Screensaver!
     else if (IsPlayingAudio() && g_guiSettings.GetBool("screensaver.usemusicvisinstead") && !g_guiSettings.GetString("musicplayer.visualisation").IsEmpty())
     { // activate the visualisation
       m_screenSaver.reset(new CScreenSaver("visualization"));
       g_windowManager.ActivateWindow(WINDOW_VISUALISATION);
       return;
     }
   }
   // Picture slideshow
   if (m_screenSaver->ID() == "screensaver.xbmc.builtin.slideshow")
   {
     // reset our codec info - don't want that on screen
     g_infoManager.SetShowCodec(false);
     CStdString type = m_screenSaver->GetSetting("type");
     CStdString path = m_screenSaver->GetSetting("path");
     if (type == "2" && path.IsEmpty())
       type = "0";
     if (type == "0")
       path = "special://profile/Thumbnails/Video/Fanart";
     if (type == "1")
       path = "special://profile/Thumbnails/Music/Fanart";
     CApplicationMessenger::Get().PictureSlideShow(path, true, type != "2");
   }
   else if (m_screenSaver->ID() == "screensaver.xbmc.builtin.dim")
     return;
   else if (m_screenSaver->ID() == "screensaver.xbmc.builtin.black")
     return;
   else if (!m_screenSaver->ID().IsEmpty())
     g_windowManager.ActivateWindow(WINDOW_SCREENSAVER);
 }
 
 void CApplication::CheckShutdown()
 {
   // first check if we should reset the timer
-  bool resetTimer = false;
+  bool resetTimer = m_bInhibitIdleShutdown;
+
   if (IsPlaying() || IsPaused()) // is something playing?
     resetTimer = true;
 
   if (m_musicInfoScanner->IsScanning())
     resetTimer = true;
 
   if (m_videoInfoScanner->IsScanning())
     resetTimer = true;
 
   if (g_windowManager.IsWindowActive(WINDOW_DIALOG_PROGRESS)) // progress dialog is onscreen
     resetTimer = true;
 
+  if (g_guiSettings.GetBool("pvrmanager.enabled") &&  !g_PVRManager.IsIdle())
+    resetTimer = true;
+
   if (resetTimer)
   {
     m_shutdownTimer.StartZero();
     return;
   }
 
   if ( m_shutdownTimer.GetElapsedSeconds() > g_guiSettings.GetInt("powermanagement.shutdowntime") * 60 )
   {
     // Since it is a sleep instead of a shutdown, let's set everything to reset when we wake up.
     m_shutdownTimer.Stop();
 
     // Sleep the box
     CApplicationMessenger::Get().Shutdown();
   }
 }
 
+void CApplication::InhibitIdleShutdown(bool inhibit)
+{
+  m_bInhibitIdleShutdown = inhibit;
+}
+
+bool CApplication::IsIdleShutdownInhibited() const
+{
+  return m_bInhibitIdleShutdown;
+}
+
 bool CApplication::OnMessage(CGUIMessage& message)
@@ -5914,15 +6015,20 @@ bool CApplication::ProcessAndStartPlaylist(const CStdString& strPlayList, CPlayL
 void CApplication::SaveCurrentFileSettings()
 {
-  if (m_itemCurrentFile->IsVideo())
+  // don't store settings for PVR in video database
+  if (m_itemCurrentFile->IsVideo() && !m_itemCurrentFile->IsPVRChannel())
   {
     // save video settings
     if (g_settings.m_currentVideoSettings != g_settings.m_defaultVideoSettings)
     {
       CVideoDatabase dbs;
       dbs.Open();
       dbs.SetVideoSettings(m_itemCurrentFile->GetPath(), g_settings.m_currentVideoSettings);
       dbs.Close();
     }
   }
+  else if (m_itemCurrentFile->IsPVRChannel())
+  {
+    g_PVRManager.SaveCurrentChannelSettings();
+  }
 }
 
diff --git a/xbmc/Application.h b/xbmc/Application.h
index 021aa77..9c5d6ce 100644
--- a/xbmc/Application.h
+++ b/xbmc/Application.h
@@ -110,377 +110,385 @@ class CApplication : public CXBApplicationEx, public IPlayerCallback, public IMs
 public:
 
   enum ESERVERS
   {
     ES_WEBSERVER = 1,
     ES_AIRPLAYSERVER,
     ES_JSONRPCSERVER,
     ES_UPNPRENDERER,
     ES_UPNPSERVER,
     ES_EVENTSERVER,
     ES_ZEROCONF
   };
 
   CApplication(void);
   virtual ~CApplication(void);
   virtual bool Initialize();
   virtual void FrameMove(bool processEvents, bool processGUI = true);
   virtual void Render();
   virtual bool RenderNoPresent();
   virtual void Preflight();
   virtual bool Create();
   virtual bool Cleanup();
 
   bool CreateGUI();
   bool InitWindow();
   bool DestroyWindow();
   void StartServices();
   void StopServices();
 
   bool StartServer(enum ESERVERS eServer, bool bStart, bool bWait = false);
 
   bool StartWebServer();
   void StopWebServer();
   bool StartAirplayServer();
   void StopAirplayServer(bool bWait);
   bool StartJSONRPCServer();
   void StopJSONRPCServer(bool bWait);
   void StartUPnP();
   void StopUPnP(bool bWait);
   void StartUPnPRenderer();
   void StopUPnPRenderer();
   void StartUPnPServer();
   void StopUPnPServer();
+  void StartPVRManager();
+  void StartEPGManager(void);
+  void StopPVRManager();
+  void StopEPGManager(void);
   bool StartEventServer();
   bool StopEventServer(bool bWait, bool promptuser);
   void RefreshEventServer();
   void StartZeroconf();
   void StopZeroconf();
   void DimLCDOnPlayback(bool dim);
   bool IsCurrentThread() const;
   void Stop(int exitCode);
   void RestartApp();
   void UnloadSkin(bool forReload = false);
   bool LoadUserWindows();
   void ReloadSkin();
   const CStdString& CurrentFile();
   CFileItem& CurrentFileItem();
   virtual bool OnMessage(CGUIMessage& message);
   PLAYERCOREID GetCurrentPlayer();
   virtual void OnPlayBackEnded();
   virtual void OnPlayBackStarted();
   virtual void OnPlayBackPaused();
   virtual void OnPlayBackResumed();
   virtual void OnPlayBackStopped();
   virtual void OnQueueNextItem();
   virtual void OnPlayBackSeek(int iTime, int seekOffset);
   virtual void OnPlayBackSeekChapter(int iChapter);
   virtual void OnPlayBackSpeedChanged(int iSpeed);
   bool PlayMedia(const CFileItem& item, int iPlaylist = PLAYLIST_MUSIC);
   bool PlayMediaSync(const CFileItem& item, int iPlaylist = PLAYLIST_MUSIC);
   bool ProcessAndStartPlaylist(const CStdString& strPlayList, PLAYLIST::CPlayList& playlist, int iPlaylist, int track=0);
   bool PlayFile(const CFileItem& item, bool bRestart = false);
   void SaveFileState(bool bForeground = false);
   void UpdateFileState();
   void StopPlaying();
   void Restart(bool bSamePosition = true);
   void DelayedPlayerRestart();
   void CheckDelayedPlayerRestart();
   bool IsPlaying() const;
   bool IsPaused() const;
   bool IsPlayingAudio() const;
   bool IsPlayingVideo() const;
   bool IsPlayingFullScreenVideo() const;
   bool IsStartingPlayback() const { return m_bPlaybackStarting; }
   bool IsFullScreen();
   bool OnKey(const CKey& key);
   bool OnAppCommand(const CAction &action);
   bool OnAction(const CAction &action);
   void CheckShutdown();
+  void InhibitIdleShutdown(bool inhibit);
+  bool IsIdleShutdownInhibited() const;
   // Checks whether the screensaver and / or DPMS should become active.
   void CheckScreenSaverAndDPMS();
   void CheckPlayingProgress();
   void CheckAudioScrobblerStatus();
   void CheckForTitleChange();
   void ActivateScreenSaver(bool forceType = false);
 
   virtual void Process();
   void ProcessSlow();
   void ResetScreenSaver();
   int GetVolume() const;
   void SetVolume(float iValue, bool isPercentage = true);
   bool IsMuted() const;
   void ToggleMute(void);
   void ShowVolumeBar(const CAction *action = NULL);
   int GetPlaySpeed() const;
   int GetSubtitleDelay() const;
   int GetAudioDelay() const;
   void SetPlaySpeed(int iSpeed);
   void ResetSystemIdleTimer();
   void ResetScreenSaverTimer();
   void StopScreenSaverTimer();
   // Wakes up from the screensaver and / or DPMS. Returns true if woken up.
   bool WakeUpScreenSaverAndDPMS(bool bPowerOffKeyPressed = false);
   bool WakeUpScreenSaver(bool bPowerOffKeyPressed = false);
   /*!
    \brief Returns the total time in fractional seconds of the currently playing media
 
    Beware that this method returns fractional seconds whereas IPlayer::GetTotalTime() returns milliseconds.
    */
   double GetTotalTime() const;
   /*!
    \brief Returns the current time in fractional seconds of the currently playing media
 
    Beware that this method returns fractional seconds whereas IPlayer::GetTime() returns milliseconds.
    */
   double GetTime() const;
   float GetPercentage() const;
 
   // Get the percentage of data currently cached/buffered (aq/vq + FileCache) from the input stream if applicable.
   float GetCachePercentage() const;
 
   void SeekPercentage(float percent);
   void SeekTime( double dTime = 0.0 );
 
   void StopShutdownTimer();
   void ResetShutdownTimers();
 
   void SaveMusicScanSettings();
   void RestoreMusicScanSettings();
 
   void StopVideoScan();
   void StopMusicScan();
   bool IsMusicScanning() const;
   bool IsVideoScanning() const;
 
   void StartVideoCleanup();
 
   void StartVideoScan(const CStdString &path, bool scanAll = false);
   void StartMusicScan(const CStdString &path, int flags = 0);
   void StartMusicAlbumScan(const CStdString& strDirectory, bool refresh=false);
   void StartMusicArtistScan(const CStdString& strDirectory, bool refresh=false);
 
   void UpdateLibraries();
   void CheckMusicPlaylist();
 
   bool ExecuteXBMCAction(std::string action);
 
   static bool OnEvent(XBMC_Event& newEvent);
 
 #if defined(HAS_LINUX_NETWORK)
   CNetworkLinux& getNetwork();
 #elif defined(HAS_WIN32_NETWORK)
   CNetworkWin32& getNetwork();
 #else
   CNetwork& getNetwork();
 #endif
 #ifdef HAS_PERFORMANCE_SAMPLE
   CPerformanceStats &GetPerformanceStats();
 #endif
 
 #ifdef HAS_DVD_DRIVE
   MEDIA_DETECT::CAutorun* m_Autorun;
 #endif
 
 #if !defined(_WIN32) && defined(HAS_DVD_DRIVE)
   MEDIA_DETECT::CDetectDVDMedia m_DetectDVDType;
 #endif
 
   IPlayer* m_pPlayer;
 
 #ifdef HAS_WEB_SERVER
   CWebServer& m_WebServer;
   CHTTPImageHandler& m_httpImageHandler;
   CHTTPVfsHandler& m_httpVfsHandler;
 #ifdef HAS_JSONRPC
   CHTTPJsonRpcHandler& m_httpJsonRpcHandler;
 #endif
 #ifdef HAS_HTTPAPI
   CHTTPApiHandler& m_httpApiHandler;
 #endif
 #ifdef HAS_WEB_INTERFACE
   CHTTPWebinterfaceHandler& m_httpWebinterfaceHandler;
   CHTTPWebinterfaceAddonsHandler& m_httpWebinterfaceAddonsHandler;
 #endif
 #endif
 
   inline bool IsInScreenSaver() { return m_bScreenSave; };
   int m_iScreenSaveLock; // spiff: are we checking for a lock? if so, ignore the screensaver state, if -1 we have failed to input locks
 
   bool m_bIsPaused;
   bool m_bPlaybackStarting;
 
   CKaraokeLyricsManager* m_pKaraokeMgr;
 
   PLAYERCOREID m_eForcedNextPlayer;
   CStdString m_strPlayListFile;
 
   int GlobalIdleTime();
   void NewFrame();
   bool WaitFrame(unsigned int timeout);
 
   void EnablePlatformDirectories(bool enable=true)
   {
     m_bPlatformDirectories = enable;
   }
 
   bool PlatformDirectoriesEnabled()
   {
     return m_bPlatformDirectories;
   }
 
   void SetStandAlone(bool value);
 
   bool IsStandAlone()
   {
     return m_bStandalone;
   }
 
   void SetEnableLegacyRes(bool value)
   {
     m_bEnableLegacyRes = value;
   }
 
   bool IsEnableLegacyRes()
   {
     return m_bEnableLegacyRes;
   }
 
   void SetEnableTestMode(bool value)
   {
     m_bTestMode = value;
   }
 
   bool IsEnableTestMode()
   {
     return m_bTestMode;
   }
 
   bool IsPresentFrame();
 
   void Minimize();
   bool ToggleDPMS(bool manual);
 
   float GetDimScreenSaverLevel() const;
 
   /*! \brief Retrieve the applications seek handler.
    \return a constant pointer to the seek handler.
    \sa CSeekHandler
    */
   const CSeekHandler *GetSeekHandler() const { return m_seekHandler; };
 
   bool SwitchToFullScreen();
 
   CSplash* GetSplash() { return m_splash; }
 protected:
   bool LoadSkin(const CStdString& skinID);
   void LoadSkin(const boost::shared_ptr<ADDON::CSkinInfo>& skin);
 
   bool m_skinReloading; // if true we disallow LoadSkin until ReloadSkin is called
 
 #if defined(TARGET_DARWIN_IOS)
   friend class CWinEventsIOS;
 #endif
   // screensaver
   bool m_bScreenSave;
   ADDON::AddonPtr m_screenSaver;
 
   // timer information
 #ifdef _WIN32
   CWinIdleTimer m_idleTimer;
 #else
   CStopWatch m_idleTimer;
 #endif
   CStopWatch m_restartPlayerTimer;
   CStopWatch m_frameTime;
   CStopWatch m_navigationTimer;
   CStopWatch m_slowTimer;
   CStopWatch m_screenSaverTimer;
   CStopWatch m_shutdownTimer;
 
+  bool m_bInhibitIdleShutdown;
+
   DPMSSupport* m_dpms;
   bool m_dpmsIsActive;
   bool m_dpmsIsManual;
 
   CFileItemPtr m_itemCurrentFile;
   CFileItemList* m_currentStack;
   CFileItemPtr m_stackFileItemToUpdate;
 
   CStdString m_prevMedia;
   CSplash* m_splash;
   ThreadIdentifier m_threadID;       // application thread ID.  Used in applicationMessanger to know where we are firing a thread with delay from.
   PLAYERCOREID m_eCurrentPlayer;
   bool m_bInitializing;
   bool m_bPlatformDirectories;
 
   CBookmark& m_progressTrackingVideoResumeBookmark;
   CFileItemPtr m_progressTrackingItem;
   bool m_progressTrackingPlayCountUpdate;
 
   int m_iPlaySpeed;
   int m_currentStackPosition;
   int m_nextPlaylistItem;
 
   bool m_bPresentFrame;
   unsigned int m_lastFrameTime;
   unsigned int m_lastRenderTime;
 
   bool m_bStandalone;
   bool m_bEnableLegacyRes;
   bool m_bTestMode;
   bool m_bSystemScreenSaverEnable;
 
   int        m_frameCount;
   CCriticalSection m_frameMutex;
   XbmcThreads::ConditionVariable  m_frameCond;
 
   VIDEO::CVideoInfoScanner *m_videoInfoScanner;
   MUSIC_INFO::CMusicInfoScanner *m_musicInfoScanner;
 
   void Mute();
   void UnMute();
 
   void SetHardwareVolume(float hardwareVolume);
   void UpdateLCD();
 
   void VolumeChanged() const;
 
   bool PlayStack(const CFileItem& item, bool bRestart);
   bool ProcessMouse();
   bool ProcessRemote(float frameTime);
   bool ProcessGamepad(float frameTime);
   bool ProcessEventServer(float frameTime);
   bool ProcessPeripherals(float frameTime);
   bool ProcessHTTPApiButtons();
   bool ProcessJsonRpcButtons();
   bool ProcessJoystickEvent(const std::string& joystickName, int button, bool isAxis, float fAmount, unsigned int holdTime = 0);
   int  GetActiveWindowID(void);
 
   float NavigationIdleTime();
   static bool AlwaysProcess(const CAction& action);
 
   void SaveCurrentFileSettings();
 
   bool InitDirectoriesLinux();
   bool InitDirectoriesOSX();
   bool InitDirectoriesWin32();
   void CreateUserDirs();
 
   CSeekHandler *m_seekHandler;
   CInertialScrollingHandler *m_pInertialScrollingHandler;
 #if defined(HAS_LINUX_NETWORK)
   CNetworkLinux m_network;
 #elif defined(HAS_WIN32_NETWORK)
   CNetworkWin32 m_network;
 #else
   CNetwork    m_network;
 #endif
 #ifdef HAS_PERFORMANCE_SAMPLE
   CPerformanceStats m_perfStats;
 #endif
 
 #ifdef HAS_EVENT_SERVER
   std::map<std::string, std::map<int, float> > m_lastAxisMap;
 #endif
 
 };
 
diff --git a/xbmc/ApplicationMessenger.cpp b/xbmc/ApplicationMessenger.cpp
index aa23a65..81a89f5 100644
--- a/xbmc/ApplicationMessenger.cpp
+++ b/xbmc/ApplicationMessenger.cpp
@@ -1,72 +1,77 @@
 /*
  *      Copyright (C) 2005-2008 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2, or (at your option)
  *  any later version.
  *
  *  This Program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with XBMC; see the file COPYING.  If not, write to
  *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
  *  http://www.gnu.org/copyleft/gpl.html
  *
  */
 
 #include "system.h"
 #include "ApplicationMessenger.h"
 #include "Application.h"
 
 #include "PlayListPlayer.h"
 #include "Util.h"
 #ifdef HAS_PYTHON
 #include "interfaces/python/XBPython.h"
 #endif
 #include "pictures/GUIWindowSlideShow.h"
 #include "interfaces/Builtins.h"
 #include "network/Network.h"
 #include "utils/log.h"
 #include "utils/URIUtils.h"
 #include "guilib/GUIWindowManager.h"
 #include "settings/Settings.h"
 #include "settings/GUISettings.h"
 #include "FileItem.h"
 #include "guilib/GUIDialog.h"
 #include "GUIInfoManager.h"
 #include "utils/Splash.h"
 #include "cores/VideoRenderers/RenderManager.h"
 #include "cores/AudioEngine/AEFactory.h"
 #include "music/tags/MusicInfoTag.h"
 
 #include "powermanagement/PowerManager.h"
 
 #ifdef _WIN32
 #include "WIN32Util.h"
 #define CHalManager CWIN32Util
 #elif defined(TARGET_DARWIN)
 #include "CocoaInterface.h"
 #endif
+#include "addons/AddonCallbacks.h"
+#include "addons/AddonCallbacksGUI.h"
 #include "storage/MediaManager.h"
 #include "guilib/LocalizeStrings.h"
 #include "threads/SingleLock.h"
 #ifdef HAS_PYTHON
 #include "interfaces/python/xbmcmodule/GUIPythonWindowDialog.h"
 #include "interfaces/python/xbmcmodule/GUIPythonWindowXMLDialog.h"
 #endif
 
 #ifdef HAS_HTTPAPI
 #include "interfaces/http-api/XBMChttp.h"
 #endif
 
 #include "playlists/PlayList.h"
 #include "FileItem.h"
 
 #include "ThumbLoader.h"
 
+#include "pvr/PVRManager.h"
+
+using namespace PVR;
 using namespace std;
@@ -221,597 +226,614 @@ void CApplicationMessenger::ProcessMessages()
 void CApplicationMessenger::ProcessMessage(ThreadMessage *pMsg)
 {
   switch (pMsg->dwMessage)
   {
     case TMSG_SHUTDOWN:
       {
         switch (g_guiSettings.GetInt("powermanagement.shutdownstate"))
         {
           case POWERSTATE_SHUTDOWN:
             Powerdown();
             break;
 
           case POWERSTATE_SUSPEND:
             Suspend();
             break;
 
           case POWERSTATE_HIBERNATE:
             Hibernate();
             break;
 
           case POWERSTATE_QUIT:
             Quit();
             break;
 
           case POWERSTATE_MINIMIZE:
             Minimize();
             break;
 
           case TMSG_RENDERER_FLUSH:
             g_renderManager.Flush();
             break;
         }
       }
       break;
 
-      case TMSG_POWERDOWN:
+    case TMSG_POWERDOWN:
       {
         g_application.Stop(EXITCODE_POWERDOWN);
         g_powerManager.Powerdown();
       }
       break;
 
     case TMSG_QUIT:
       {
         g_application.Stop(EXITCODE_QUIT);
       }
       break;
 
     case TMSG_HIBERNATE:
       {
+        g_PVRManager.SetWakeupCommand();
         g_powerManager.Hibernate();
       }
       break;
 
     case TMSG_SUSPEND:
       {
+        g_PVRManager.SetWakeupCommand();
         g_powerManager.Suspend();
       }
       break;
 
     case TMSG_RESTART:
     case TMSG_RESET:
       {
         g_application.Stop(EXITCODE_REBOOT);
         g_powerManager.Reboot();
       }
       break;
 
     case TMSG_RESTARTAPP:
       {
 #if defined(TARGET_WINDOWS) || defined(TARGET_LINUX)
         g_application.Stop(EXITCODE_RESTARTAPP);
 #endif
       }
       break;
 
+    case TMSG_INHIBITIDLESHUTDOWN:
+      {
+        g_application.InhibitIdleShutdown((bool)pMsg->dwParam1);
+      }
+      break;
+
     case TMSG_MEDIA_PLAY:
       {
         // first check if we were called from the PlayFile() function
         if (pMsg->lpVoid && pMsg->dwParam2 == 0)
         {
           CFileItem *item = (CFileItem *)pMsg->lpVoid;
           g_application.PlayFile(*item, pMsg->dwParam1 != 0);
           delete item;
           return;
         }
         // restore to previous window if needed
         if (g_windowManager.GetActiveWindow() == WINDOW_SLIDESHOW ||
             g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO ||
             g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION)
           g_windowManager.PreviousWindow();
 
         g_application.ResetScreenSaver();
         g_application.WakeUpScreenSaverAndDPMS();
 
         //g_application.StopPlaying();
         // play file
         if(pMsg->lpVoid)
         {
           CFileItemList *list = (CFileItemList *)pMsg->lpVoid;
 
           if (list->Size() > 0)
           {
             int playlist = PLAYLIST_MUSIC;
             for (int i = 0; i < list->Size(); i++)
             {
               if ((*list)[i]->IsVideo())
               {
                 playlist = PLAYLIST_VIDEO;
                 break;
               }
             }
 
             g_playlistPlayer.ClearPlaylist(playlist);
             g_playlistPlayer.SetCurrentPlaylist(playlist);
             //For single item lists try PlayMedia. This covers some more cases where a playlist is not appropriate
             //It will fall through to PlayFile
             if (list->Size() == 1 && !(*list)[0]->IsPlayList())
               g_application.PlayMedia(*((*list)[0]), playlist);
             else
             {
               // Handle "shuffled" option if present
               if (list->HasProperty("shuffled") && list->GetProperty("shuffled").isBoolean())
                 g_playlistPlayer.SetShuffle(playlist, list->GetProperty("shuffled").asBoolean(), false);
               // Handle "repeat" option if present
               if (list->HasProperty("repeat") && list->GetProperty("repeat").isInteger())
                 g_playlistPlayer.SetRepeat(playlist, (PLAYLIST::REPEAT_STATE)list->GetProperty("repeat").asInteger(), false);
 
               g_playlistPlayer.Add(playlist, (*list));
               g_playlistPlayer.Play(pMsg->dwParam1);
             }
           }
 
           delete list;
         }
         else if (pMsg->dwParam1 == PLAYLIST_MUSIC || pMsg->dwParam1 == PLAYLIST_VIDEO)
         {
           if (g_playlistPlayer.GetCurrentPlaylist() != (int)pMsg->dwParam1)
             g_playlistPlayer.SetCurrentPlaylist(pMsg->dwParam1);
 
           PlayListPlayerPlay(pMsg->dwParam2);
         }
       }
       break;
 
     case TMSG_MEDIA_RESTART:
       g_application.Restart(true);
       break;
 
     case TMSG_PICTURE_SHOW:
       {
         CGUIWindowSlideShow *pSlideShow = (CGUIWindowSlideShow *)g_windowManager.GetWindow(WINDOW_SLIDESHOW);
         if (!pSlideShow) return ;
 
         // stop playing file
         if (g_application.IsPlayingVideo()) g_application.StopPlaying();
 
         if (g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
           g_windowManager.PreviousWindow();
 
         g_application.ResetScreenSaver();
         g_application.WakeUpScreenSaverAndDPMS();
 
         g_graphicsContext.Lock();
 
         if (g_windowManager.GetActiveWindow() != WINDOW_SLIDESHOW)
           g_windowManager.ActivateWindow(WINDOW_SLIDESHOW);
         if (URIUtils::IsZIP(pMsg->strParam) || URIUtils::IsRAR(pMsg->strParam)) // actually a cbz/cbr
         {
           CFileItemList items;
           CStdString strPath;
           if (URIUtils::IsZIP(pMsg->strParam))
             URIUtils::CreateArchivePath(strPath, "zip", pMsg->strParam.c_str(), "");
           else
             URIUtils::CreateArchivePath(strPath, "rar", pMsg->strParam.c_str(), "");
 
           CUtil::GetRecursiveListing(strPath, items, g_settings.m_pictureExtensions);
           if (items.Size() > 0)
           {
             pSlideShow->Reset();
             for (int i=0;i<items.Size();++i)
             {
               pSlideShow->Add(items[i].get());
             }
             pSlideShow->Select(items[0]->GetPath());
           }
         }
         else
         {
           CFileItem item(pMsg->strParam, false);
           pSlideShow->Reset();
           pSlideShow->Add(&item);
           pSlideShow->Select(pMsg->strParam);
         }
         g_graphicsContext.Unlock();
       }
       break;
 
     case TMSG_SLIDESHOW_SCREENSAVER:
     case TMSG_PICTURE_SLIDESHOW:
       {
         CGUIWindowSlideShow *pSlideShow = (CGUIWindowSlideShow *)g_windowManager.GetWindow(WINDOW_SLIDESHOW);
         if (!pSlideShow) return ;
 
         if (g_application.IsPlayingVideo())
           g_application.StopPlaying();
 
         g_graphicsContext.Lock();
         pSlideShow->Reset();
 
         CFileItemList items;
         CStdString strPath = pMsg->strParam;
         CStdString extensions = g_settings.m_pictureExtensions;
         if (pMsg->dwParam1)
           extensions += "|.tbn";
         CUtil::GetRecursiveListing(strPath, items, extensions);
 
         if (items.Size() > 0)
         {
           for (int i=0;i<items.Size();++i)
             pSlideShow->Add(items[i].get());
           pSlideShow->StartSlideShow(pMsg->dwMessage == TMSG_SLIDESHOW_SCREENSAVER); //Start the slideshow!
         }
         if (pMsg->dwMessage == TMSG_SLIDESHOW_SCREENSAVER)
           pSlideShow->Shuffle();
 
         if (g_windowManager.GetActiveWindow() != WINDOW_SLIDESHOW)
         {
           if(items.Size() == 0)
           {
             g_guiSettings.SetString("screensaver.mode", "screensaver.xbmc.builtin.dim");
             g_application.ActivateScreenSaver();
           }
           else
             g_windowManager.ActivateWindow(WINDOW_SLIDESHOW);
         }
 
         g_graphicsContext.Unlock();
       }
       break;
 
     case TMSG_SETLANGUAGE:
       g_guiSettings.SetLanguage(pMsg->strParam);
       break;
     case TMSG_MEDIA_STOP:
       {
         // restore to previous window if needed
         if (g_windowManager.GetActiveWindow() == WINDOW_SLIDESHOW ||
             g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO ||
             g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION)
           g_windowManager.PreviousWindow();
 
         g_application.ResetScreenSaver();
         g_application.WakeUpScreenSaverAndDPMS();
 
         // stop playing file
         if (g_application.IsPlaying()) g_application.StopPlaying();
       }
       break;
 
     case TMSG_MEDIA_PAUSE:
       if (g_application.m_pPlayer)
       {
         g_application.ResetScreenSaver();
         g_application.WakeUpScreenSaverAndDPMS();
         g_application.m_pPlayer->Pause();
       }
       break;
 
     case TMSG_MEDIA_UNPAUSE:
       if (g_application.IsPaused())
       {
         g_application.ResetScreenSaver();
         g_application.WakeUpScreenSaverAndDPMS();
         g_application.m_pPlayer->Pause();
       }
       break;
 
     case TMSG_SWITCHTOFULLSCREEN:
       if( g_windowManager.GetActiveWindow() != WINDOW_FULLSCREEN_VIDEO )
         g_application.SwitchToFullScreen();
       break;
 
     case TMSG_TOGGLEFULLSCREEN:
       g_graphicsContext.Lock();
       g_graphicsContext.ToggleFullScreenRoot();
       g_graphicsContext.Unlock();
       break;
 
     case TMSG_MINIMIZE:
       g_application.Minimize();
       break;
 
     case TMSG_EXECUTE_OS:
       /* Suspend AE temporarily so exclusive or hog-mode sinks */
       /* don't block external player's access to audio device  */
       if (!CAEFactory::Suspend())
       {
         CLog::Log(LOGNOTICE, __FUNCTION__, "Failed to suspend AudioEngine before launching external program");
       }
 #if defined( _LINUX) && !defined(TARGET_DARWIN)
       CUtil::RunCommandLine(pMsg->strParam.c_str(), (pMsg->dwParam1 == 1));
 #elif defined(_WIN32)
       CWIN32Util::XBMCShellExecute(pMsg->strParam.c_str(), (pMsg->dwParam1 == 1));
 #endif
       /* Resume AE processing of XBMC native audio */
       if (!CAEFactory::Resume())
       {
         CLog::Log(LOGFATAL, __FUNCTION__, "Failed to restart AudioEngine after return from external player");
       }
       break;
 
     case TMSG_HTTPAPI:
     {
 #ifdef HAS_HTTPAPI
       if (!m_pXbmcHttp)
       {
         m_pXbmcHttp = new CXbmcHttp();
       }
       switch (m_pXbmcHttp->xbmcCommand(pMsg->strParam))
       {
         case 1:
           Restart();
           break;
 
         case 2:
           Shutdown();
           break;
 
         case 3:
           Quit();
           break;
 
         case 4:
           Reset();
           break;
 
         case 5:
           RestartApp();
           break;
       }
 #endif
     }
     break;
 
     case TMSG_EXECUTE_SCRIPT:
 #ifdef HAS_PYTHON
       g_pythonParser.evalFile(pMsg->strParam.c_str(),ADDON::AddonPtr());
 #endif
       break;
 
     case TMSG_EXECUTE_BUILT_IN:
       CBuiltins::Execute(pMsg->strParam.c_str());
       break;
 
     case TMSG_PLAYLISTPLAYER_PLAY:
       if (pMsg->dwParam1 != (DWORD) -1)
         g_playlistPlayer.Play(pMsg->dwParam1);
       else
         g_playlistPlayer.Play();
       break;
 
     case TMSG_PLAYLISTPLAYER_PLAY_SONG_ID:
       if (pMsg->dwParam1 != (DWORD) -1)
       {
         bool *result = (bool*)pMsg->lpVoid;
         *result = g_playlistPlayer.PlaySongId(pMsg->dwParam1);
       }
       else
         g_playlistPlayer.Play();
       break;
 
     case TMSG_PLAYLISTPLAYER_NEXT:
       g_playlistPlayer.PlayNext();
       break;
 
     case TMSG_PLAYLISTPLAYER_PREV:
       g_playlistPlayer.PlayPrevious();
       break;
 
     case TMSG_PLAYLISTPLAYER_ADD:
       if(pMsg->lpVoid)
       {
         CFileItemList *list = (CFileItemList *)pMsg->lpVoid;
 
         g_playlistPlayer.Add(pMsg->dwParam1, (*list));
         delete list;
       }
       break;
 
     case TMSG_PLAYLISTPLAYER_INSERT:
       if (pMsg->lpVoid)
       {
         CFileItemList *list = (CFileItemList *)pMsg->lpVoid;
         g_playlistPlayer.Insert(pMsg->dwParam1, (*list), pMsg->dwParam2);
         delete list;
       }
       break;
 
     case TMSG_PLAYLISTPLAYER_REMOVE:
       if (pMsg->dwParam1 != (DWORD) -1)
         g_playlistPlayer.Remove(pMsg->dwParam1,pMsg->dwParam2);
       break;
 
     case TMSG_PLAYLISTPLAYER_CLEAR:
       g_playlistPlayer.ClearPlaylist(pMsg->dwParam1);
       break;
 
     case TMSG_PLAYLISTPLAYER_SHUFFLE:
       g_playlistPlayer.SetShuffle(pMsg->dwParam1, pMsg->dwParam2 > 0);
       break;
 
     case TMSG_PLAYLISTPLAYER_REPEAT:
       g_playlistPlayer.SetRepeat(pMsg->dwParam1, (PLAYLIST::REPEAT_STATE)pMsg->dwParam2);
       break;
 
     case TMSG_PLAYLISTPLAYER_GET_ITEMS:
       if (pMsg->lpVoid)
       {
         PLAYLIST::CPlayList playlist = g_playlistPlayer.GetPlaylist(pMsg->dwParam1);
         CFileItemList *list = (CFileItemList *)pMsg->lpVoid;
 
         for (int i = 0; i < playlist.size(); i++)
           list->Add(CFileItemPtr(new CFileItem(*playlist[i])));
       }
       break;
 
     case TMSG_PLAYLISTPLAYER_SWAP:
       if (pMsg->lpVoid)
       {
         vector<int> *indexes = (vector<int> *)pMsg->lpVoid;
         if (indexes->size() == 2)
           g_playlistPlayer.Swap(pMsg->dwParam1, indexes->at(0), indexes->at(1));
         delete indexes;
       }
       break;
 
     // Window messages below here...
     case TMSG_DIALOG_DOMODAL:  //doModel of window
       {
         CGUIDialog* pDialog = (CGUIDialog*)g_windowManager.GetWindow(pMsg->dwParam1);
         if (!pDialog) return ;
         pDialog->DoModal();
       }
       break;
 
     case TMSG_NETWORKMESSAGE:
       {
         g_application.getNetwork().NetworkMessage((CNetwork::EMESSAGE)pMsg->dwParam1, (int)pMsg->dwParam2);
       }
       break;
 
     case TMSG_GUI_DO_MODAL:
       {
         CGUIDialog *pDialog = (CGUIDialog *)pMsg->lpVoid;
         if (pDialog)
           pDialog->DoModal((int)pMsg->dwParam1, pMsg->strParam);
       }
       break;
 
     case TMSG_GUI_SHOW:
       {
         CGUIDialog *pDialog = (CGUIDialog *)pMsg->lpVoid;
         if (pDialog)
           pDialog->Show();
       }
       break;
 
     case TMSG_GUI_WINDOW_CLOSE:
       {
         CGUIWindow *window = (CGUIWindow *)pMsg->lpVoid;
         if (window)
           window->Close(pMsg->dwParam2 & 0x1 ? true : false, pMsg->dwParam1, pMsg->dwParam2 & 0x2 ? true : false);
       }
       break;
 
     case TMSG_GUI_ACTIVATE_WINDOW:
       {
         g_windowManager.ActivateWindow(pMsg->dwParam1, pMsg->params, pMsg->dwParam2 > 0);
       }
       break;
 
+    case TMSG_GUI_ADDON_DIALOG:
+      {
+        if (pMsg->lpVoid)
+        { // TODO: This is ugly - really these python dialogs should just be normal XBMC dialogs
+          ((ADDON::CGUIAddonWindowDialog *) pMsg->lpVoid)->Show_Internal(pMsg->dwParam2 > 0);
+        }
+      }
+      break;
+
     case TMSG_GUI_PYTHON_DIALOG:
       {
         if (pMsg->lpVoid)
         { // TODO: This is ugly - really these python dialogs should just be normal XBMC dialogs
           if (pMsg->dwParam1)
             ((CGUIPythonWindowXMLDialog *)pMsg->lpVoid)->Show_Internal(pMsg->dwParam2 > 0);
           else
             ((CGUIPythonWindowDialog *)pMsg->lpVoid)->Show_Internal(pMsg->dwParam2 > 0);
         }
       }
       break;
 
     case TMSG_GUI_ACTION:
       {
         if (pMsg->lpVoid)
         {
           CAction *action = (CAction *)pMsg->lpVoid;
           if (pMsg->dwParam1 == WINDOW_INVALID)
             g_application.OnAction(*action);
           else
           {
             CGUIWindow *pWindow = g_windowManager.GetWindow(pMsg->dwParam1);  
             if (pWindow)
               pWindow->OnAction(*action);
             else
               CLog::Log(LOGWARNING, "Failed to get window with ID %i to send an action to", pMsg->dwParam1);
           }
           delete action;
         }
       }
       break;
 
     case TMSG_GUI_MESSAGE:
       {
         if (pMsg->lpVoid)
         {
           CGUIMessage *message = (CGUIMessage *)pMsg->lpVoid;
           g_windowManager.SendMessage(*message, pMsg->dwParam1);
           delete message;
         }
       }
       break;
 
     case TMSG_GUI_INFOLABEL:
       {
         if (pMsg->lpVoid)
         {
           vector<CStdString> *infoLabels = (vector<CStdString> *)pMsg->lpVoid;
           for (unsigned int i = 0; i < pMsg->params.size(); i++)
             infoLabels->push_back(g_infoManager.GetLabel(g_infoManager.TranslateString(pMsg->params[i])));
         }
       }
       break;
     case TMSG_GUI_INFOBOOL:
       {
         if (pMsg->lpVoid)
         {
           vector<bool> *infoLabels = (vector<bool> *)pMsg->lpVoid;
           for (unsigned int i = 0; i < pMsg->params.size(); i++)
             infoLabels->push_back(g_infoManager.EvaluateBool(pMsg->params[i]));
         }
       }
       break;
 
     case TMSG_CALLBACK:
       {
         ThreadMessageCallback *callback = (ThreadMessageCallback*)pMsg->lpVoid;
         callback->callback(callback->userptr);
       }
       break;
 
     case TMSG_VOLUME_SHOW:
       {
         CAction action((int)pMsg->dwParam1);
         g_application.ShowVolumeBar(&action);
       }
       break;
 
     case TMSG_SPLASH_MESSAGE:
       {
         if (g_application.GetSplash())
           g_application.GetSplash()->Show(pMsg->strParam);
       }
       break;
       
     case TMSG_DISPLAY_SETUP:
     {
       *((bool*)pMsg->lpVoid) = g_application.InitWindow();
       g_application.ReloadSkin();
     }
     break;
     
     case TMSG_DISPLAY_DESTROY:
     {
       *((bool*)pMsg->lpVoid) = g_application.DestroyWindow();
     }
     break;
 
     case TMSG_UPDATE_CURRENT_ITEM:
     {
       CFileItem* item = (CFileItem*)pMsg->lpVoid;
       if (!item)
         return;
       if (pMsg->dwParam1 == 1 && item->HasMusicInfoTag()) // only grab music tag
         g_infoManager.SetCurrentSongTag(*item->GetMusicInfoTag());
       else if (pMsg->dwParam1 == 2 && item->HasVideoInfoTag()) // only grab video tag
         g_infoManager.SetCurrentVideoTag(*item->GetVideoInfoTag());
       else
         g_infoManager.SetCurrentItem(*item);
       delete item;
       break;
     }
   }
 }
 
@@ -923,7 +945,7 @@ void CApplicationMessenger::PlayFile(const CFileItem &item, bool bRestart /*= fa
 
-void CApplicationMessenger::MediaStop()
+void CApplicationMessenger::MediaStop(bool bWait /* = true */)
 {
   ThreadMessage tMsg = {TMSG_MEDIA_STOP};
-  SendMessage(tMsg, true);
+  SendMessage(tMsg, bWait);
 }
 
@@ -1131,2 +1153,8 @@ void CApplicationMessenger::RestartApp()
 
+void CApplicationMessenger::InhibitIdleShutdown(bool inhibit)
+{
+  ThreadMessage tMsg = {TMSG_INHIBITIDLESHUTDOWN, (DWORD)inhibit};
+  SendMessage(tMsg);
+}
+
 void CApplicationMessenger::NetworkMessage(DWORD dwMessage, DWORD dwParam)
diff --git a/xbmc/ApplicationMessenger.h b/xbmc/ApplicationMessenger.h
index 0a3b6b6..fd19687 100644
--- a/xbmc/ApplicationMessenger.h
+++ b/xbmc/ApplicationMessenger.h
@@ -42,71 +42,73 @@ class CVideoInfoTag;
 namespace MUSIC_INFO
 {
   class CMusicInfoTag;
 }
 
 // defines here
 #define TMSG_DIALOG_DOMODAL       100
 #define TMSG_EXECUTE_SCRIPT       102
 #define TMSG_EXECUTE_BUILT_IN     103
 #define TMSG_EXECUTE_OS           104
 
 #define TMSG_MEDIA_PLAY           200
 #define TMSG_MEDIA_STOP           201
 #define TMSG_MEDIA_PAUSE          202
 #define TMSG_MEDIA_RESTART        203
 #define TMSG_MEDIA_UNPAUSE        204
 
 #define TMSG_PLAYLISTPLAYER_PLAY  210
 #define TMSG_PLAYLISTPLAYER_NEXT  211
 #define TMSG_PLAYLISTPLAYER_PREV  212
 #define TMSG_PLAYLISTPLAYER_ADD   213
 #define TMSG_PLAYLISTPLAYER_CLEAR 214
 #define TMSG_PLAYLISTPLAYER_SHUFFLE   215
 #define TMSG_PLAYLISTPLAYER_GET_ITEMS 216
 #define TMSG_PLAYLISTPLAYER_PLAY_SONG_ID 217
 #define TMSG_PLAYLISTPLAYER_INSERT 218
 #define TMSG_PLAYLISTPLAYER_REMOVE 219
 #define TMSG_PLAYLISTPLAYER_SWAP 223
 #define TMSG_PLAYLISTPLAYER_REPEAT 224
 #define TMSG_UPDATE_CURRENT_ITEM 225
 
 #define TMSG_PICTURE_SHOW         220
 #define TMSG_PICTURE_SLIDESHOW    221
 #define TMSG_SLIDESHOW_SCREENSAVER  222
 
 #define TMSG_SHUTDOWN             300
 #define TMSG_POWERDOWN            301
 #define TMSG_QUIT                 302
 #define TMSG_HIBERNATE            303
 #define TMSG_SUSPEND              304
 #define TMSG_RESTART              305
 #define TMSG_RESET                306
 #define TMSG_RESTARTAPP           307
 #define TMSG_SWITCHTOFULLSCREEN   308
 #define TMSG_MINIMIZE             309
 #define TMSG_TOGGLEFULLSCREEN     310
 #define TMSG_SETLANGUAGE          311
 #define TMSG_RENDERER_FLUSH       312
+#define TMSG_INHIBITIDLESHUTDOWN  313
 
 #define TMSG_HTTPAPI              400
 
 #define TMSG_NETWORKMESSAGE         500
 
 #define TMSG_GUI_DO_MODAL             600
 #define TMSG_GUI_SHOW                 601
 #define TMSG_GUI_ACTIVATE_WINDOW      604
 #define TMSG_GUI_PYTHON_DIALOG        605
 #define TMSG_GUI_WINDOW_CLOSE         606
 #define TMSG_GUI_ACTION               607
 #define TMSG_GUI_INFOLABEL            608
 #define TMSG_GUI_INFOBOOL             609
-#define TMSG_GUI_MESSAGE              610
+#define TMSG_GUI_ADDON_DIALOG         610
+#define TMSG_GUI_MESSAGE              611
 
 #define TMSG_CALLBACK             800
 
 #define TMSG_VOLUME_SHOW          900
 #define TMSG_SPLASH_MESSAGE       901
 
 #define TMSG_DISPLAY_SETUP      1000
 #define TMSG_DISPLAY_DESTROY    1001
 
@@ -144,93 +146,94 @@ class CApplicationMessenger
 public:
   /*!
    \brief The only way through which the global instance of the CApplicationMessenger should be accessed.
    \return the global instance.
    */
   static CApplicationMessenger& Get();
 
   void Cleanup();
   // if a message has to be send to the gui, use MSG_TYPE_WINDOW instead
   void SendMessage(ThreadMessage& msg, bool wait = false);
   void ProcessMessages(); // only call from main thread.
   void ProcessWindowMessages();
 
 
   void MediaPlay(std::string filename);
   void MediaPlay(const CFileItem &item);
   void MediaPlay(const CFileItemList &item, int song = 0);
   void MediaPlay(int playlistid, int song = -1);
-  void MediaStop();
+  void MediaStop(bool bWait = true);
   void MediaPause();
   void MediaRestart(bool bWait);
 
   void PlayListPlayerPlay();
   void PlayListPlayerPlay(int iSong);
   bool PlayListPlayerPlaySongId(int songId);
   void PlayListPlayerNext();
   void PlayListPlayerPrevious();
   void PlayListPlayerAdd(int playlist, const CFileItem &item);
   void PlayListPlayerAdd(int playlist, const CFileItemList &list);
   void PlayListPlayerClear(int playlist);
   void PlayListPlayerShuffle(int playlist, bool shuffle);
   void PlayListPlayerGetItems(int playlist, CFileItemList &list);
   void PlayListPlayerInsert(int playlist, const CFileItem &item, int position); 
   void PlayListPlayerInsert(int playlist, const CFileItemList &list, int position);
   void PlayListPlayerRemove(int playlist, int position);
   void PlayListPlayerSwap(int playlist, int indexItem1, int indexItem2);
   void PlayListPlayerRepeat(int playlist, int repeatState);
 
   void PlayFile(const CFileItem &item, bool bRestart = false); // thread safe version of g_application.PlayFile()
   void PictureShow(std::string filename);
   void PictureSlideShow(std::string pathname, bool bScreensaver = false, bool addTBN = false);
   void SetGUILanguage(const std::string &strLanguage);
   void Shutdown();
   void Powerdown();
   void Quit();
   void Hibernate();
   void Suspend();
   void Restart();
   void RestartApp();
   void Reset();
+  void InhibitIdleShutdown(bool inhibit);
   void SwitchToFullscreen(); //
   void Minimize(bool wait = false);
   void ExecOS(const CStdString command, bool waitExit = false);
   void UserEvent(int code);
   //! \brief Set the tag for the currently playing song
   void SetCurrentSongTag(const MUSIC_INFO::CMusicInfoTag& tag);
   //! \brief Set the tag for the currently playing video
   void SetCurrentVideoTag(const CVideoInfoTag& tag);
   //! \brief Set the currently currently item
   void SetCurrentItem(const CFileItem& item);
 
   CStdString GetResponse();
   int SetResponse(CStdString response);
   void HttpApi(std::string cmd, bool wait = false);
   void ExecBuiltIn(const CStdString &command, bool wait = false);
 
   void NetworkMessage(DWORD dwMessage, DWORD dwParam = 0);
 
   void DoModal(CGUIDialog *pDialog, int iWindowID, const CStdString &param = "");
   void Show(CGUIDialog *pDialog);
   void Close(CGUIWindow *window, bool forceClose, bool waitResult = true, int nextWindowID = 0, bool enableSound = true);
   void ActivateWindow(int windowID, const std::vector<CStdString> &params, bool swappingWindows);
   void SendAction(const CAction &action, int windowID = WINDOW_INVALID, bool waitResult=true);
 
   /*! \brief Send a GUIMessage, optionally waiting before it's processed to return.
    Should be used to send messages to the GUI from other threads.
    \param msg the GUIMessage to send.
    \param windowID optional window to send the message to (defaults to no specified window).
    \param waitResult whether to wait for the result (defaults to false).
    */
   void SendGUIMessage(const CGUIMessage &msg, int windowID = WINDOW_INVALID, bool waitResult=false);
 
   std::vector<CStdString> GetInfoLabels(const std::vector<CStdString> &properties);
   std::vector<bool> GetInfoBooleans(const std::vector<CStdString> &properties);
 
   void ShowVolumeBar(bool up);
 
   void SetSplashMessage(const CStdString& message);
   void SetSplashMessage(int stringID);
   
   bool SetupDisplay();
   bool DestroyDisplay();
 
diff --git a/xbmc/DatabaseManager.cpp b/xbmc/DatabaseManager.cpp
index a23ce08..2f34415 100644
--- a/xbmc/DatabaseManager.cpp
+++ b/xbmc/DatabaseManager.cpp
@@ -1,32 +1,36 @@
 /*
  *      Copyright (C) 2012 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2, or (at your option)
  *  any later version.
  *
  *  This Program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with XBMC; see the file COPYING.  If not, write to
  *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
  *  http://www.gnu.org/copyleft/gpl.html
  *
  */
 
 #include "DatabaseManager.h"
 #include "utils/log.h"
 #include "addons/AddonDatabase.h"
 #include "ViewDatabase.h"
 #include "TextureDatabase.h"
 #include "music/MusicDatabase.h"
 #include "video/VideoDatabase.h"
+#include "pvr/PVRDatabase.h"
+#include "epg/EpgDatabase.h"
 #include "settings/AdvancedSettings.h"
 
 using namespace std;
+using namespace EPG;
+using namespace PVR;
 
@@ -47,14 +51,16 @@ CDatabaseManager::~CDatabaseManager()
 void CDatabaseManager::Initialize(bool addonsOnly)
 {
   Deinitialize();
   { CAddonDatabase db; UpdateDatabase(db); }
   if (addonsOnly)
     return;
   CLog::Log(LOGDEBUG, "%s, updating databases...", __FUNCTION__);
   { CViewDatabase db; UpdateDatabase(db); }
   { CTextureDatabase db; UpdateDatabase(db); }
   { CMusicDatabase db; UpdateDatabase(db, &g_advancedSettings.m_databaseMusic); }
   { CVideoDatabase db; UpdateDatabase(db, &g_advancedSettings.m_databaseVideo); }
+  { CPVRDatabase db; UpdateDatabase(db, &g_advancedSettings.m_databaseTV); }
+  { CEpgDatabase db; UpdateDatabase(db, &g_advancedSettings.m_databaseEpg); }
   CLog::Log(LOGDEBUG, "%s, updating databases... DONE", __FUNCTION__);
 }
 
diff --git a/xbmc/FileItem.cpp b/xbmc/FileItem.cpp
index f35fed4..8512e4d 100644
--- a/xbmc/FileItem.cpp
+++ b/xbmc/FileItem.cpp
@@ -1,56 +1,61 @@
 /*
  *      Copyright (C) 2005-2008 Team XBMC
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2, or (at your option)
  *  any later version.
  *
  *  This Program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with XBMC; see the file COPYING.  If not, write to
  *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
  *  http://www.gnu.org/copyleft/gpl.html
  *
  */
 
 #include "FileItem.h"
 #include "guilib/LocalizeStrings.h"
 #include "utils/StringUtils.h"
 #include "utils/URIUtils.h"
 #include "Util.h"
 #include "playlists/PlayListFactory.h"
 #include "utils/Crc32.h"
 #include "filesystem/Directory.h"
 #include "filesystem/StackDirectory.h"
 #include "filesystem/CurlFile.h"
 #include "filesystem/MultiPathDirectory.h"
 #include "filesystem/MusicDatabaseDirectory.h"
 #include "filesystem/VideoDatabaseDirectory.h"
 #include "music/tags/MusicInfoTagLoaderFactory.h"
 #include "CueDocument.h"
 #include "video/VideoDatabase.h"
 #include "music/MusicDatabase.h"
 #include "utils/TuxBoxUtil.h"
+#include "epg/Epg.h"
+#include "pvr/channels/PVRChannel.h"
+#include "pvr/recordings/PVRRecording.h"
+#include "pvr/timers/PVRTimerInfoTag.h"
+#include "utils/Observer.h"
 #include "video/VideoInfoTag.h"
 #include "threads/SingleLock.h"
 #include "music/tags/MusicInfoTag.h"
 #include "pictures/PictureInfoTag.h"
 #include "music/Artist.h"
 #include "music/Album.h"
 #include "music/Song.h"
 #include "URL.h"
 #include "settings/GUISettings.h"
 #include "settings/AdvancedSettings.h"
 #include "settings/Settings.h"
 #include "utils/RegExp.h"
 #include "utils/log.h"
 #include "utils/Variant.h"
 #include "music/karaoke/karaokelyricsfactory.h"
 #include "utils/Mime.h"
 
@@ -60,289 +65,533 @@ using namespace PLAYLIST;
 using namespace MUSIC_INFO;
+using namespace PVR;
+using namespace EPG;
 
 CFileItem::CFileItem(const CSong& song)
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   SetLabel(song.strTitle);
   m_strPath = song.strFileName;
   GetMusicInfoTag()->SetSong(song);
   m_lStartOffset = song.iStartOffset;
   m_lStartPartNumber = 0;
   SetProperty("item_start", song.iStartOffset);
   m_lEndOffset = song.iEndOffset;
   m_strThumbnailImage = song.strThumb;
 }
 
 CFileItem::CFileItem(const CStdString &path, const CAlbum& album)
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   SetLabel(album.strAlbum);
   m_strPath = path;
   m_bIsFolder = true;
   m_strLabel2 = StringUtils::Join(album.artist, g_advancedSettings.m_musicItemSeparator);
   URIUtils::AddSlashAtEnd(m_strPath);
   GetMusicInfoTag()->SetAlbum(album);
   m_bIsAlbum = true;
   CMusicDatabase::SetPropertiesFromAlbum(*this,album);
 }
 
 CFileItem::CFileItem(const CMusicInfoTag& music)
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   SetLabel(music.GetTitle());
   m_strPath = music.GetURL();
   m_bIsFolder = URIUtils::HasSlashAtEnd(m_strPath);
   *GetMusicInfoTag() = music;
   FillInDefaultIcon();
 }
 
 CFileItem::CFileItem(const CVideoInfoTag& movie)
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   SetLabel(movie.m_strTitle);
   if (movie.m_strFileNameAndPath.IsEmpty())
   {
     m_strPath = movie.m_strPath;
     URIUtils::AddSlashAtEnd(m_strPath);
     m_bIsFolder = true;
   }
   else
   {
     m_strPath = movie.m_strFileNameAndPath;
     m_bIsFolder = false;
   }
   *GetVideoInfoTag() = movie;
   if (movie.m_iSeason == 0) SetProperty("isspecial", "true");
   FillInDefaultIcon();
 }
 
+CFileItem::CFileItem(const CEpgInfoTag& tag)
+{
+  m_musicInfoTag = NULL;
+  m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
+  m_pictureInfoTag = NULL;
+
+  Reset();
+
+  m_strPath = tag.Path();
+  m_bIsFolder = false;
+  *GetEPGInfoTag() = tag;
+  SetLabel(tag.Title());
+  m_strLabel2 = tag.Plot();
+  m_dateTime = tag.StartAsLocalTime();
+
+  if (!tag.Icon().IsEmpty())
+  {
+    SetThumbnailImage(tag.Icon());
+    SetIconImage(tag.Icon());
+  }
+}
+
+CFileItem::CFileItem(const CPVRChannel& channel)
+{
+  m_musicInfoTag = NULL;
+  m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
+  m_pictureInfoTag = NULL;
+
+  Reset();
+  CEpgInfoTag epgNow;
+  bool bHasEpgNow = channel.GetEPGNow(epgNow);
+
+  m_strPath = channel.Path();
+  m_bIsFolder = false;
+  *GetPVRChannelInfoTag() = channel;
+  SetLabel(channel.ChannelName());
+  m_strLabel2 = bHasEpgNow ? epgNow.Title() :
+      g_guiSettings.GetBool("epg.hidenoinfoavailable") ?
+        StringUtils::EmptyString :
+        g_localizeStrings.Get(19055); // no information available
+
+  if (channel.IsRadio() && bHasEpgNow)
+  {
+    CMusicInfoTag* musictag = GetMusicInfoTag();
+    if (musictag)
+    {
+      musictag->SetURL(channel.Path());
+      musictag->SetTitle(m_strLabel2);
+      musictag->SetArtist(channel.ChannelName());
+      musictag->SetAlbumArtist(channel.ChannelName());
+      if (bHasEpgNow)
+        musictag->SetGenre(epgNow.Genre());
+      musictag->SetDuration(bHasEpgNow ? epgNow.GetDuration() : 3600);
+      musictag->SetLoaded(true);
+      musictag->SetComment("");
+      musictag->SetLyrics("");
+    }
+  }
+
+  if (!channel.IconPath().IsEmpty())
+  {
+    SetThumbnailImage(channel.IconPath());
+    SetIconImage(channel.IconPath());
+  }
+
+  SetProperty("channelid", channel.ChannelID());
+  SetProperty("path", channel.Path());
+}
+
+CFileItem::CFileItem(const CPVRRecording& record)
+{
+  m_musicInfoTag = NULL;
+  m_videoInfoTag = NULL;
+  m_epgInfoTag   = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
+  m_pictureInfoTag = NULL;
+
+  Reset();
+
+  m_strPath = record.m_strFileNameAndPath;
+  m_bIsFolder = false;
+  *GetPVRRecordingInfoTag() = record;
+  SetLabel(record.m_strTitle);
+  m_strLabel2 = record.m_strPlot;
+}
+
+CFileItem::CFileItem(const CPVRTimerInfoTag& timer)
+{
+  m_musicInfoTag = NULL;
+  m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
+  m_pictureInfoTag = NULL;
+
+  Reset();
+
+  m_strPath = timer.Path();
+  m_bIsFolder = false;
+  *GetPVRTimerInfoTag() = timer;
+  SetLabel(timer.Title());
+  m_strLabel2 = timer.Summary();
+  m_dateTime = timer.StartAsLocalTime();
+
+  if (!timer.ChannelIcon().IsEmpty())
+  {
+    SetThumbnailImage(timer.ChannelIcon());
+    SetIconImage(timer.ChannelIcon());
+  }
+}
+
 CFileItem::CFileItem(const CArtist& artist)
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   SetLabel(artist.strArtist);
   m_strPath = artist.strArtist;
   m_bIsFolder = true;
   URIUtils::AddSlashAtEnd(m_strPath);
   GetMusicInfoTag()->SetArtist(artist.strArtist);
 }
 
 CFileItem::CFileItem(const CGenre& genre)
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   SetLabel(genre.strGenre);
   m_strPath = genre.strGenre;
   m_bIsFolder = true;
   URIUtils::AddSlashAtEnd(m_strPath);
   GetMusicInfoTag()->SetGenre(genre.strGenre);
 }
 
 CFileItem::CFileItem(const CFileItem& item): CGUIListItem()
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   *this = item;
 }
 
 CFileItem::CFileItem(const CGUIListItem& item)
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   // not particularly pretty, but it gets around the issue of Reset() defaulting
   // parameters in the CGUIListItem base class.
   *((CGUIListItem *)this) = item;
 }
 
 CFileItem::CFileItem(void)
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
 }
 
 CFileItem::CFileItem(const CStdString& strLabel)
     : CGUIListItem()
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   SetLabel(strLabel);
 }
 
 CFileItem::CFileItem(const CStdString& strPath, bool bIsFolder)
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   m_strPath = strPath;
   m_bIsFolder = bIsFolder;
   // tuxbox urls cannot have a / at end
   if (m_bIsFolder && !m_strPath.IsEmpty() && !IsFileFolder() && !URIUtils::IsTuxBox(m_strPath))
     URIUtils::AddSlashAtEnd(m_strPath);
 }
 
 CFileItem::CFileItem(const CMediaSource& share)
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   m_bIsFolder = true;
   m_bIsShareOrDrive = true;
   m_strPath = share.strPath;
   URIUtils::AddSlashAtEnd(m_strPath);
   CStdString label = share.strName;
   if (!share.strStatus.IsEmpty())
     label.Format("%s (%s)", share.strName.c_str(), share.strStatus.c_str());
   SetLabel(label);
   m_iLockMode = share.m_iLockMode;
   m_strLockCode = share.m_strLockCode;
   m_iHasLock = share.m_iHasLock;
   m_iBadPwdCount = share.m_iBadPwdCount;
   m_iDriveType = share.m_iDriveType;
   m_strThumbnailImage = share.m_strThumbnailImage;
   SetLabelPreformated(true);
   if (IsDVD())
     GetVideoInfoTag()->m_strFileNameAndPath = share.strDiskUniqueId; // share.strDiskUniqueId contains disc unique id
 }
 
 CFileItem::~CFileItem(void)
 {
   delete m_musicInfoTag;
   delete m_videoInfoTag;
+  delete m_epgInfoTag;
+  delete m_pvrChannelInfoTag;
+  delete m_pvrRecordingInfoTag;
+  delete m_pvrTimerInfoTag;
   delete m_pictureInfoTag;
 
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
 }
 
 const CFileItem& CFileItem::operator=(const CFileItem& item)
 {
   if (this == &item) return * this;
   CGUIListItem::operator=(item);
   m_bLabelPreformated=item.m_bLabelPreformated;
   FreeMemory();
   m_strPath = item.GetPath();
   m_bIsParentFolder = item.m_bIsParentFolder;
   m_iDriveType = item.m_iDriveType;
   m_bIsShareOrDrive = item.m_bIsShareOrDrive;
   m_dateTime = item.m_dateTime;
   m_dwSize = item.m_dwSize;
   if (item.HasMusicInfoTag())
   {
     m_musicInfoTag = GetMusicInfoTag();
     if (m_musicInfoTag)
       *m_musicInfoTag = *item.m_musicInfoTag;
   }
   else
   {
     delete m_musicInfoTag;
     m_musicInfoTag = NULL;
   }
 
   if (item.HasVideoInfoTag())
   {
     m_videoInfoTag = GetVideoInfoTag();
     if (m_videoInfoTag)
       *m_videoInfoTag = *item.m_videoInfoTag;
   }
   else
   {
     delete m_videoInfoTag;
     m_videoInfoTag = NULL;
   }
 
+  if (item.HasEPGInfoTag())
+  {
+    m_epgInfoTag = GetEPGInfoTag();
+    if (m_epgInfoTag)
+      *m_epgInfoTag = *item.m_epgInfoTag;
+  }
+  else
+  {
+    if (m_epgInfoTag)
+      delete m_epgInfoTag;
+
+    m_epgInfoTag = NULL;
+  }
+
+  if (item.HasPVRChannelInfoTag())
+  {
+    m_pvrChannelInfoTag = GetPVRChannelInfoTag();
+    if (m_pvrChannelInfoTag)
+      *m_pvrChannelInfoTag = *item.m_pvrChannelInfoTag;
+  }
+  else
+  {
+    if (m_pvrChannelInfoTag)
+      delete m_pvrChannelInfoTag;
+
+    m_pvrChannelInfoTag = NULL;
+  }
+
+  if (item.HasPVRRecordingInfoTag())
+  {
+    m_pvrRecordingInfoTag = GetPVRRecordingInfoTag();
+    if (m_pvrRecordingInfoTag)
+      *m_pvrRecordingInfoTag = *item.m_pvrRecordingInfoTag;
+  }
+  else
+  {
+    if (m_pvrRecordingInfoTag)
+      delete m_pvrRecordingInfoTag;
+
+    m_pvrRecordingInfoTag = NULL;
+  }
+
+  if (item.HasPVRTimerInfoTag())
+  {
+    m_pvrTimerInfoTag = GetPVRTimerInfoTag();
+    if (m_pvrTimerInfoTag)
+      *m_pvrTimerInfoTag = *item.m_pvrTimerInfoTag;
+  }
+  else
+  {
+    if (m_pvrTimerInfoTag)
+      delete m_pvrTimerInfoTag;
+
+    m_pvrTimerInfoTag = NULL;
+  }
+
   if (item.HasPictureInfoTag())
   {
     m_pictureInfoTag = GetPictureInfoTag();
     if (m_pictureInfoTag)
       *m_pictureInfoTag = *item.m_pictureInfoTag;
   }
   else
   {
     delete m_pictureInfoTag;
     m_pictureInfoTag = NULL;
   }
 
   m_lStartOffset = item.m_lStartOffset;
   m_lStartPartNumber = item.m_lStartPartNumber;
   m_lEndOffset = item.m_lEndOffset;
   m_strDVDLabel = item.m_strDVDLabel;
   m_strTitle = item.m_strTitle;
   m_iprogramCount = item.m_iprogramCount;
   m_idepth = item.m_idepth;
   m_iLockMode = item.m_iLockMode;
   m_strLockCode = item.m_strLockCode;
   m_iHasLock = item.m_iHasLock;
   m_iBadPwdCount = item.m_iBadPwdCount;
   m_bCanQueue=item.m_bCanQueue;
   m_mimetype = item.m_mimetype;
   m_extrainfo = item.m_extrainfo;
   m_specialSort = item.m_specialSort;
   m_bIsAlbum = item.m_bIsAlbum;
   return *this;
 }
 
 void CFileItem::Reset()
 {
   m_strLabel2.Empty();
   SetLabel("");
   m_bLabelPreformated=false;
   FreeIcons();
   m_overlayIcon = ICON_OVERLAY_NONE;
   m_bSelected = false;
   m_bIsAlbum = false;
   m_strDVDLabel.Empty();
   m_strTitle.Empty();
   m_strPath.Empty();
   m_dwSize = 0;
   m_bIsFolder = false;
   m_bIsParentFolder=false;
   m_bIsShareOrDrive = false;
   m_dateTime.Reset();
   m_iDriveType = CMediaSource::SOURCE_TYPE_UNKNOWN;
   m_lStartOffset = 0;
   m_lStartPartNumber = 0;
   m_lEndOffset = 0;
   m_iprogramCount = 0;
   m_idepth = 1;
   m_iLockMode = LOCK_MODE_EVERYONE;
   m_strLockCode = "";
   m_iBadPwdCount = 0;
   m_iHasLock = 0;
   m_bCanQueue=true;
   m_mimetype = "";
   delete m_musicInfoTag;
   m_musicInfoTag=NULL;
   delete m_videoInfoTag;
   m_videoInfoTag=NULL;
+  delete m_epgInfoTag;
+  m_epgInfoTag=NULL;
+  delete m_pvrChannelInfoTag;
+  m_pvrChannelInfoTag=NULL;
+  delete m_pvrRecordingInfoTag;
+  m_pvrRecordingInfoTag=NULL;
+  delete m_pvrTimerInfoTag;
+  m_pvrTimerInfoTag=NULL;
   delete m_pictureInfoTag;
   m_pictureInfoTag=NULL;
   m_extrainfo.Empty();
   m_specialSort = SortSpecialNone;
   SetInvalid();
 }
 
@@ -465,28 +714,31 @@ void CFileItem::Serialize(CVariant& value)
 void CFileItem::ToSortable(SortItem &sortable)
 {
   sortable[FieldPath] = m_strPath;
   sortable[FieldDate] = (m_dateTime.IsValid()) ? m_dateTime.GetAsDBDateTime() : "";
   sortable[FieldSize] = m_dwSize;
   sortable[FieldDriveType] = m_iDriveType;
   sortable[FieldStartOffset] = m_lStartOffset;
   sortable[FieldStartOffset] = m_lEndOffset;
   sortable[FieldProgramCount] = m_iprogramCount;
   sortable[FieldBitrate] = m_dwSize;
   sortable[FieldTitle] = m_strTitle;
   sortable[FieldSortSpecial] = m_specialSort;
   sortable[FieldFolder] = m_bIsFolder;
 
   // If there's ever a need to convert more properties from CGUIListItem it might be
   // worth to make CGUIListItem  implement ISortable as well and call it from here
   sortable[FieldLabel] = GetLabel();
 
   if (HasMusicInfoTag())
     GetMusicInfoTag()->ToSortable(sortable);
     
   if (HasVideoInfoTag())
     GetVideoInfoTag()->ToSortable(sortable);
     
   if (HasPictureInfoTag())
     GetPictureInfoTag()->ToSortable(sortable);
+
+  if (HasPVRChannelInfoTag())
+    GetPVRChannelInfoTag()->ToSortable(sortable);
 }
 
@@ -525,34 +777,59 @@ bool CFileItem::Exists(bool bUseCache /* = true */) const
 bool CFileItem::IsVideo() const
 {
   /* check preset mime type */
   if( m_mimetype.Left(6).Equals("video/") )
     return true;
 
   if (HasVideoInfoTag()) return true;
   if (HasMusicInfoTag()) return false;
   if (HasPictureInfoTag()) return false;
+  if (IsPVRRecording())  return true;
 
   if (IsHDHomeRun() || IsTuxBox() || URIUtils::IsDVD(m_strPath) || IsSlingbox())
     return true;
 
   CStdString extension;
   if( m_mimetype.Left(12).Equals("application/") )
   { /* check for some standard types */
     extension = m_mimetype.Mid(12);
     if( extension.Equals("ogg")
      || extension.Equals("mp4")
      || extension.Equals("mxf") )
      return true;
   }
 
   URIUtils::GetExtension(m_strPath, extension);
 
   if (extension.IsEmpty())
     return false;
 
   extension.ToLower();
 
   return (g_settings.m_videoExtensions.Find(extension) != -1);
 }
 
+bool CFileItem::IsEPG() const
+{
+  if (HasEPGInfoTag()) return true; /// is this enough?
+  return false;
+}
+
+bool CFileItem::IsPVRChannel() const
+{
+  if (HasPVRChannelInfoTag()) return true; /// is this enough?
+  return false;
+}
+
+bool CFileItem::IsPVRRecording() const
+{
+  if (HasPVRRecordingInfoTag()) return true; /// is this enough?
+  return false;
+}
+
+bool CFileItem::IsPVRTimer() const
+{
+  if (HasPVRTimerInfoTag()) return true; /// is this enough?
+  return false;
+}
+
 bool CFileItem::IsDiscStub() const
@@ -884,2 +1161,7 @@ bool CFileItem::IsVTP() const
 
+bool CFileItem::IsPVR() const
+{
+  return CUtil::IsPVR(m_strPath);
+}
+
 bool CFileItem::IsLiveTV() const
@@ -924,80 +1206,100 @@ bool CFileItem::IsReadOnly() const
 void CFileItem::FillInDefaultIcon()
 {
   //CLog::Log(LOGINFO, "FillInDefaultIcon(%s)", pItem->GetLabel().c_str());
   // find the default icon for a file or folder item
   // for files this can be the (depending on the file type)
   //   default picture for photo's
   //   default picture for songs
   //   default picture for videos
   //   default picture for shortcuts
   //   default picture for playlists
   //   or the icon embedded in an .xbe
   //
   // for folders
   //   for .. folders the default picture for parent folder
   //   for other folders the defaultFolder.png
 
   if (GetIconImage().IsEmpty())
   {
     if (!m_bIsFolder)
     {
       /* To reduce the average runtime of this code, this list should
        * be ordered with most frequently seen types first.  Also bear
        * in mind the complexity of the code behind the check in the
        * case of IsWhatater() returns false.
        */
-      if ( IsAudio() )
+      if (IsPVRChannel())
+      {
+        if (GetPVRChannelInfoTag()->IsRadio())
+          SetIconImage("DefaultAudio.png");
+        else
+          SetIconImage("DefaultVideo.png");
+      }
+      else if ( IsLiveTV() )
+      {
+        // Live TV Channel
+        SetIconImage("DefaultVideo.png");
+      }
+      else if ( IsAudio() )
       {
         // audio
         SetIconImage("DefaultAudio.png");
       }
       else if ( IsVideo() )
       {
         // video
         SetIconImage("DefaultVideo.png");
       }
+      else if (IsPVRRecording())
+      {
+        SetIconImage("DefaultVideo.png");
+      }
+      else if (IsPVRTimer())
+      {
+        SetIconImage("DefaultVideo.png");
+      }
       else if ( IsPicture() )
       {
         // picture
         SetIconImage("DefaultPicture.png");
       }
       else if ( IsPlayList() )
       {
         SetIconImage("DefaultPlaylist.png");
       }
       else if ( IsPythonScript() )
       {
         SetIconImage("DefaultScript.png");
       }
       else
       {
         // default icon for unknown file type
         SetIconImage("DefaultFile.png");
       }
     }
     else
     {
       if ( IsPlayList() )
       {
         SetIconImage("DefaultPlaylist.png");
       }
       else if (IsParentFolder())
       {
         SetIconImage("DefaultFolderBack.png");
       }
       else
       {
         SetIconImage("DefaultFolder.png");
       }
     }
   }
   // Set the icon overlays (if applicable)
   if (!HasOverlay())
   {
     if (URIUtils::IsInRAR(m_strPath))
       SetOverlayImage(CGUIListItem::ICON_OVERLAY_RAR);
     else if (URIUtils::IsInZIP(m_strPath))
       SetOverlayImage(CGUIListItem::ICON_OVERLAY_ZIP);
   }
 }
 
@@ -1035,2 +1337,8 @@ void CFileItem::SetLabel(const CStdString &strLabel)
 
+void CFileItem::SetLabel2(const CStdString &strLabel)
+{
+  m_strLabel2 = strLabel;
+}
+
+
 void CFileItem::SetFileSizeLabel()
@@ -1499,160 +1807,163 @@ void CFileItemList::FillSortFields(FILEITEMFILLFUNC func)
 void CFileItemList::Sort(SORT_METHOD sortMethod, SortOrder sortOrder)
 {
   //  Already sorted?
   if (sortMethod == m_sortMethod && m_sortOrder == sortOrder)
     return;
 
   SortBy sortBy = SortByNone;
   SortAttribute sortAttributes = SortAttributeNone;
 
   switch (sortMethod)
   {
   case SORT_METHOD_LABEL:
   case SORT_METHOD_LABEL_IGNORE_FOLDERS:
   case SORT_METHOD_LABEL_IGNORE_THE:
     sortBy = SortByLabel;
     break;
   case SORT_METHOD_DATE:
     sortBy = SortByDate;
     break;
   case SORT_METHOD_SIZE:
     sortBy = SortBySize;
     break;
   case SORT_METHOD_BITRATE:
     sortBy = SortByBitrate;
     break;      
   case SORT_METHOD_DRIVE_TYPE:
     sortBy = SortByDriveType;
     break;
   case SORT_METHOD_TRACKNUM:
     sortBy = SortByTrackNumber;
     break;
   case SORT_METHOD_EPISODE:
     sortBy = SortByEpisodeNumber;
     break;
   case SORT_METHOD_DURATION:
   case SORT_METHOD_VIDEO_RUNTIME:
     sortBy = SortByTime;
     break;
   case SORT_METHOD_TITLE:
   case SORT_METHOD_TITLE_IGNORE_THE:
   case SORT_METHOD_VIDEO_TITLE:
     sortBy = SortByTitle;
     break;
   case SORT_METHOD_ARTIST:
   case SORT_METHOD_ARTIST_IGNORE_THE:
     sortBy = SortByArtist;
     break;
   case SORT_METHOD_ALBUM:
   case SORT_METHOD_ALBUM_IGNORE_THE:
     sortBy = SortByAlbum;
     break;
   case SORT_METHOD_GENRE:
     sortBy = SortByGenre;
     break;
   case SORT_METHOD_COUNTRY:
     sortBy = SortByCountry;
     break;
   case SORT_METHOD_DATEADDED:
     sortBy = SortByDateAdded;
     break;
   case SORT_METHOD_FILE:
     sortBy = SortByFile;
     break;
   case SORT_METHOD_SONG_RATING:
   case SORT_METHOD_VIDEO_RATING:
     sortBy = SortByRating;
     break;
   case SORT_METHOD_VIDEO_SORT_TITLE:
   case SORT_METHOD_VIDEO_SORT_TITLE_IGNORE_THE:
     sortBy = SortBySortTitle;
     break;
   case SORT_METHOD_YEAR:
     sortBy = SortByYear;
     break;
   case SORT_METHOD_PRODUCTIONCODE:
     sortBy = SortByProductionCode;
     break;
   case SORT_METHOD_PROGRAM_COUNT:
     sortBy = SortByProgramCount;
     break;
   case SORT_METHOD_PLAYLIST_ORDER:
     sortBy = SortByPlaylistOrder;
     break;
   case SORT_METHOD_MPAA_RATING:
     sortBy = SortByMPAA;
     break;
   case SORT_METHOD_STUDIO:
   case SORT_METHOD_STUDIO_IGNORE_THE:
     sortBy = SortByStudio;
     break;
   case SORT_METHOD_FULLPATH:
     sortBy = SortByPath;
     break;
   case SORT_METHOD_LASTPLAYED:
     sortBy = SortByLastPlayed;
     break;
   case SORT_METHOD_PLAYCOUNT:
     sortBy = SortByPlaycount;
     break;
   case SORT_METHOD_LISTENERS:
     sortBy = SortByListeners;
     break;    
+  case SORT_METHOD_CHANNEL:
+    sortBy = SortByChannel;
+    break;
   default:
     CLog::Log(LOGWARNING, "Unknown sort method %d", sortMethod);
     return;
   }
 
   if (sortMethod == SORT_METHOD_LABEL_IGNORE_THE ||
       sortMethod == SORT_METHOD_TITLE_IGNORE_THE ||
       sortMethod == SORT_METHOD_ARTIST_IGNORE_THE ||
       sortMethod == SORT_METHOD_ALBUM_IGNORE_THE ||
       sortMethod == SORT_METHOD_VIDEO_SORT_TITLE_IGNORE_THE ||
       sortMethod == SORT_METHOD_STUDIO_IGNORE_THE)
     sortAttributes = (SortAttribute)((int)sortAttributes | SortAttributeIgnoreArticle);
 
   if (sortMethod == SORT_METHOD_FILE        ||
       sortMethod == SORT_METHOD_VIDEO_SORT_TITLE ||
       sortMethod == SORT_METHOD_VIDEO_SORT_TITLE_IGNORE_THE ||
       sortMethod == SORT_METHOD_LABEL_IGNORE_FOLDERS ||
       sortMethod == SORT_METHOD_DATEADDED ||
       sortMethod == SORT_METHOD_VIDEO_RATING ||
       sortMethod == SORT_METHOD_YEAR ||
       sortMethod == SORT_METHOD_PLAYLIST_ORDER ||
       sortMethod == SORT_METHOD_LASTPLAYED ||
       sortMethod == SORT_METHOD_PLAYCOUNT ||
       m_sortIgnoreFolders)
     sortAttributes = (SortAttribute)((int)sortAttributes | SortAttributeIgnoreFolders);
 
   if (sortBy == SortByNone)
     return;
 
   SortItems sortItems((size_t)Size());
   for (int index = 0; index < Size(); index++)
   {
     m_items[index]->ToSortable(sortItems[index]);
     sortItems[index][FieldId] = index;
   }
 
   // do the sorting
   SortUtils::Sort(sortBy, sortOrder, sortAttributes, sortItems);
 
   // apply the new order to the existing CFileItems
   VECFILEITEMS sortedFileItems;
   sortedFileItems.reserve(Size());
   for (SortItems::const_iterator it = sortItems.begin(); it != sortItems.end(); it++)
   {
     CFileItemPtr item = m_items[(int)it->at(FieldId).asInteger()];
     // Set the sort label in the CFileItem
     item->SetSortLabel(CStdStringW(it->at(FieldSort).asWideString()));
 
     sortedFileItems.push_back(item);
   }
 
   // replace the current list with the re-ordered one
   m_items.assign(sortedFileItems.begin(), sortedFileItems.end());
 
   m_sortMethod = sortMethod;
   m_sortOrder = sortOrder;
 }
 
@@ -2376,10 +2687,12 @@ CStdString CFileItemList::GetDiscFileCache(int windowID) const
 bool CFileItemList::AlwaysCache() const
 {
   // some database folders are always cached
   if (IsMusicDb())
     return CMusicDatabaseDirectory::CanCache(GetPath());
   if (IsVideoDb())
     return CVideoDatabaseDirectory::CanCache(GetPath());
+  if (IsEPG())
+    return true; // always cache
   return false;
 }
 
@@ -2850,2 +3163,34 @@ CVideoInfoTag* CFileItem::GetVideoInfoTag()
 
+CEpgInfoTag* CFileItem::GetEPGInfoTag()
+{
+  if (!m_epgInfoTag)
+    m_epgInfoTag = new CEpgInfoTag;
+
+  return m_epgInfoTag;
+}
+
+CPVRChannel* CFileItem::GetPVRChannelInfoTag()
+{
+  if (!m_pvrChannelInfoTag)
+    m_pvrChannelInfoTag = new CPVRChannel;
+
+  return m_pvrChannelInfoTag;
+}
+
+CPVRRecording* CFileItem::GetPVRRecordingInfoTag()
+{
+  if (!m_pvrRecordingInfoTag)
+    m_pvrRecordingInfoTag = new CPVRRecording;
+
+  return m_pvrRecordingInfoTag;
+}
+
+CPVRTimerInfoTag* CFileItem::GetPVRTimerInfoTag()
+{
+  if (!m_pvrTimerInfoTag)
+    m_pvrTimerInfoTag = new CPVRTimerInfoTag;
+
+  return m_pvrTimerInfoTag;
+}
+
 CPictureInfoTag* CFileItem::GetPictureInfoTag()
diff --git a/xbmc/FileItem.h b/xbmc/FileItem.h
index f32429f..2c77d67 100644
--- a/xbmc/FileItem.h
+++ b/xbmc/FileItem.h
@@ -45,2 +45,12 @@ namespace MUSIC_INFO
 class CVideoInfoTag;
+namespace EPG
+{
+  class CEpgInfoTag;
+}
+namespace PVR
+{
+  class CPVRChannel;
+  class CPVRRecording;
+  class CPVRTimerInfoTag;
+}
 class CPictureInfoTag;
@@ -67,244 +77,306 @@ class CFileItem :
 public:
   CFileItem(void);
   CFileItem(const CFileItem& item);
   CFileItem(const CGUIListItem& item);
   CFileItem(const CStdString& strLabel);
   CFileItem(const CStdString& strPath, bool bIsFolder);
   CFileItem(const CSong& song);
   CFileItem(const CStdString &path, const CAlbum& album);
   CFileItem(const CArtist& artist);
   CFileItem(const CGenre& genre);
   CFileItem(const MUSIC_INFO::CMusicInfoTag& music);
   CFileItem(const CVideoInfoTag& movie);
+  CFileItem(const EPG::CEpgInfoTag& tag);
+  CFileItem(const PVR::CPVRChannel& channel);
+  CFileItem(const PVR::CPVRRecording& record);
+  CFileItem(const PVR::CPVRTimerInfoTag& timer);
   CFileItem(const CMediaSource& share);
   virtual ~CFileItem(void);
   virtual CGUIListItem *Clone() const { return new CFileItem(*this); };
 
   const CStdString &GetPath() const { return m_strPath; };
   void SetPath(const CStdString &path) { m_strPath = path; };
 
   void Reset();
   const CFileItem& operator=(const CFileItem& item);
   virtual void Archive(CArchive& ar);
   virtual void Serialize(CVariant& value);
   virtual void ToSortable(SortItem &sortable);
   virtual bool IsFileItem() const { return true; };
 
   bool Exists(bool bUseCache = true) const;
   bool IsVideo() const;
   bool IsDiscStub() const;
   bool IsPicture() const;
   bool IsLyrics() const;
   bool IsAudio() const;
   bool IsKaraoke() const;
   bool IsCUESheet() const;
   bool IsLastFM() const;
   bool IsInternetStream(const bool bStrictCheck = false) const;
   bool IsPlayList() const;
   bool IsSmartPlayList() const;
   bool IsPythonScript() const;
   bool IsPlugin() const;
   bool IsScript() const;
   bool IsAddonsPath() const;
   bool IsSourcesPath() const;
   bool IsNFO() const;
   bool IsDVDImage() const;
   bool IsOpticalMediaFile() const;
   bool IsDVDFile(bool bVobs = true, bool bIfos = true) const;
   bool IsBDFile() const;
   bool IsRAR() const;
   bool IsAPK() const;
   bool IsZIP() const;
   bool IsCBZ() const;
   bool IsCBR() const;
   bool IsISO9660() const;
   bool IsCDDA() const;
   bool IsDVD() const;
   bool IsOnDVD() const;
   bool IsOnLAN() const;
   bool IsHD() const;
   bool IsNfs() const;  
   bool IsAfp() const;    
   bool IsRemote() const;
   bool IsSmb() const;
   bool IsURL() const;
   bool IsDAAP() const;
   bool IsStack() const;
   bool IsMultiPath() const;
   bool IsMusicDb() const;
   bool IsVideoDb() const;
+  bool IsEPG() const;
+  bool IsPVRChannel() const;
+  bool IsPVRRecording() const;
+  bool IsPVRTimer() const;
   bool IsType(const char *ext) const;
   bool IsVirtualDirectoryRoot() const;
   bool IsReadOnly() const;
   bool CanQueue() const;
   void SetCanQueue(bool bYesNo);
   bool IsParentFolder() const;
   bool IsFileFolder() const;
   bool IsRemovable() const;
   bool IsTuxBox() const;
   bool IsMythTV() const;
   bool IsHDHomeRun() const;
   bool IsSlingbox() const;
   bool IsVTP() const;
+  bool IsPVR() const;
   bool IsLiveTV() const;
   bool IsRSS() const;
   bool IsAndroidApp() const;
 
   void RemoveExtension();
   void CleanString();
   void FillInDefaultIcon();
   void SetFileSizeLabel();
   virtual void SetLabel(const CStdString &strLabel);
+  virtual void SetLabel2(const CStdString &strLabel);
   CURL GetAsUrl() const;
   int GetVideoContentType() const; /* return VIDEODB_CONTENT_TYPE, but don't want to include videodb in this header */
   bool IsLabelPreformated() const { return m_bLabelPreformated; }
   void SetLabelPreformated(bool bYesNo) { m_bLabelPreformated=bYesNo; }
   bool SortsOnTop() const { return m_specialSort == SortSpecialOnTop; }
   bool SortsOnBottom() const { return m_specialSort == SortSpecialOnBottom; }
   void SetSpecialSort(SortSpecial sort) { m_specialSort = sort; }
 
   inline bool HasMusicInfoTag() const
   {
     return m_musicInfoTag != NULL;
   }
 
   MUSIC_INFO::CMusicInfoTag* GetMusicInfoTag();
 
   inline const MUSIC_INFO::CMusicInfoTag* GetMusicInfoTag() const
   {
     return m_musicInfoTag;
   }
 
   inline bool HasVideoInfoTag() const
   {
     return m_videoInfoTag != NULL;
   }
 
   CVideoInfoTag* GetVideoInfoTag();
 
   inline const CVideoInfoTag* GetVideoInfoTag() const
   {
     return m_videoInfoTag;
   }
 
+  inline bool HasEPGInfoTag() const
+  {
+    return m_epgInfoTag != NULL;
+  }
+
+  EPG::CEpgInfoTag* GetEPGInfoTag();
+
+  inline const EPG::CEpgInfoTag* GetEPGInfoTag() const
+  {
+    return m_epgInfoTag;
+  }
+
+  inline bool HasPVRChannelInfoTag() const
+  {
+    return m_pvrChannelInfoTag != NULL;
+  }
+
+  PVR::CPVRChannel* GetPVRChannelInfoTag();
+
+  inline const PVR::CPVRChannel* GetPVRChannelInfoTag() const
+  {
+    return m_pvrChannelInfoTag;
+  }
+
+  inline bool HasPVRRecordingInfoTag() const
+  {
+    return m_pvrRecordingInfoTag != NULL;
+  }
+
+  PVR::CPVRRecording* GetPVRRecordingInfoTag();
+
+  inline const PVR::CPVRRecording* GetPVRRecordingInfoTag() const
+  {
+    return m_pvrRecordingInfoTag;
+  }
+
+  inline bool HasPVRTimerInfoTag() const
+  {
+    return m_pvrTimerInfoTag != NULL;
+  }
+
+  PVR::CPVRTimerInfoTag* GetPVRTimerInfoTag();
+
+  inline const PVR::CPVRTimerInfoTag* GetPVRTimerInfoTag() const
+  {
+    return m_pvrTimerInfoTag;
+  }
+
   inline bool HasPictureInfoTag() const
   {
     return m_pictureInfoTag != NULL;
   }
 
   inline const CPictureInfoTag* GetPictureInfoTag() const
   {
     return m_pictureInfoTag;
   }
 
   CPictureInfoTag* GetPictureInfoTag();
 
   /*!
    \brief Get the local fanart for this item if it exists
    \return path to the local fanart for this item, or empty if none exists
    \sa GetFolderThumb, GetTBNFile
    */
   CStdString GetLocalFanart() const;
 
   // Gets the .tbn file associated with this item
   CStdString GetTBNFile() const;
   // Gets the folder image associated with this item (defaults to folder.jpg)
   CStdString GetFolderThumb(const CStdString &folderJPG = "folder.jpg") const;
   // Gets the correct movie title
   CStdString GetMovieName(bool bUseFolderNames = false) const;
 
   /*! \brief Find the base movie path (i.e. the item the user expects us to use to lookup the movie)
    For folder items, with "use foldernames for lookups" it returns the folder.
    Regardless of settings, for VIDEO_TS/BDMV it returns the parent of the VIDEO_TS/BDMV folder (if present)
 
    \param useFolderNames whether we're using foldernames for lookups
    \return the base movie folder
    */
   CStdString GetBaseMoviePath(bool useFolderNames) const;
 
 #ifdef UNIT_TESTING
   static bool testGetBaseMoviePath();
 #endif
 
   // Gets the user thumb, if it exists
   CStdString GetUserVideoThumb() const;
   CStdString GetUserMusicThumb(bool alwaysCheckRemote = false) const;
 
   /*! \brief Get the path where we expect local metadata to reside.
    For a folder, this is just the existing path (eg tvshow folder)
    For a file, this is the parent path, with exceptions made for VIDEO_TS and BDMV files
 
    Three cases are handled:
 
      /foo/bar/movie_name/file_name          -> /foo/bar/movie_name/
      /foo/bar/movie_name/VIDEO_TS/file_name -> /foo/bar/movie_name/
      /foo/bar/movie_name/BDMV/file_name     -> /foo/bar/movie_name/
 
      \sa URIUtils::GetParentPath
    */
   CStdString GetLocalMetadataPath() const;
 
   // finds a matching local trailer file
   CStdString FindTrailer() const;
 
   virtual bool LoadMusicTag();
 
   /* returns the content type of this item if known. will lookup for http streams */
   const CStdString& GetMimeType(bool lookup = true) const;
 
   /* sets the mime-type if known beforehand */
   void SetMimeType(const CStdString& mimetype) { m_mimetype = mimetype; } ;
 
   /* general extra info about the contents of the item, not for display */
   void SetExtraInfo(const CStdString& info) { m_extrainfo = info; };
   const CStdString& GetExtraInfo() const { return m_extrainfo; };
 
   /*! \brief Update an item with information from another item
    We take metadata information from the given item and supplement the current item
    with that info.  If tags exist in the new item we use the entire tag information.
    Properties are appended, and labels, thumbnail and icon are updated if non-empty
    in the given item.
    \param item the item used to supplement information
    \param replaceLabels whether to replace labels (defaults to true)
    */
   void UpdateInfo(const CFileItem &item, bool replaceLabels = true);
 
   bool IsSamePath(const CFileItem *item) const;
 
   bool IsAlbum() const;
 
   bool m_bIsShareOrDrive;    ///< is this a root share/drive
   int m_iDriveType;     ///< If \e m_bIsShareOrDrive is \e true, use to get the share type. Types see: CMediaSource::m_iDriveType
   CDateTime m_dateTime;             ///< file creation date & time
   int64_t m_dwSize;             ///< file size (0 for folders)
   CStdString m_strDVDLabel;
   CStdString m_strTitle;
   int m_iprogramCount;
   int m_idepth;
   int m_lStartOffset;
   int m_lStartPartNumber;
   int m_lEndOffset;
   LockType m_iLockMode;
   CStdString m_strLockCode;
   int m_iHasLock; // 0 - no lock 1 - lock, but unlocked 2 - locked
   int m_iBadPwdCount;
 
 private:
   CStdString m_strPath;            ///< complete path to item
 
   SortSpecial m_specialSort;
   bool m_bIsParentFolder;
   bool m_bCanQueue;
   bool m_bLabelPreformated;
   CStdString m_mimetype;
   CStdString m_extrainfo;
   MUSIC_INFO::CMusicInfoTag* m_musicInfoTag;
   CVideoInfoTag* m_videoInfoTag;
+  EPG::CEpgInfoTag* m_epgInfoTag;
+  PVR::CPVRChannel* m_pvrChannelInfoTag;
+  PVR::CPVRRecording* m_pvrRecordingInfoTag;
+  PVR::CPVRTimerInfoTag * m_pvrTimerInfoTag;
   CPictureInfoTag* m_pictureInfoTag;
   bool m_bIsAlbum;
 };
 
 /*!
   \brief A shared pointer to CFileItem
   \sa CFileItem
   */