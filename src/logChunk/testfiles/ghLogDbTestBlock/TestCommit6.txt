commit 42ca6d5ebde033ddfdf324187ec3e664c2b75c4f
Author: Jordan DeLong <jdelong@fb.com>
Date:   2013-09-30

    Clean up target cache
    
    Just delete some unused stuff, simplify the Cache<> template
    a lot.  Delete some vestigial things in MethodCache (the Pair,
    keyToPair function, etc).  That's all I'm going to do here for now.
    
    Reviewed By: @markw65
    
    Differential Revision: D990840

diff --git a/hphp/runtime/vm/jit/code-gen.cpp b/hphp/runtime/vm/jit/code-gen.cpp
index 3c8ebbd..26de72c 100644
--- a/hphp/runtime/vm/jit/code-gen.cpp
+++ b/hphp/runtime/vm/jit/code-gen.cpp
@@ -2436,38 +2436,29 @@ void CodeGenerator::cgLdObjClass(IRInstruction* inst) {
 void CodeGenerator::cgLdObjMethod(IRInstruction *inst) {
   auto cls       = inst->src(0);
   auto clsReg    = m_regs[cls].reg();
   auto name      = inst->src(1);
   auto actRec    = inst->src(2);
   auto actRecReg = m_regs[actRec].reg();
-  auto const handle = MethodCache::alloc();
-
-  // lookup in the targetcache
-  if (debug) {
-    MethodCache::Pair p;
-    static_assert(sizeof(p.m_value) == 8,
-                  "MethodCache::Pair::m_value assumed to be 8 bytes");
-    static_assert(sizeof(p.m_key) == 8,
-                  "MethodCache::Pair::m_key assumed to be 8 bytes");
-  }
+  auto const handle = RDS::alloc<MethodCache>().handle();
 
   // preload handle->m_value
-  m_as.loadq(rVmTl[handle + offsetof(MethodCache::Pair, m_value)],
+  m_as.loadq(rVmTl[handle + offsetof(MethodCache, m_value)],
              m_rScratch);
-  m_as.cmpq (rVmTl[handle + offsetof(MethodCache::Pair, m_key)],
+  m_as.cmpq (rVmTl[handle + offsetof(MethodCache, m_key)],
              clsReg);
   ifThenElse(CC_E, // if handle->key == cls
              [&] { // then actReg->m_func = handle->value
                m_as.storeq(m_rScratch, actRecReg[AROFF(m_func)]);
              },
              [&] { // else call slow path helper
                cgCallHelper(m_as,
                             CppCall(methodCacheSlowPath),
                             kVoidDest,
                             SyncOptions::kSyncPoint,
                             ArgGroup(m_regs).addr(rVmTl, handle)
                                             .ssa(actRec)
                                             .ssa(name)
                                             .ssa(cls));
              });
 }
 
diff --git a/hphp/runtime/vm/jit/target-cache.cpp b/hphp/runtime/vm/jit/target-cache.cpp
index f581eb9..cf7e144 100644
--- a/hphp/runtime/vm/jit/target-cache.cpp
+++ b/hphp/runtime/vm/jit/target-cache.cpp
@@ -41,10 +41,9 @@ const StaticString s_call("__call");
 
-inline bool
-stringMatches(const StringData* rowString, const StringData* sd) {
+inline bool stringMatches(const StringData* rowString, const StringData* sd) {
   return rowString &&
     (rowString == sd ||
      rowString->data() == sd->data() ||
      (rowString->hash() == sd->hash() &&
       rowString->same(sd)));
 }
 
@@ -52,11 +51,17 @@ template<class T = void>
 T* handleToPtr(RDS::Handle h) {
   return (T*)((char*)RDS::tl_base + h);
 }
 
+template<class Cache>
+typename Cache::Pair* keyToPair(Cache* cache, const StringData* k) {
+  assert(Util::isPowerOfTwo(Cache::kNumLines));
+  return cache->m_pairs + (k->hash() & (Cache::kNumLines - 1));
 }
 
-//=============================================================================
+}
+
+//////////////////////////////////////////////////////////////////////
 // FuncCache
 
 // Set of FuncCache handles for dynamic function callsites, used for
 // invalidation when a function is renamed.
@@ -65,3 +70,2 @@ static std::vector<RDS::Link<FuncCache> > funcCacheEntries;
 
-template<>
 RDS::Handle FuncCache::alloc() {
@@ -73,235 +77,210 @@ RDS::Handle FuncCache::alloc() {
 
-void invalidateForRenameFunction(const StringData* name) {
-  assert(name);
-  std::lock_guard<std::mutex> g(funcCacheMutex);
-  for (auto& h : funcCacheEntries) {
-    memset(h.get(), 0, sizeof *h);
-  }
-}
-
-template<>
-inline int
-FuncCache::hashKey(const StringData* sd) {
-  return sd->hash();
-}
-
-template<>
-const Func*
-FuncCache::lookup(RDS::Handle handle, StringData *sd, const void* /* ignored */) {
-  auto const thiz = handleToPtr<FuncCache>(handle);
+const Func* FuncCache::lookup(RDS::Handle handle, StringData* sd) {
   Func* func;
-  Pair* pair = thiz->keyToPair(sd);
+  auto const thiz = handleToPtr<FuncCache>(handle);
+  auto const pair = keyToPair(thiz, sd);
   const StringData* pairSd = pair->m_key;
   if (!stringMatches(pairSd, sd)) {
     // Miss. Does it actually exist?
     func = Unit::lookupFunc(sd);
     if (UNLIKELY(!func)) {
       Transl::VMRegAnchor _;
       func = Unit::loadFunc(sd);
       if (!func) {
         raise_error("Undefined function: %s", sd->data());
       }
     }
     func->validate();
-    pair->m_key = func->name(); // use a static name
+    pair->m_key = const_cast<StringData*>(func->name()); // use a static name
     pair->m_value = func;
   }
   // DecRef the string here; more compact than doing so in callers.
   decRefStr(sd);
   assert(stringMatches(pair->m_key, pair->m_value->name()));
   pair->m_value->validate();
   return pair->m_value;
 }
 
-//=============================================================================
-// MethodCache
+void invalidateForRenameFunction(const StringData* name) {
+  assert(name);
+  std::lock_guard<std::mutex> g(funcCacheMutex);
+  for (auto& h : funcCacheEntries) {
+    memset(h.get(), 0, sizeof *h);
+  }
+}
+
+//////////////////////////////////////////////////////////////////////
+// ClassCache
 
-inline int MethodCache::hashKey(uintptr_t c) {
-  pointer_hash<Class> h;
-  return h(reinterpret_cast<const Class*>(c));
+RDS::Handle ClassCache::alloc() {
+  return RDS::alloc<ClassCache,sizeof(Pair)>().handle();
 }
 
+const Class* ClassCache::lookup(RDS::Handle handle, StringData* name) {
+  auto const thiz = handleToPtr<ClassCache>(handle);
+  auto const pair = keyToPair(thiz, name);
+  const StringData* pairSd = pair->m_key;
+  if (!stringMatches(pairSd, name)) {
+    TRACE(1, "ClassCache miss: %s\n", name->data());
+    const NamedEntity *ne = Unit::GetNamedEntity(name);
+    Class *c = Unit::lookupClass(ne);
+    if (UNLIKELY(!c)) {
+      String normName = normalizeNS(name);
+      if (normName) {
+        return lookup(handle, normName.get());
+      } else {
+        c = Unit::loadMissingClass(ne, name);
+      }
+      if (UNLIKELY(!c)) {
+        raise_error(Strings::UNKNOWN_CLASS, name->data());
+      }
+    }
+
+    if (pair->m_key) decRefStr(pair->m_key);
+    pair->m_key = name;
+    name->incRefCount();
+    pair->m_value = c;
+  } else {
+    TRACE(1, "ClassCache hit: %s\n", name->data());
+  }
+  return pair->m_value;
+}
+
+//=============================================================================
+// MethodCache
+
 /*
  * We have a call site for an object method, which previously invoked
  * func, but this call has a different Class (cls).  See if we can
  * figure out the correct Func to call.
  */
 static inline const Func* wouldCall(const Class* cls, const Func* prev) {
   if (LIKELY(cls->numMethods() > prev->methodSlot())) {
     const Func* cand = cls->methods()[prev->methodSlot()];
     /* If this class has the same func at the same method slot
        we're good to go. No need to recheck permissions,
        since we already checked them first time around */
     if (LIKELY(cand == prev)) return cand;
     if (prev->attrs() & AttrPrivate) {
       /* If the previously called function was private, then
          the context class must be prev->cls() - so its
          definitely accessible. So if this derives from
          prev->cls() its the function that would be picked.
          Note that we can only get here if there is a same
          named function deeper in the class hierarchy */
       if (cls->classof(prev->cls())) return prev;
     }
     if (cand->name() == prev->name()) {
       /*
        * We have the same name - so its probably the right function.
        * If its not public, check that both funcs were originally
        * defined in the same base class.
        */
       if ((cand->attrs() & AttrPublic) ||
           cand->baseCls() == prev->baseCls()) {
         return cand;
       }
     }
   }
   return nullptr;
 }
 
-/*
- * This is flagged NEVER_INLINE because if gcc inlines it, it will
- * hoist a bunch of initialization code (callee-saved regs pushes,
- * making a frame, and rsp adjustment) above the fast path.  When not
- * inlined, gcc is generating a jmp to this function instead of a
- * call.
- */
-HOT_FUNC_VM NEVER_INLINE
-void methodCacheSlowPath(MethodCache::Pair* mce,
+HOT_FUNC_VM
+void methodCacheSlowPath(MethodCache* mce,
                          ActRec* ar,
                          StringData* name,
                          Class* cls) {
   assert(ar->hasThis());
   assert(ar->getThis()->getVMClass() == cls);
   assert(IMPLIES(mce->m_key, mce->m_value));
 
   try {
     bool isMagicCall = mce->m_key & 0x1u;
     bool isStatic;
     const Func* func;
 
     auto* storedClass = reinterpret_cast<Class*>(mce->m_key & ~0x3u);
     if (storedClass == cls) {
       isStatic = mce->m_key & 0x2u;
       func = mce->m_value;
     } else {
       if (LIKELY(storedClass != nullptr &&
                  ((func = wouldCall(cls, mce->m_value)) != nullptr) &&
                  !isMagicCall)) {
         Stats::inc(Stats::TgtCache_MethodHit, func != nullptr);
         isMagicCall = false;
       } else {
         Class* ctx = arGetContextClass((ActRec*)ar->m_savedRbp);
         Stats::inc(Stats::TgtCache_MethodMiss);
         TRACE(2, "MethodCache: miss class %p name %s!\n", cls, name->data());
         auto const& objMethod = MethodLookup::CallType::ObjMethod;
         func = g_vmContext->lookupMethodCtx(cls, name, ctx, objMethod, false);
         if (UNLIKELY(!func)) {
           isMagicCall = true;
           func = cls->lookupMethod(s_call.get());
           if (UNLIKELY(!func)) {
             // Do it again, but raise the error this time.
             (void) g_vmContext->lookupMethodCtx(cls, name, ctx, objMethod,
                                                 true);
             NOT_REACHED();
           }
         } else {
           isMagicCall = false;
         }
       }
 
       isStatic = func->attrs() & AttrStatic;
 
       mce->m_key = uintptr_t(cls) | (uintptr_t(isStatic) << 1) |
         uintptr_t(isMagicCall);
       mce->m_value = func;
     }
 
     assert(func);
     func->validate();
     ar->m_func = func;
 
     if (UNLIKELY(isStatic && !func->isClosureBody())) {
       decRefObj(ar->getThis());
       if (debug) ar->setThis(nullptr); // suppress assert in setClass
       ar->setClass(cls);
     }
 
     assert(!ar->hasVarEnv() && !ar->hasInvName());
     if (UNLIKELY(isMagicCall)) {
       ar->setInvName(name);
       assert(name->isStatic()); // No incRef needed.
     }
   } catch (...) {
     /*
      * Barf.
      *
      * If the slow lookup fails, we're going to rewind to the state
      * before the FPushObjMethodD that dumped us here. In this state,
      * the object is still on the stack, but for efficiency reasons,
      * we've smashed this TypedValue* with the ActRec we were trying
      * to push.
      *
      * Reconstitute the virtual object before rethrowing.
      */
     TypedValue* shouldBeObj = reinterpret_cast<TypedValue*>(ar) +
       kNumActRecCells - 1;
     ObjectData* arThis = ar->getThis();
     shouldBeObj->m_type = KindOfObject;
     shouldBeObj->m_data.pobj = arThis;
 
     // There used to be a half-built ActRec on the stack that we need the
     // unwinder to ignore. We overwrote 1/3 of it with the code above, but
     // because of the emitMarker() in LdObjMethod we need the other two slots
     // to not have any TypedValues.
     tvWriteNull(shouldBeObj - 1);
     tvWriteNull(shouldBeObj - 2);
 
     throw;
   }
 }
 
 //=============================================================================
-// ClassCache
-
-template<>
-inline int
-ClassCache::hashKey(StringData* sd) {
-  return sd->hash();
-}
-
-template<>
-const Class*
-ClassCache::lookup(RDS::Handle handle, StringData *name,
-                   const void* unused) {
-  auto const thiz = handleToPtr<ClassCache>(handle);
-  Pair *pair = thiz->keyToPair(name);
-  const StringData* pairSd = pair->m_key;
-  if (!stringMatches(pairSd, name)) {
-    TRACE(1, "ClassCache miss: %s\n", name->data());
-    const NamedEntity *ne = Unit::GetNamedEntity(name);
-    Class *c = Unit::lookupClass(ne);
-    if (UNLIKELY(!c)) {
-      String normName = normalizeNS(name);
-      if (normName) {
-        return lookup(handle, normName.get(), unused);
-      } else {
-        c = Unit::loadMissingClass(ne, name);
-      }
-      if (UNLIKELY(!c)) {
-        raise_error(Strings::UNKNOWN_CLASS, name->data());
-      }
-    }
-
-    if (pair->m_key) decRefStr(pair->m_key);
-    pair->m_key = name;
-    name->incRefCount();
-    pair->m_value = c;
-  } else {
-    TRACE(1, "ClassCache hit: %s\n", name->data());
-  }
-  return pair->m_value;
-}
-
-//=============================================================================
 // *SPropCache
 //
 
diff --git a/hphp/runtime/vm/jit/target-cache.h b/hphp/runtime/vm/jit/target-cache.h
index b8d4e14..dc7a3e4 100644
--- a/hphp/runtime/vm/jit/target-cache.h
+++ b/hphp/runtime/vm/jit/target-cache.h
@@ -32,64 +32,67 @@ namespace HPHP {
 namespace HPHP { namespace JIT {
 
 //////////////////////////////////////////////////////////////////////
 
 /*
- * Some caches have a Lookup != k, because the TC passes a container
- * with other necessary info to Cache::lookup. E.g., when looking up
- * function preludes, we also need the number of arguments. Since
- * the current ActRec encapsulates both, we pass in an ActRec to
- * Cache::lookup even though CallCache maps Funcs to TCAs.
- *
- * KNLines must be a power of two.
+ * Per-callsite dynamic function name lookups (where the name of the
+ * function isn't known at translation time).  4-way cache.
  */
-template<typename Key, typename Value, class LookupKey,
-  int KNLines = 4,
-  typename ReturnValue = Value>
-class Cache {
-public:
-  static const int kNumLines = KNLines;
+struct FuncCache {
+  static constexpr int kNumLines = 4;
 
   struct Pair {
-    Key   m_key;
-    Value m_value;
-  } m_pairs[kNumLines];
-
-  inline Pair* keyToPair(Key k) {
-    if (kNumLines == 1) {
-      return &m_pairs[0];
-    }
-    assert(HPHP::Util::isPowerOfTwo(kNumLines));
-    return m_pairs + (hashKey(k) & (kNumLines - 1));
-  }
-
-private:
-  // Each instance needs to implement this
-  static int hashKey(Key k);
-
-public:
-  typedef Key CacheKey;
-  typedef LookupKey CacheLookupKey;
-  typedef Value CacheValue;
-
-  static RDS::Handle alloc() {
-    return HPHP::RDS::alloc<Cache,sizeof(Pair)>().handle();
-  }
-  static ReturnValue lookup(RDS::Handle chand, LookupKey lookup,
-                            const void* extraKey = nullptr);
+    StringData*  m_key;
+    const Func*  m_value;
+  };
+
+  static RDS::Handle alloc();
+  static const Func* lookup(RDS::Handle, StringData* lookup);
+
+  Pair m_pairs[kNumLines];
 };
 
+/*
+ * In order to handle fb_rename_function (when it is enabled), we need
+ * to invalidate dynamic function call caches (the FuncCache).  This
+ * hook is called when fb_rename_function is used.
+ */
+void invalidateForRenameFunction(const StringData* name);
+
+//////////////////////////////////////////////////////////////////////
+
+/*
+ * Per-callsite dynamic class name lookups (where the name of the
+ * class isn't known at translation time).  4-way cache.
+ */
+struct ClassCache {
+  static constexpr int kNumLines = 4;
+
+  struct Pair {
+    StringData*  m_key;
+    const Class* m_value;
+  };
+
+  static RDS::Handle alloc();
+  static const Class* lookup(RDS::Handle, StringData* lookup);
+
+  Pair m_pairs[kNumLines];
+};
+
+//////////////////////////////////////////////////////////////////////
+
 struct StaticMethodCache {
   const Func* m_func;
   const Class* m_cls;
+
   static RDS::Handle alloc(const StringData* cls,
                       const StringData* meth,
                       const char* ctxName);
   static const Func* lookupIR(RDS::Handle chand,
                               const NamedEntity* ne, const StringData* cls,
                               const StringData* meth, TypedValue* vmfp,
                               TypedValue* vmsp);
   static const Func* lookup(RDS::Handle chand,
                             const NamedEntity* ne, const StringData* cls,
                             const StringData* meth);
 };
 
@@ -106,24 +109,10 @@ struct StaticMethodFCache {
 
-typedef Cache<StringData*,const Class*,StringData*> ClassCache;
-typedef Cache<const StringData*,const Func*,StringData*> FuncCache;
-
-template<> RDS::Handle FuncCache::alloc();
-template<> const Func* FuncCache::lookup(RDS::Handle,
-  StringData*, const void* extraKey);
-template<> const Class* ClassCache::lookup(RDS::Handle,
-  StringData*, const void* extraKey);
-
-/*
- * In order to handle fb_rename_function (when it is enabled), we need
- * to invalidate dynamic function call caches (the FuncCache).  This
- * hook is called when fb_rename_function is used.
- */
-void invalidateForRenameFunction(const StringData* name);
+//////////////////////////////////////////////////////////////////////
 
 /*
  * Static properties.
  *
  * We only cache statically known property name references from within
  * the class.  Current statistics shows in class references dominating
  * by 91.5% of all static property access.
  */
@@ -143,29 +132,31 @@ struct SPropCache {
 
-struct MethodCache {
-  struct Pair {
-    uintptr_t m_key;
-    const Func* m_value;
-  } m_pairs[1];
-
-  inline Pair* keyToPair(uintptr_t k) {
-    return &m_pairs[0];
-  }
-
-  static int hashKey(uintptr_t);
+//////////////////////////////////////////////////////////////////////
 
-  static RDS::Handle alloc() {
-    return ::HPHP::RDS::alloc<MethodCache,alignof(Pair)>()
-      .handle();
-  }
+/*
+ * Method cache entries cache the dispatch target for a function call.
+ * The key is a Class*, but the low bits are reused for other
+ * purposes.  The fast path in the TC doesn't have to check these
+ * bits---it just checks if m_key is bitwise equal to the candidate
+ * Class* it has, and if so it accepts m_value.
+ *
+ * The MethodCache line consists of a Class* key (stored as a
+ * uintptr_t) and a Func*.  The low bit of the key is set if the
+ * function call is a magic call (in which case the cached Func* is
+ * the __call function).  The second lowest bit of the key is set if
+ * the cached Func has AttrStatic.
+ */
+struct MethodCache {
+  uintptr_t m_key;
+  const Func* m_value;
 };
 
-void methodCacheSlowPath(MethodCache::Pair* mce,
+void methodCacheSlowPath(MethodCache* mce,
                          ActRec* ar,
                          StringData* name,
                          Class* cls);
 
 //////////////////////////////////////////////////////////////////////
 
 }}
 
 #endif